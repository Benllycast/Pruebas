CCS PCH C Compiler, Version 4.105, 13255               20-Ago-13 17:56

               Filename: G:\Project\pic\CCS\Pruebas\Nucleo.lst

               ROM used: 9560 bytes (29%)
                         Largest free fragment is 23208
               RAM used: 543 (27%) at main() level
                         665 (32%) worst case
               Stack:    15 worst case (6 in main + 9 for interrupts)

*
0000:  GOTO   2188
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   1C7A
0060:  BTFSS  F9D.2
0062:  GOTO   006C
0066:  BTFSC  F9E.2
0068:  GOTO   1C82
006C:  BTFSS  FA0.0
006E:  GOTO   0078
0072:  BTFSC  FA1.0
0074:  GOTO   1D06
0078:  BTFSS  FA0.5
007A:  GOTO   0084
007E:  BTFSC  FA1.5
0080:  GOTO   1BF2
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "Nucleo.h" 
.................... /*=========================Configuracion del Hardware========================== 
....................  
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentandolo a 96Mhz-> div:2 a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU 
....................  
.................... ==============================================================================*/ 
....................  
.................... /*=================== FILE HEADER ===================================*/ 
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... //#include "PIC18F4550.h" 
.................... #device adc=10 
.................... //#define SIMULACION 1	// comentar esto si se prueba en forma real 
....................  
.................... /*====================fuses de configuracion del dispositivo==================*/ 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN, NOPBADEN 
.................... /* 
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage programing, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//(PLL prescaler) PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4 (whit pll enable)                      
.................... #FUSES USBDIV						//enable USBDIV, USB clock source come from PLL divide by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
....................  
.................... /*============================ DEFINICIONES DE PINES =========================*/ 
.................... #define PIN_SDA	PIN_B0 
.................... #define PIN_SCL	PIN_B1 
.................... #define PIN_XMIT	PIN_C6 
.................... #define PIN_RCV	PIN_C7 
....................  
.................... #define SPI_SS		PIN_D7 
.................... #define SPI_MISO	PIN_D6 
.................... #define SPI_MOSI	PIN_D5 
.................... #define SPI_SCL	PIN_D4 
....................  
....................  
.................... /*=================== CONFIGURACION DEL RELOJ DE TRABAJO =====================*/ 
.................... #use delay(clock=16000000)	//cambiar el valor del clock si se cambia la frecuencia de la CPU 
*
0654:  MOVLW  04
0656:  MOVLB  1
0658:  SUBWF  xBC,F
065A:  BNC   0670
065C:  MOVLW  01
065E:  MOVWF  FEA
0660:  MOVLW  BC
0662:  MOVWF  FE9
0664:  MOVF   FEF,W
0666:  BZ    0670
0668:  BRA    066C
066A:  NOP   
066C:  DECFSZ FEF,F
066E:  BRA    066A
0670:  MOVLB  0
0672:  GOTO   068C (RETURN)
*
1E3C:  MOVLW  01
1E3E:  MOVWF  FEA
1E40:  MOVLW  70
1E42:  MOVWF  FE9
1E44:  MOVF   FEF,W
1E46:  BZ    1E64
1E48:  MOVLW  05
1E4A:  MOVWF  01
1E4C:  CLRF   00
1E4E:  DECFSZ 00,F
1E50:  BRA    1E4E
1E52:  DECFSZ 01,F
1E54:  BRA    1E4C
1E56:  MOVLW  2E
1E58:  MOVWF  00
1E5A:  DECFSZ 00,F
1E5C:  BRA    1E5A
1E5E:  BRA    1E60
1E60:  DECFSZ FEF,F
1E62:  BRA    1E48
1E64:  GOTO   1E8E (RETURN)
....................  
.................... /*=================== CONFIGURACION LIBRERIAS DE COMUNICACION ================*/ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
.................... //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1) 
.................... //#use fixed_io(b_outputs=PIN_B0, PIN_B1) 
.................... //#use i2c(master, FORCE_HW) 
.................... /*=================== LIBRERIAS ESTANDAR PARA EL MANEJO DE DATOS =============*/ 
....................  
.................... #endif	//ifndef NUCLEO_H 
....................  
.................... #use RTOS(timer=0, minor_cycle=10ms, statistics) 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0556:  MOVFF  1B8,1BD
055A:  MOVFF  1B7,1BC
055E:  MOVLB  1
0560:  MOVF   xBB,F
0562:  BZ    05AC
0564:  MOVFF  1BA,03
0568:  MOVFF  1B9,FE9
056C:  MOVFF  1BA,FEA
0570:  MOVF   FEF,F
0572:  BZ    05AC
....................      *s++ = *s2++; 
0574:  MOVFF  1BD,03
0578:  MOVF   xBC,W
057A:  INCF   xBC,F
057C:  BTFSC  FD8.2
057E:  INCF   xBD,F
0580:  MOVWF  xBE
0582:  MOVFF  03,1BF
0586:  MOVFF  1BA,03
058A:  MOVF   xB9,W
058C:  INCF   xB9,F
058E:  BTFSC  FD8.2
0590:  INCF   xBA,F
0592:  MOVWF  FE9
0594:  MOVFF  03,FEA
0598:  MOVFF  FEF,1C0
059C:  MOVFF  1BF,FEA
05A0:  MOVFF  1BE,FE9
05A4:  MOVFF  1C0,FEF
05A8:  DECF   xBB,F
05AA:  BRA    0560
....................   for (; n > 0; n--) 
05AC:  MOVF   xBB,F
05AE:  BZ    05C8
....................      *s++ = '\0'; 
05B0:  MOVFF  1BD,03
05B4:  MOVF   xBC,W
05B6:  INCF   xBC,F
05B8:  BTFSC  FD8.2
05BA:  INCF   xBD,F
05BC:  MOVWF  FE9
05BE:  MOVFF  03,FEA
05C2:  CLRF   FEF
05C4:  DECF   xBB,F
05C6:  BRA    05AC
....................  
....................   return(s1); 
05C8:  MOVFF  1B7,01
05CC:  MOVFF  1B8,02
.................... } 
05D0:  MOVLB  0
05D2:  GOTO   0628 (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
051A:  MOVFF  1B8,1BA
051E:  MOVFF  1B7,1B9
0522:  MOVFF  1BA,03
0526:  MOVLB  1
0528:  MOVFF  1B9,FE9
052C:  MOVFF  1BA,FEA
0530:  MOVF   FEF,F
0532:  BZ    0540
0534:  INCF   xB9,F
0536:  BTFSC  FD8.2
0538:  INCF   xBA,F
053A:  MOVLB  0
053C:  BRA    0522
053E:  MOVLB  1
....................    return(sc - s); 
0540:  MOVF   xB7,W
0542:  SUBWF  xB9,W
0544:  MOVWF  00
0546:  MOVF   xB8,W
0548:  SUBWFB xBA,W
054A:  MOVWF  03
054C:  MOVFF  00,01
.................... } 
0550:  MOVLB  0
0552:  GOTO   05FC (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef SIMULACION 
.................... 	#include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
....................  
.................... extern void usb_cdc_putc_fast(char c); 
.................... extern char usb_cdc_getc(void); 
.................... extern void usb_cdc_putc(char c); 
.................... extern void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... extern float get_float_usb(); 
.................... extern signed long get_long_usb(); 
.................... extern signed int get_int_usb(); 
.................... extern void get_string_usb(char* s, unsigned int max); 
.................... extern BYTE gethex_usb(); 
.................... extern BYTE gethex1_usb(); 
....................  
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
.................... #endif 
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
.................... #define ACC_x		0 
.................... #define ACC_y		1 
.................... #define ACC_z		2 
.................... #define AD_VEL 	3 
.................... #define AD_REV	4 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(unsigned int canal, int16 *buffer); 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
0B64:  MOVLW  08
0B66:  MOVWF  01
0B68:  MOVLW  04
0B6A:  MOVWF  00
0B6C:  DECFSZ 00,F
0B6E:  BRA    0B6C
0B70:  BCF    F8A.1
0B72:  BCF    F93.1
0B74:  MOVLW  04
0B76:  MOVWF  00
0B78:  DECFSZ 00,F
0B7A:  BRA    0B78
0B7C:  MOVLB  1
0B7E:  RLCF   xD1,F
0B80:  BCF    F8A.0
0B82:  BTFSC  FD8.0
0B84:  BSF    F93.0
0B86:  BTFSS  FD8.0
0B88:  BCF    F93.0
0B8A:  BSF    F93.1
0B8C:  BTFSS  F81.1
0B8E:  BRA    0B8C
0B90:  DECFSZ 01,F
0B92:  BRA    0B96
0B94:  BRA    0B9A
0B96:  MOVLB  0
0B98:  BRA    0B68
0B9A:  MOVLW  04
0B9C:  MOVWF  00
0B9E:  DECFSZ 00,F
0BA0:  BRA    0B9E
0BA2:  BCF    F8A.1
0BA4:  BCF    F93.1
0BA6:  NOP   
0BA8:  BSF    F93.0
0BAA:  MOVLW  04
0BAC:  MOVWF  00
0BAE:  DECFSZ 00,F
0BB0:  BRA    0BAE
0BB2:  MOVLW  04
0BB4:  MOVWF  00
0BB6:  DECFSZ 00,F
0BB8:  BRA    0BB6
0BBA:  BSF    F93.1
0BBC:  BTFSS  F81.1
0BBE:  BRA    0BBC
0BC0:  CLRF   01
0BC2:  MOVLW  04
0BC4:  MOVWF  00
0BC6:  DECFSZ 00,F
0BC8:  BRA    0BC6
0BCA:  BTFSC  F81.0
0BCC:  BSF    01.0
0BCE:  BCF    F8A.1
0BD0:  BCF    F93.1
0BD2:  BCF    F8A.0
0BD4:  BCF    F93.0
0BD6:  MOVLB  0
0BD8:  RETLW  00
0BDA:  MOVLW  08
0BDC:  MOVLB  1
0BDE:  MOVWF  xD2
0BE0:  MOVFF  00,1D3
0BE4:  BSF    F93.0
0BE6:  MOVLW  04
0BE8:  MOVWF  00
0BEA:  DECFSZ 00,F
0BEC:  BRA    0BEA
0BEE:  BSF    F93.1
0BF0:  BTFSS  F81.1
0BF2:  BRA    0BF0
0BF4:  BTFSC  F81.0
0BF6:  BSF    FD8.0
0BF8:  BTFSS  F81.0
0BFA:  BCF    FD8.0
0BFC:  RLCF   01,F
0BFE:  MOVLW  04
0C00:  MOVWF  00
0C02:  DECFSZ 00,F
0C04:  BRA    0C02
0C06:  BCF    F93.1
0C08:  BCF    F8A.1
0C0A:  DECFSZ xD2,F
0C0C:  BRA    0BE4
0C0E:  BSF    F93.0
0C10:  MOVLW  04
0C12:  MOVWF  00
0C14:  DECFSZ 00,F
0C16:  BRA    0C14
0C18:  BCF    F8A.0
0C1A:  MOVF   xD3,W
0C1C:  BTFSS  FD8.2
0C1E:  BCF    F93.0
0C20:  NOP   
0C22:  BSF    F93.1
0C24:  BTFSS  F81.1
0C26:  BRA    0C24
0C28:  MOVLW  04
0C2A:  MOVWF  00
0C2C:  DECFSZ 00,F
0C2E:  BRA    0C2C
0C30:  BCF    F8A.1
0C32:  BCF    F93.1
0C34:  MOVLW  04
0C36:  MOVWF  00
0C38:  DECFSZ 00,F
0C3A:  BRA    0C38
0C3C:  BCF    F8A.0
0C3E:  BCF    F93.0
0C40:  MOVLB  0
0C42:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
.................... byte DS_vic = 0x00; 
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_sec = 0x00; 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD		0x55 
.................... #define MEMORIA_CMD_VER_INFO		0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD				0x40 
.................... #define MEMORIA_CMD_READ_FILE		0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK			0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON		0x01 
.................... #define MEMORIA_OFF		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT		12 
.................... #define MEMORIA_NAME_TERMINATOR		0x00 
.................... #define MEMORIA_DELIMITADOR			0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE		0x00 
.................... #define MEMORIA_LOW_PERFORMANCE		0x40 
....................  
.................... #define FILE_WR 1 
.................... #define FILE_RD 0 
....................  
.................... //extern char MEM_info[5]; 
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... void MEMORIA_getinfo(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char* filename, short modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char* data, unsigned int size); 
.................... void MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char* buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA_H 
.................... #define CAPTURA_FRECUENCIA_H 
.................... //canales de lectura 
.................... #define CCP_CANAL_1 1 
.................... #define CCP_CANAL_2 2 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_8|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
.................... int semaforo_ccp = 0; 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... void CP_activar_captura(int canal); 
.................... void CP_desativar_captura(); 
.................... int CP_ocupado(); 
.................... int32 CP_obtener_resultado(); 
....................  
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
.................... #define INDICADOR_AMARILLO	PIN_E0 
.................... #define INDICADOR_USB		PIN_E1 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... char testfile[] = "prueba"; 
.................... int1 salida = 0; 
.................... int myerror = 0; 
.................... int16 lectura = 0; 
.................... //int32 resultado = 0; 
.................... struct Log { 
.................... 	byte dia; 
.................... 	byte mes; 
.................... 	byte anio; 
.................... 	byte hor; 
.................... 	byte min; 
.................... 	byte seg; 
.................... 	int8 sensor; 
.................... 	int8 no_data; 
.................... 	int32 value; 
.................... 	int16 crc; 
.................... } data; 
....................  
.................... void save(){ 
*
08CA:  MOVLB  1
08CC:  CLRF   xB2
08CE:  CLRF   xB3
.................... 	char * bData; 
.................... 	int nBytes = 0, escritos = 0; 
.................... 	/*if(_debug_usb()){ 
.................... 		//printf(usb_cdc_putc,"\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
.................... 		printf("\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
.................... 			DS_dia, DS_mes,DS_anio, 
.................... 			DS_hor,DS_min,DS_sec, sensor, no_data, value); 
.................... 	}  */   
.................... 	printf("\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
.................... 			data.dia, data.mes, data.anio, 
.................... 			data.hor, data.min, data.seg, 
.................... 			data.sensor, data.no_data, data.value); 
08D0:  MOVLW  0A
08D2:  BTFSS  F9E.4
08D4:  BRA    08D2
08D6:  MOVWF  FAD
08D8:  MOVLW  0D
08DA:  BTFSS  F9E.4
08DC:  BRA    08DA
08DE:  MOVWF  FAD
08E0:  MOVFF  43,1B4
08E4:  MOVLW  1B
08E6:  MOVWF  xB5
08E8:  MOVLB  0
08EA:  RCALL  032E
08EC:  MOVLW  2F
08EE:  BTFSS  F9E.4
08F0:  BRA    08EE
08F2:  MOVWF  FAD
08F4:  MOVFF  44,1B4
08F8:  MOVLW  1B
08FA:  MOVLB  1
08FC:  MOVWF  xB5
08FE:  MOVLB  0
0900:  RCALL  032E
0902:  MOVLW  2F
0904:  BTFSS  F9E.4
0906:  BRA    0904
0908:  MOVWF  FAD
090A:  MOVFF  45,1B4
090E:  MOVLW  1B
0910:  MOVLB  1
0912:  MOVWF  xB5
0914:  MOVLB  0
0916:  RCALL  032E
0918:  MOVLW  28
091A:  BTFSS  F9E.4
091C:  BRA    091A
091E:  MOVWF  FAD
0920:  MOVFF  46,1B4
0924:  MOVLW  1B
0926:  MOVLB  1
0928:  MOVWF  xB5
092A:  MOVLB  0
092C:  RCALL  032E
092E:  MOVLW  3A
0930:  BTFSS  F9E.4
0932:  BRA    0930
0934:  MOVWF  FAD
0936:  MOVFF  47,1B4
093A:  MOVLW  1B
093C:  MOVLB  1
093E:  MOVWF  xB5
0940:  MOVLB  0
0942:  RCALL  032E
0944:  MOVLW  3A
0946:  BTFSS  F9E.4
0948:  BRA    0946
094A:  MOVWF  FAD
094C:  MOVFF  48,1B4
0950:  MOVLW  1B
0952:  MOVLB  1
0954:  MOVWF  xB5
0956:  MOVLB  0
0958:  RCALL  032E
095A:  MOVLW  9D
095C:  MOVWF  FF6
095E:  MOVLW  02
0960:  MOVWF  FF7
0962:  MOVLW  04
0964:  MOVLB  1
0966:  MOVWF  xB4
0968:  MOVLB  0
096A:  BRA    03AC
096C:  MOVFF  49,1B4
0970:  MOVLW  1B
0972:  MOVLB  1
0974:  MOVWF  xB5
0976:  MOVLB  0
0978:  RCALL  032E
097A:  MOVLW  20
097C:  BTFSS  F9E.4
097E:  BRA    097C
0980:  MOVWF  FAD
0982:  MOVLW  4E
0984:  BTFSS  F9E.4
0986:  BRA    0984
0988:  MOVWF  FAD
098A:  MOVLW  3A
098C:  BTFSS  F9E.4
098E:  BRA    098C
0990:  MOVWF  FAD
0992:  MOVFF  4A,1B4
0996:  MOVLW  1B
0998:  MOVLB  1
099A:  MOVWF  xB5
099C:  MOVLB  0
099E:  RCALL  032E
09A0:  MOVLW  20
09A2:  BTFSS  F9E.4
09A4:  BRA    09A2
09A6:  MOVWF  FAD
09A8:  MOVLW  56
09AA:  BTFSS  F9E.4
09AC:  BRA    09AA
09AE:  MOVWF  FAD
09B0:  MOVLW  3A
09B2:  BTFSS  F9E.4
09B4:  BRA    09B2
09B6:  MOVWF  FAD
09B8:  MOVLW  41
09BA:  MOVWF  FE9
09BC:  MOVFF  4E,1B7
09C0:  MOVFF  4D,1B6
09C4:  MOVFF  4C,1B5
09C8:  MOVFF  4B,1B4
09CC:  BRA    0458
.................... 	bData = (char *)&data; 
09CE:  MOVLB  1
09D0:  CLRF   xB5
09D2:  MOVLW  43
09D4:  MOVFF  1B5,1B1
09D8:  MOVWF  xB0
.................... 	nBytes = sizeof(data); 
09DA:  MOVLW  0E
09DC:  MOVWF  xB2
.................... 	if((myerror = MEMORIA_open(testfile, FILE_WR)) != 0){ 
09DE:  CLRF   xB5
09E0:  MOVLW  38
09E2:  MOVWF  xB4
09E4:  MOVLW  01
09E6:  MOVWF  xB6
09E8:  MOVLB  0
09EA:  BRA    05D6
09EC:  MOVFF  01,40
09F0:  MOVF   40,F
09F2:  BZ    0A1C
.................... 		printf("\n\rE%u", myerror); 
09F4:  MOVLW  0A
09F6:  BTFSS  F9E.4
09F8:  BRA    09F6
09FA:  MOVWF  FAD
09FC:  MOVLW  0D
09FE:  BTFSS  F9E.4
0A00:  BRA    09FE
0A02:  MOVWF  FAD
0A04:  MOVLW  45
0A06:  BTFSS  F9E.4
0A08:  BRA    0A06
0A0A:  MOVWF  FAD
0A0C:  MOVFF  40,1B4
0A10:  MOVLW  1B
0A12:  MOVLB  1
0A14:  MOVWF  xB5
0A16:  MOVLB  0
0A18:  RCALL  032E
.................... 	}else{ 
0A1A:  BRA    0A88
.................... 		if( (myerror = MEMORIA_write(nBytes)) != 0 ){ 
0A1C:  MOVFF  1B2,1B4
0A20:  BRA    06F2
0A22:  MOVFF  01,40
0A26:  MOVF   40,F
0A28:  BZ    0A52
.................... 			printf("\n\rE%u", myerror); 
0A2A:  MOVLW  0A
0A2C:  BTFSS  F9E.4
0A2E:  BRA    0A2C
0A30:  MOVWF  FAD
0A32:  MOVLW  0D
0A34:  BTFSS  F9E.4
0A36:  BRA    0A34
0A38:  MOVWF  FAD
0A3A:  MOVLW  45
0A3C:  BTFSS  F9E.4
0A3E:  BRA    0A3C
0A40:  MOVWF  FAD
0A42:  MOVFF  40,1B4
0A46:  MOVLW  1B
0A48:  MOVLB  1
0A4A:  MOVWF  xB5
0A4C:  MOVLB  0
0A4E:  RCALL  032E
.................... 		}else{ 
0A50:  BRA    0A88
.................... 			MEMORIA_set_data(bData, nBytes); 
0A52:  MOVFF  1B1,1B5
0A56:  MOVFF  1B0,1B4
0A5A:  MOVFF  1B2,1B6
0A5E:  BRA    07DE
.................... 			printf("\n\rW%u", escritos); 
0A60:  MOVLW  0A
0A62:  BTFSS  F9E.4
0A64:  BRA    0A62
0A66:  MOVWF  FAD
0A68:  MOVLW  0D
0A6A:  BTFSS  F9E.4
0A6C:  BRA    0A6A
0A6E:  MOVWF  FAD
0A70:  MOVLW  57
0A72:  BTFSS  F9E.4
0A74:  BRA    0A72
0A76:  MOVWF  FAD
0A78:  MOVFF  1B3,1B4
0A7C:  MOVLW  1B
0A7E:  MOVLB  1
0A80:  MOVWF  xB5
0A82:  MOVLB  0
0A84:  RCALL  032E
.................... 			MEMORIA_close(); 
0A86:  BRA    0894
.................... 		} 
.................... 	} 
.................... } 
0A88:  RETLW  00
.................... /*======================= declaracion de tareas =======================*/ 
....................  
.................... #task (rate=120ms, max=10ms)  
.................... void Tarea1() 
.................... { 
.................... 	AD_leer_canal(0,&lectura); 
0A8A:  MOVLB  1
0A8C:  CLRF   xB0
0A8E:  CLRF   xB2
0A90:  MOVLW  41
0A92:  MOVWF  xB1
0A94:  MOVLB  0
0A96:  RCALL  02B0
.................... 	data.sensor = 0; 
0A98:  CLRF   49
.................... 	data.value = lectura; 
0A9A:  CLRF   4E
0A9C:  CLRF   4D
0A9E:  MOVFF  42,4C
0AA2:  MOVFF  41,4B
.................... 	++data.no_data; 
0AA6:  INCF   4A,F
.................... 	save(); 
0AA8:  RCALL  08CA
.................... 	rtos_yield(); 
0AAA:  MOVLW  B6
0AAC:  MOVWF  56
0AAE:  MOVLW  0A
0AB0:  MOVWF  57
0AB2:  GOTO   24A4
.................... } 
0AB6:  MOVLW  8A
0AB8:  MOVWF  56
0ABA:  MOVLW  0A
0ABC:  MOVWF  57
0ABE:  GOTO   24A4
....................  
.................... #task (rate=130ms, max=10ms) 
.................... void Tarea2() 
.................... { 
.................... 	AD_leer_canal(1,&lectura); 
0AC2:  MOVLW  01
0AC4:  MOVLB  1
0AC6:  MOVWF  xB0
0AC8:  CLRF   xB2
0ACA:  MOVLW  41
0ACC:  MOVWF  xB1
0ACE:  MOVLB  0
0AD0:  CALL   02B0
.................... 	data.sensor = 1; 
0AD4:  MOVLW  01
0AD6:  MOVWF  49
.................... 	data.value = lectura; 
0AD8:  CLRF   4E
0ADA:  CLRF   4D
0ADC:  MOVFF  42,4C
0AE0:  MOVFF  41,4B
.................... 	++data.no_data; 
0AE4:  INCF   4A,F
.................... 	save(); 
0AE6:  RCALL  08CA
.................... 	rtos_yield(); 
0AE8:  MOVLW  F4
0AEA:  MOVWF  x65
0AEC:  MOVLW  0A
0AEE:  MOVWF  x66
0AF0:  GOTO   24A4
.................... } 
0AF4:  MOVLW  C2
0AF6:  MOVWF  x65
0AF8:  MOVLW  0A
0AFA:  MOVWF  x66
0AFC:  GOTO   24A4
....................  
.................... #task (rate=130ms, max=10ms) 
.................... void Tarea3() 
.................... { 
.................... 	AD_leer_canal(2,&lectura); 
0B00:  MOVLW  02
0B02:  MOVLB  1
0B04:  MOVWF  xB0
0B06:  CLRF   xB2
0B08:  MOVLW  41
0B0A:  MOVWF  xB1
0B0C:  MOVLB  0
0B0E:  CALL   02B0
.................... 	data.sensor = 2; 
0B12:  MOVLW  02
0B14:  MOVWF  49
.................... 	data.value = lectura; 
0B16:  CLRF   4E
0B18:  CLRF   4D
0B1A:  MOVFF  42,4C
0B1E:  MOVFF  41,4B
.................... 	++data.no_data; 
0B22:  INCF   4A,F
.................... 	save(); 
0B24:  RCALL  08CA
.................... 	rtos_yield(); 
0B26:  MOVLW  32
0B28:  MOVWF  x74
0B2A:  MOVLW  0B
0B2C:  MOVWF  x75
0B2E:  GOTO   24A4
.................... } 
0B32:  MOVLW  00
0B34:  MOVWF  x74
0B36:  MOVLW  0B
0B38:  MOVWF  x75
0B3A:  GOTO   24A4
....................  
.................... /* 
.................... #task (rate=40, max=10ms) 
.................... void rpm(){ 
.................... 	if(semaforo_ccp == 0){ 
.................... 		CP_activar_captura(CCP_CANAL_1); 
.................... 	} 
.................... 	//rtos_await(Q_CCP == 2);                        
.................... 	if(Q_CCP != 2){ 
.................... 		rtos_yield();	 
.................... 	} 
.................... 	resultado = CP_obtener_resultado(); 
.................... 	CP_desativar_captura(); 
.................... 	save(4, (numeros++), resultado);                                 
.................... 	rtos_yield(); 
.................... }*/ 
....................  
.................... #task (rate=1s, max=10ms) 
.................... void Indicador() 
.................... {	 
....................    output_bit(INDICADOR_AMARILLO, salida); 
0B3E:  BTFSC  3F.0
0B40:  BRA    0B46
0B42:  BCF    F8D.0
0B44:  BRA    0B48
0B46:  BSF    F8D.0
0B48:  BCF    F96.0
....................    salida = !(salida); 
0B4A:  BTG    3F.0
....................    rtos_yield(); 
0B4C:  MOVLW  58
0B4E:  MOVWF  x83
0B50:  MOVLW  0B
0B52:  MOVWF  x84
0B54:  GOTO   24A4
.................... } 
0B58:  MOVLW  3E
0B5A:  MOVWF  x83
0B5C:  MOVLW  0B
0B5E:  MOVWF  x84
0B60:  GOTO   24A4
....................  
.................... #task (rate=500ms, max=10ms) 
.................... void reloj(){ 
.................... 	ds1307_get_date(data.dia, data.mes, data.anio, DS_vic); 
.................... 	ds1307_get_time(data.hor, data.min, data.seg); 
.................... 	rtos_yield(); 
*
0E38:  MOVLW  44
0E3A:  MOVWF  x92
0E3C:  MOVLW  0E
0E3E:  MOVWF  x93
0E40:  GOTO   24A4
.................... } 
0E44:  MOVLW  6E
0E46:  MOVWF  x92
0E48:  MOVLW  0C
0E4A:  MOVWF  x93
0E4C:  GOTO   24A4
....................  
....................  
.................... //#include "test.c"	// comentar esto en la aplicacion final 
....................  
.................... /*======================= configuracon de dispositivos =======================*/ 
.................... void setup_devices(){ 
....................    myerror = COM_init(); 
*
20E0:  BRA    1E12
20E2:  MOVFF  01,40
....................    myerror = MEMORIA_init_hw(); 
20E6:  BRA    1E68
20E8:  MOVFF  01,40
....................    myerror = MEMORIA_init(); 
20EC:  BRA    1EBA
20EE:  MOVFF  01,40
....................    myerror = AD_init_adc(); 
20F2:  BRA    1F1E
20F4:  MOVFF  01,40
....................    //myerror = CP_init_ccp(); 
....................    ds1307_init(DS1307_OUT_ON_DISABLED_HIHG | DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
20F8:  MOVLW  90
20FA:  MOVLB  1
20FC:  MOVWF  x6F
20FE:  MOVLB  0
2100:  BRA    1F6A
....................    //ds1307_set_date_time(0x0d, 0x01, 0x0d, 0x00, 0x0a, 0x2a, 0x00); 
....................     
....................    /*=================== modulos hw no usados ========================*/ 
....................    setup_psp(PSP_DISABLED); 
2102:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
2104:  BCF    FD1.0
....................    setup_spi(SPI_SS_DISABLED); 
2106:  BCF    FC6.5
2108:  BCF    F94.7
210A:  BSF    F93.0
210C:  BCF    F93.1
210E:  MOVLW  01
2110:  MOVWF  FC6
2112:  MOVLW  00
2114:  MOVWF  FC7
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
2116:  MOVLW  88
2118:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
211A:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
211C:  MOVLW  00
211E:  MOVWF  FCA
2120:  MOVLW  00
2122:  MOVWF  FCB
....................       
....................    #ifndef CAPTURA_FRECUENCIA_H 
.................... 	setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
.................... 	setup_ccp1(CCP_OFF); 
....................    #endif 
....................     
....................    setup_comparator(NC_NC_NC_NC); 
2124:  MOVLW  07
2126:  MOVWF  FB4
2128:  MOVF   F92,W
212A:  MOVWF  F92
212C:  MOVLW  0D
212E:  MOVWF  00
2130:  DECFSZ 00,F
2132:  BRA    2130
2134:  MOVF   FB4,W
2136:  BCF    FA1.6
....................    setup_vref(FALSE); 
2138:  CLRF   FB5
....................     
....................    /*===================para los indicadores========================*/ 
....................    set_tris_e(0x00); 
213A:  MOVLW  00
213C:  MOVWF  F96
....................    set_tris_b(0x00); 
213E:  MOVWF  F93
....................    set_tris_c(0x80);		//configuracion para el modulo de memoria 
2140:  MOVLW  80
2142:  MOVWF  F94
....................    set_tris_d(0x48); 
2144:  MOVLW  48
2146:  MOVWF  F95
....................    output_bit(INDICADOR_USB, 0); 
2148:  BCF    F8D.1
214A:  BCF    F96.1
....................    output_bit(INDICADOR_AMARILLO, 1); 
214C:  BSF    F8D.0
214E:  BCF    F96.0
....................    output_low(SPI_SCL); 
2150:  BCF    F95.4
2152:  BCF    F8C.4
....................    output_high(SPI_SS); 
2154:  BCF    F95.7
2156:  BSF    F8C.7
....................    output_low(SPI_MOSI); 
2158:  BCF    F95.5
215A:  BCF    F8C.5
....................    output_high(SPI_MISO); 
215C:  BCF    F95.6
215E:  BSF    F8C.6
....................    //delay_ms(3000); 
....................    data.dia = data.mes = data.anio = 0; 
2160:  CLRF   45
2162:  MOVFF  45,44
2166:  MOVFF  44,43
....................    data.hor = data.min = data.seg = 0; 
216A:  CLRF   48
216C:  MOVFF  48,47
2170:  MOVFF  47,46
....................    data.value = data.sensor = data.no_data = 0;    
2174:  CLRF   4A
2176:  MOVFF  4A,49
217A:  CLRF   4E
217C:  CLRF   4D
217E:  CLRF   4C
2180:  MOVFF  49,4B
....................    return; 
.................... } 
2184:  GOTO   2364 (RETURN)
....................  
.................... /*=========================================================================== 
.................... ||										 MAIN 													|| 
.................... =============================================================================*/ 
.................... void main(void) { 
2188:  CLRF   FF8
218A:  BCF    FD0.7
218C:  BSF    07.7
218E:  CLRF   FEA
2190:  CLRF   FE9
2192:  BSF    FB8.3
2194:  MOVLW  A0
2196:  MOVWF  FAF
2198:  MOVLW  01
219A:  MOVWF  FB0
219C:  MOVLW  A6
219E:  MOVWF  FAC
21A0:  MOVLW  90
21A2:  MOVWF  FAB
21A4:  CLRF   23
21A6:  CLRF   24
21A8:  CLRF   25
21AA:  CLRF   26
21AC:  CLRF   27
21AE:  CLRF   28
21B0:  CLRF   29
21B2:  MOVLW  FD
21B4:  MOVWF  2A
21B6:  MOVLW  05
21B8:  MOVWF  2B
21BA:  MOVWF  2C
21BC:  MOVLW  FF
21BE:  MOVWF  2D
21C0:  CLRF   2E
21C2:  CLRF   32
21C4:  CLRF   31
21C6:  CLRF   30
21C8:  CLRF   2F
21CA:  CLRF   36
21CC:  CLRF   35
21CE:  CLRF   34
21D0:  CLRF   33
21D2:  CLRF   37
21D4:  BCF    3F.0
21D6:  CLRF   40
21D8:  CLRF   42
21DA:  CLRF   41
21DC:  CLRF   xA4
21DE:  CLRF   xA8
21E0:  CLRF   xFB
21E2:  MOVLB  1
21E4:  CLRF   x01
21E6:  CLRF   x02
21E8:  BSF    FB8.3
21EA:  MOVLW  A0
21EC:  MOVWF  FAF
21EE:  MOVLW  01
21F0:  MOVWF  FB0
21F2:  MOVLW  A6
21F4:  MOVWF  FAC
21F6:  MOVLW  90
21F8:  MOVWF  FAB
21FA:  BCF    3F.2
21FC:  BCF    3F.3
21FE:  BCF    3F.4
2200:  BCF    3F.5
2202:  CLRF   x53
2204:  CLRF   x54
2206:  CLRF   x55
2208:  CLRF   x59
220A:  CLRF   x58
220C:  CLRF   x57
220E:  CLRF   x56
2210:  MOVLW  01
2212:  MOVWF  x6B
2214:  MOVLW  80
2216:  MOVWF  x6C
2218:  MOVLW  40
221A:  MOVWF  x6D
221C:  MOVLW  15
221E:  MOVWF  x6E
2220:  MOVF   FC1,W
2222:  ANDLW  C0
2224:  IORLW  0F
2226:  MOVWF  FC1
2228:  MOVLW  07
222A:  MOVWF  FB4
222C:  MOVLW  03
222E:  MOVWF  1B
2230:  CLRF   1C
2232:  CLRF   1D
2234:  CLRF   1E
2236:  MOVLW  70
2238:  MOVWF  38
223A:  MOVLW  72
223C:  MOVWF  39
223E:  MOVLW  75
2240:  MOVWF  3A
2242:  MOVLW  65
2244:  MOVWF  3B
2246:  MOVLW  62
2248:  MOVWF  3C
224A:  MOVLW  61
224C:  MOVWF  3D
224E:  CLRF   3E
2250:  MOVLB  0
2252:  CLRF   xA0
2254:  MOVLW  04
2256:  MOVWF  xA1
2258:  MOVLW  0C
225A:  MOVWF  xA2
225C:  MOVLW  4C
225E:  MOVLB  1
2260:  MOVWF  x03
2262:  MOVLW  75
2264:  MOVWF  x04
2266:  MOVLW  6E
2268:  MOVWF  x05
226A:  MOVLW  65
226C:  MOVWF  x06
226E:  MOVLW  73
2270:  MOVWF  x07
2272:  CLRF   x08
2274:  CLRF   x09
2276:  CLRF   x0A
2278:  CLRF   x0B
227A:  CLRF   x0C
227C:  CLRF   x0D
227E:  MOVLW  4D
2280:  MOVWF  x0E
2282:  MOVLW  61
2284:  MOVWF  x0F
2286:  MOVLW  72
2288:  MOVWF  x10
228A:  MOVLW  74
228C:  MOVWF  x11
228E:  MOVLW  65
2290:  MOVWF  x12
2292:  MOVLW  73
2294:  MOVWF  x13
2296:  CLRF   x14
2298:  CLRF   x15
229A:  CLRF   x16
229C:  CLRF   x17
229E:  CLRF   x18
22A0:  MOVLW  4D
22A2:  MOVWF  x19
22A4:  MOVLW  69
22A6:  MOVWF  x1A
22A8:  MOVLW  E9
22AA:  MOVWF  x1B
22AC:  MOVLW  72
22AE:  MOVWF  x1C
22B0:  MOVLW  63
22B2:  MOVWF  x1D
22B4:  MOVLW  6F
22B6:  MOVWF  x1E
22B8:  MOVLW  6C
22BA:  MOVWF  x1F
22BC:  MOVLW  65
22BE:  MOVWF  x20
22C0:  MOVLW  73
22C2:  MOVWF  x21
22C4:  CLRF   x22
22C6:  CLRF   x23
22C8:  MOVLW  4A
22CA:  MOVWF  x24
22CC:  MOVLW  75
22CE:  MOVWF  x25
22D0:  MOVLW  65
22D2:  MOVWF  x26
22D4:  MOVLW  76
22D6:  MOVWF  x27
22D8:  MOVLW  65
22DA:  MOVWF  x28
22DC:  MOVLW  73
22DE:  MOVWF  x29
22E0:  CLRF   x2A
22E2:  CLRF   x2B
22E4:  CLRF   x2C
22E6:  CLRF   x2D
22E8:  CLRF   x2E
22EA:  MOVLW  56
22EC:  MOVWF  x2F
22EE:  MOVLW  69
22F0:  MOVWF  x30
22F2:  MOVLW  65
22F4:  MOVWF  x31
22F6:  MOVLW  72
22F8:  MOVWF  x32
22FA:  MOVLW  6E
22FC:  MOVWF  x33
22FE:  MOVLW  65
2300:  MOVWF  x34
2302:  MOVLW  73
2304:  MOVWF  x35
2306:  CLRF   x36
2308:  CLRF   x37
230A:  CLRF   x38
230C:  CLRF   x39
230E:  MOVLW  53
2310:  MOVWF  x3A
2312:  MOVLW  E1
2314:  MOVWF  x3B
2316:  MOVLW  62
2318:  MOVWF  x3C
231A:  MOVLW  61
231C:  MOVWF  x3D
231E:  MOVLW  64
2320:  MOVWF  x3E
2322:  MOVLW  6F
2324:  MOVWF  x3F
2326:  CLRF   x40
2328:  CLRF   x41
232A:  CLRF   x42
232C:  CLRF   x43
232E:  CLRF   x44
2330:  MOVLW  44
2332:  MOVWF  x45
2334:  MOVLW  6F
2336:  MOVWF  x46
2338:  MOVLW  6D
233A:  MOVWF  x47
233C:  MOVLW  69
233E:  MOVWF  x48
2340:  MOVLW  6E
2342:  MOVWF  x49
2344:  MOVLW  67
2346:  MOVWF  x4A
2348:  MOVLW  6F
234A:  MOVWF  x4B
234C:  CLRF   x4C
234E:  CLRF   x4D
2350:  CLRF   x50
2352:  CLRF   x51
2354:  CLRF   x52
2356:  CLRF   x5A
2358:  CLRF   x5B
235A:  CLRF   x5C
235C:  CLRF   x5D
235E:  CLRF   x5E
.................... 	setup_devices(); 
2360:  MOVLB  0
2362:  BRA    20E0
....................    rtos_run(); //A partir de aqu comenzar la ejecucin de las tareas 
2364:  CLRF   51
2366:  CLRF   53
2368:  MOVLW  0C
236A:  MOVWF  52
236C:  CLRF   55
236E:  CLRF   54
2370:  CLRF   5B
2372:  CLRF   5A
2374:  CLRF   59
2376:  CLRF   58
2378:  MOVLW  FF
237A:  MOVWF  5D
237C:  MOVWF  5C
237E:  CLRF   5F
2380:  CLRF   5E
2382:  MOVLW  8A
2384:  MOVWF  56
2386:  MOVLW  0A
2388:  MOVWF  57
238A:  CLRF   x60
238C:  CLRF   x62
238E:  MOVLW  0D
2390:  MOVWF  x61
2392:  CLRF   x64
2394:  CLRF   x63
2396:  CLRF   x6A
2398:  CLRF   x69
239A:  CLRF   x68
239C:  CLRF   x67
239E:  MOVLW  FF
23A0:  MOVWF  x6C
23A2:  MOVWF  x6B
23A4:  CLRF   x6E
23A6:  CLRF   x6D
23A8:  MOVLW  C2
23AA:  MOVWF  x65
23AC:  MOVLW  0A
23AE:  MOVWF  x66
23B0:  CLRF   x6F
23B2:  CLRF   x71
23B4:  MOVLW  0D
23B6:  MOVWF  x70
23B8:  CLRF   x73
23BA:  CLRF   x72
23BC:  CLRF   x79
23BE:  CLRF   x78
23C0:  CLRF   x77
23C2:  CLRF   x76
23C4:  MOVLW  FF
23C6:  MOVWF  x7B
23C8:  MOVWF  x7A
23CA:  CLRF   x7D
23CC:  CLRF   x7C
23CE:  MOVLW  00
23D0:  MOVWF  x74
23D2:  MOVLW  0B
23D4:  MOVWF  x75
23D6:  CLRF   x7E
23D8:  CLRF   x80
23DA:  MOVLW  64
23DC:  MOVWF  x7F
23DE:  CLRF   x82
23E0:  CLRF   x81
23E2:  CLRF   x88
23E4:  CLRF   x87
23E6:  CLRF   x86
23E8:  CLRF   x85
23EA:  MOVLW  FF
23EC:  MOVWF  x8A
23EE:  MOVWF  x89
23F0:  CLRF   x8C
23F2:  CLRF   x8B
23F4:  MOVLW  3E
23F6:  MOVWF  x83
23F8:  MOVLW  0B
23FA:  MOVWF  x84
23FC:  CLRF   x8D
23FE:  CLRF   x8F
2400:  MOVLW  32
2402:  MOVWF  x8E
2404:  CLRF   x91
2406:  CLRF   x90
2408:  CLRF   x97
240A:  CLRF   x96
240C:  CLRF   x95
240E:  CLRF   x94
2410:  MOVLW  FF
2412:  MOVWF  x99
2414:  MOVWF  x98
2416:  CLRF   x9B
2418:  CLRF   x9A
241A:  MOVLW  6E
241C:  MOVWF  x92
241E:  MOVLW  0C
2420:  MOVWF  x93
2422:  CLRF   1A
2424:  MOVLW  88
2426:  MOVWF  FD5
2428:  MOVLW  9E
242A:  MOVWF  FD7
242C:  MOVLW  58
242E:  MOVWF  FD6
2430:  BCF    FF2.2
2432:  MOVLW  88
2434:  MOVWF  FD5
2436:  MOVLW  3C
2438:  MOVWF  FD7
243A:  MOVLW  B0
243C:  MOVWF  FD6
243E:  BCF    FF2.2
2440:  CLRF   1C
2442:  MOVLW  04
2444:  MOVWF  1B
2446:  BCF    FD8.0
2448:  RLCF   1A,W
244A:  MOVWF  00
244C:  CALL   00D2
2450:  MOVWF  02
2452:  MOVLW  01
2454:  ADDWF  00,W
2456:  CALL   00D2
245A:  MOVWF  03
245C:  MOVFF  03,FEA
2460:  MOVFF  02,FE9
2464:  MOVFF  FEF,02
2468:  INCF   FE9,F
246A:  MOVFF  FEF,00
246E:  MOVFF  FEC,01
2472:  INCF   FEC,F
2474:  MOVFF  FEF,03
2478:  BNZ   247E
247A:  INCF   FEC,F
247C:  MOVF   FED,F
247E:  MOVF   FEC,W
2480:  SUBWF  01,W
2482:  BNZ   253C
2484:  MOVF   00,W
2486:  SUBWF  03,W
2488:  BNZ   253C
248A:  MOVF   FED,F
248C:  MOVF   FED,F
248E:  CLRF   FEE
2490:  CLRF   FEE
2492:  BTFSC  02.7
2494:  BRA    253C
2496:  MOVF   FEC,F
2498:  MOVFF  FEC,FFA
249C:  MOVF   FED,F
249E:  MOVFF  FEF,FE8
24A2:  MOVWF  FF9
24A4:  MOVLB  0
24A6:  BCF    FD8.0
24A8:  RLCF   1A,W
24AA:  MOVWF  00
24AC:  CALL   00D2
24B0:  MOVWF  02
24B2:  MOVLW  01
24B4:  ADDWF  00,W
24B6:  CALL   00D2
24BA:  MOVWF  03
24BC:  MOVFF  03,FEA
24C0:  MOVFF  02,FE9
24C4:  BTFSS  FF2.2
24C6:  BRA    24CA
24C8:  BSF    FEF.4
24CA:  MOVLW  07
24CC:  ADDWF  FE9,F
24CE:  MOVLW  00
24D0:  ADDWFC FEA,F
24D2:  MOVF   FD6,W
24D4:  MOVFF  FD7,03
24D8:  ADDLW  50
24DA:  MOVWF  01
24DC:  MOVLW  3C
24DE:  SUBWFB 03,W
24E0:  MOVWF  02
24E2:  MOVF   01,W
24E4:  ADDWF  FEF,F
24E6:  MOVF   02,W
24E8:  ADDWFC FEC,W
24EA:  MOVWF  FEF
24EC:  MOVLW  00
24EE:  ADDWFC FEC,W
24F0:  MOVWF  FEF
24F2:  MOVLW  00
24F4:  ADDWFC FEC,W
24F6:  MOVWF  FEF
24F8:  MOVF   FED,F
24FA:  MOVF   FED,F
24FC:  MOVF   FED,F
24FE:  MOVF   FEC,W
2500:  MOVF   FEC,W
2502:  MOVF   FEC,W
2504:  MOVF   FEC,W
2506:  MOVF   02,W
2508:  SUBWF  FEC,W
250A:  BNC   2520
250C:  BNZ   2516
250E:  MOVF   FED,F
2510:  MOVF   01,W
2512:  SUBWF  FEE,W
2514:  BNC   2520
2516:  MOVF   FED,F
2518:  MOVF   01,W
251A:  MOVWF  FEF
251C:  MOVF   02,W
251E:  MOVWF  FEC
2520:  MOVF   FEE,F
2522:  MOVF   FEC,W
2524:  SUBWF  02,W
2526:  BNC   253C
2528:  BNZ   2532
252A:  MOVF   FED,F
252C:  MOVF   01,W
252E:  SUBWF  FEE,W
2530:  BC    253C
2532:  MOVF   FED,F
2534:  MOVF   01,W
2536:  MOVWF  FEF
2538:  MOVF   02,W
253A:  MOVWF  FEC
253C:  INCF   1A,F
253E:  MOVLW  05
2540:  SUBWF  1A,W
2542:  BNZ   2446
2544:  CLRF   1A
2546:  MOVF   FD6,W
2548:  MOVFF  FD7,03
254C:  BTFSC  FF2.2
254E:  BRA    2436
2550:  BRA    2546
2552:  MOVLW  FF
2554:  MOVWF  1A
.................... } 
....................  
.................... #include "comunicacion.c" 
.................... //#include "Nucleo.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
....................  
.................... extern void usb_cdc_putc_fast(char c); 
.................... extern char usb_cdc_getc(void); 
.................... extern void usb_cdc_putc(char c); 
.................... extern void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... extern float get_float_usb(); 
.................... extern signed long get_long_usb(); 
.................... extern signed int get_int_usb(); 
.................... extern void get_string_usb(char* s, unsigned int max); 
.................... extern BYTE gethex_usb(); 
.................... extern BYTE gethex1_usb(); 
....................  
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// Two examples are provided:                                        //// 
.................... ////      ex_usb_serial.c                                              //// 
.................... ////      ex_usb_serial2.c                                             //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /*============================================================================ 
.................... CDC USB descriptor propio para el manejo de datos por usb 
....................  
....................  
....................  
....................  
....................  
.................... ============================================================================*/ 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x000B 
.................... #define  USB_CONFIG_VID       0x04D8 
.................... #define  USB_CONFIG_BUS_POWER 0x64   		//100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #define USB_HID_DEVICE  FALSE 
.................... #define USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
2556:  SLEEP 
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................     
....................    /*	 
....................    ////////////////////////////////////////// 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................    /////////////////////////////////////////// 
....................    */ 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
....................          0x0B,0x00, //product id   ==10,11 
....................          0x00,0x01, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //#if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          40, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          '_',0, 
....................          'C',0, 
....................          'o',0, 
....................          'n',0, 
....................          't',0, 
....................          'r',0, 
....................          'o',0, 
....................          'l',0, 
....................          '_',0, 
....................          'D',0, 
....................          'e',0, 
....................          'v',0, 
....................          'i',0, 
....................          'c',0, 
....................          'e',0, 
....................          's',0 
....................  
.................... }; 
.................... //#endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
1738:  CLRF   03
173A:  MOVLB  1
173C:  MOVF   xE6,W
173E:  ADDLW  70
1740:  MOVWF  FE9
1742:  MOVLW  0F
1744:  ADDWFC 03,W
1746:  MOVWF  FEA
1748:  MOVF   FEF,F
174A:  BZ    1770
174C:  MOVF   xE6,W
174E:  MULLW  08
1750:  MOVF   FF3,W
1752:  CLRF   xE8
1754:  MOVWF  xE7
1756:  MOVLW  04
1758:  ADDWF  xE7,F
175A:  MOVLW  00
175C:  ADDWFC xE8,F
175E:  MOVFF  1E7,FE9
1762:  MOVLW  04
1764:  ADDWF  xE8,W
1766:  MOVWF  FEA
1768:  MOVFF  FEF,1E7
176C:  BTFSS  xE7.7
176E:  BRA    1774
1770:  MOVLW  00
1772:  BRA    1776
1774:  MOVLW  01
1776:  MOVWF  01
.................... } 
1778:  MOVLB  0
177A:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
1D8A:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1D8C:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1D8E:  MOVLW  08
1D90:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
1D92:  MOVF   F94,W
1D94:  IORLW  30
1D96:  MOVLB  1
1D98:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1D9A:  MOVLB  0
1D9C:  CLRF   xA4
1D9E:  CLRF   19
1DA0:  BTFSC  FF2.7
1DA2:  BSF    19.7
1DA4:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
1DA6:  CALL   0F7E
1DAA:  BTFSC  19.7
1DAC:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
1DAE:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
1DB6:  CLRF   19
1DB8:  BTFSC  FF2.7
1DBA:  BSF    19.7
1DBC:  BCF    FF2.7
....................    usb_token_reset(); 
1DBE:  CALL   0F7E
1DC2:  BTFSC  19.7
1DC4:  BSF    FF2.7
....................    UCON = 0; 
1DC6:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1DC8:  MOVLW  14
1DCA:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
1DCC:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1DCE:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1DD0:  MOVLW  01
1DD2:  MOVWF  xA4
.................... } 
1DD4:  GOTO   1DE4 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
1DB0:  RCALL  1D8A
.................... } 
1DB2:  GOTO   1E18 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
*
1DD8:  BSF    F95.3
1DDA:  BTFSS  F83.3
1DDC:  BRA    1DE6
....................    { 
....................       if (UCON_USBEN==0)  
1DDE:  BTFSC  F6D.3
1DE0:  BRA    1DE4
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1DE2:  BRA    1DB6
....................       } 
....................    } 
....................    else  
1DE4:  BRA    1DEC
....................    { 
....................       if (UCON_USBEN==1)   
1DE6:  BTFSS  F6D.3
1DE8:  BRA    1DEC
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
1DEA:  RCALL  1D8A
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1DEC:  DECFSZ xA4,W
1DEE:  BRA    1E06
1DF0:  BTFSC  F6D.5
1DF2:  BRA    1E06
....................    { 
....................       UIR=0; 
1DF4:  CLRF   F68
....................       UIE=0; 
1DF6:  CLRF   F69
....................       enable_interrupts(INT_USB); 
1DF8:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1DFA:  MOVLW  C0
1DFC:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1DFE:  MOVLW  11
1E00:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1E02:  MOVLW  02
1E04:  MOVWF  xA4
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1E06:  GOTO   1E1A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
177C:  MOVFF  1E1,1E6
1780:  RCALL  1738
1782:  MOVF   01,F
1784:  BZ    184E
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
1786:  MOVLB  1
1788:  MOVF   xE1,W
178A:  MULLW  08
178C:  MOVF   FF3,W
178E:  CLRF   xE7
1790:  MOVWF  xE6
1792:  MOVLW  04
1794:  ADDWF  xE6,F
1796:  MOVLW  00
1798:  ADDWFC xE7,F
179A:  MOVLW  01
179C:  ADDWF  xE6,W
179E:  MOVWF  01
17A0:  MOVLW  00
17A2:  ADDWFC xE7,W
17A4:  MOVWF  03
17A6:  MOVFF  01,FE9
17AA:  MOVLW  04
17AC:  ADDWF  03,W
17AE:  MOVWF  FEA
17B0:  MOVFF  1E2,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
17B4:  MOVF   xE4,W
17B6:  SUBLW  02
17B8:  BNZ   17E8
....................       { 
....................          i = EP_BDxST_I(endpoint); 
17BA:  MOVF   xE1,W
17BC:  MULLW  08
17BE:  MOVF   FF3,W
17C0:  CLRF   xE7
17C2:  MOVWF  xE6
17C4:  MOVLW  04
17C6:  ADDWF  xE6,F
17C8:  MOVLW  00
17CA:  ADDWFC xE7,F
17CC:  MOVFF  1E6,FE9
17D0:  MOVLW  04
17D2:  ADDWF  xE7,W
17D4:  MOVWF  FEA
17D6:  MOVFF  FEF,1E5
....................          if (bit_test(i,6)) 
17DA:  BTFSS  xE5.6
17DC:  BRA    17E2
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
17DE:  CLRF   xE4
....................          else 
17E0:  BRA    17E6
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
17E2:  MOVLW  01
17E4:  MOVWF  xE4
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
17E6:  BRA    180E
17E8:  MOVF   xE4,W
17EA:  SUBLW  04
17EC:  BNZ   180E
....................       { 
....................          i = EP_BDxST_O(endpoint); 
17EE:  MOVF   xE1,W
17F0:  MULLW  08
17F2:  MOVF   FF3,W
17F4:  CLRF   xE7
17F6:  MOVWF  FE9
17F8:  MOVLW  04
17FA:  ADDWF  xE7,W
17FC:  MOVWF  FEA
17FE:  MOVFF  FEF,1E5
....................          if (bit_test(i,6)) 
1802:  BTFSS  xE5.6
1804:  BRA    180C
....................             tgl = USB_DTS_DATA1; 
1806:  MOVLW  01
1808:  MOVWF  xE4
....................          else 
180A:  BRA    180E
....................             tgl = USB_DTS_DATA0; 
180C:  CLRF   xE4
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
180E:  DECFSZ xE4,W
1810:  BRA    1818
....................          i=0xC8;  //DATA1, UOWN 
1812:  MOVLW  C8
1814:  MOVWF  xE5
....................       else //if (tgl == USB_DTS_DATA0)  
1816:  BRA    181C
....................          i=0x88; //DATA0, UOWN 
1818:  MOVLW  88
181A:  MOVWF  xE5
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
181C:  BTFSC  xE3.0
181E:  BSF    xE5.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
1820:  BTFSC  xE3.1
1822:  BSF    xE5.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
1824:  MOVF   xE1,W
1826:  MULLW  08
1828:  MOVF   FF3,W
182A:  CLRF   xE7
182C:  MOVWF  xE6
182E:  MOVLW  04
1830:  ADDWF  xE6,F
1832:  MOVLW  00
1834:  ADDWFC xE7,F
1836:  MOVFF  1E6,FE9
183A:  MOVLW  04
183C:  ADDWF  xE7,W
183E:  MOVWF  FEA
1840:  MOVFF  1E5,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
1844:  MOVLW  01
1846:  MOVWF  01
1848:  BRA    1854
....................    } 
....................    else  
184A:  BRA    184C
184C:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
184E:  MOVLW  00
1850:  MOVWF  01
1852:  MOVLB  1
.................... } 
1854:  MOVLB  0
1856:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
1982:  MOVFF  1D9,1E6
1986:  RCALL  1738
1988:  MOVF   01,F
198A:  BZ    1A0E
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
198C:  MOVLB  1
198E:  MOVF   xD9,W
1990:  MULLW  08
1992:  MOVF   FF3,W
1994:  CLRF   xE2
1996:  MOVWF  xE1
1998:  MOVLW  04
199A:  ADDWF  xE1,F
199C:  MOVLW  00
199E:  ADDWFC xE2,F
19A0:  MOVLW  02
19A2:  ADDWF  xE1,W
19A4:  MOVWF  01
19A6:  MOVLW  00
19A8:  ADDWFC xE2,W
19AA:  MOVWF  03
19AC:  MOVFF  01,FE9
19B0:  MOVLW  04
19B2:  ADDWF  03,W
19B4:  MOVWF  FEA
19B6:  MOVFF  FEC,03
19BA:  MOVF   FED,F
19BC:  MOVFF  FEF,1DF
19C0:  MOVFF  03,1E0
....................       memcpy(buff_add, ptr, len);      
19C4:  MOVFF  1E0,FEA
19C8:  MOVFF  1DF,FE9
19CC:  MOVFF  1DB,FE2
19D0:  MOVFF  1DA,FE1
19D4:  MOVFF  1DD,02
19D8:  MOVFF  1DC,01
19DC:  MOVF   01,F
19DE:  BZ    19E4
19E0:  INCF   02,F
19E2:  BRA    19E8
19E4:  MOVF   02,F
19E6:  BZ    19F4
19E8:  MOVFF  FE6,FEE
19EC:  DECFSZ 01,F
19EE:  BRA    19E8
19F0:  DECFSZ 02,F
19F2:  BRA    19E8
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
19F4:  MOVFF  1D9,1E1
19F8:  MOVFF  1DD,1E3
19FC:  MOVFF  1DC,1E2
1A00:  MOVFF  1DE,1E4
1A04:  MOVLB  0
1A06:  RCALL  177C
1A08:  MOVF   01,W
1A0A:  BRA    1A12
....................    } 
....................    else  
1A0C:  BRA    1A0E
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
1A0E:  MOVLW  00
1A10:  MOVWF  01
.................... } 
1A12:  GOTO   1A30 (RETURN)
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
1678:  MOVLB  1
167A:  MOVF   xD9,W
167C:  MULLW  08
167E:  MOVF   FF3,W
1680:  CLRF   xDF
1682:  MOVWF  FE9
1684:  MOVLW  04
1686:  ADDWF  xDF,W
1688:  MOVWF  FEA
168A:  MOVFF  FEF,1DB
....................    if (tgl == USB_DTS_TOGGLE)  
168E:  MOVF   xDA,W
1690:  SUBLW  02
1692:  BNZ   16A0
....................    { 
....................       if (bit_test(i,6)) 
1694:  BTFSS  xDB.6
1696:  BRA    169C
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
1698:  CLRF   xDA
....................       else 
169A:  BRA    16A0
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
169C:  MOVLW  01
169E:  MOVWF  xDA
....................    } 
....................    if (tgl == USB_DTS_STALL)  
16A0:  MOVF   xDA,W
16A2:  SUBLW  03
16A4:  BNZ   16CC
....................    { 
....................       i = 0x84; 
16A6:  MOVLW  84
16A8:  MOVWF  xDB
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
16AA:  MOVF   xD9,W
16AC:  MULLW  08
16AE:  MOVF   FF3,W
16B0:  CLRF   xDF
16B2:  MOVWF  xDE
16B4:  MOVLW  04
16B6:  ADDWF  xDE,F
16B8:  MOVLW  00
16BA:  ADDWFC xDF,F
16BC:  MOVFF  1DE,FE9
16C0:  MOVLW  04
16C2:  ADDWF  xDF,W
16C4:  MOVWF  FEA
16C6:  MOVLW  84
16C8:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
16CA:  BRA    16DA
16CC:  DECFSZ xDA,W
16CE:  BRA    16D6
....................       i = 0xC8;  //DATA1, UOWN 
16D0:  MOVLW  C8
16D2:  MOVWF  xDB
....................    else //if (tgl == USB_DTS_DATA0)  
16D4:  BRA    16DA
....................       i = 0x88; //DATA0, UOWN 
16D6:  MOVLW  88
16D8:  MOVWF  xDB
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
16DA:  BCF    FD8.0
16DC:  RLCF   xD9,W
16DE:  CLRF   03
16E0:  MOVLB  0
16E2:  CALL   015C
16E6:  TBLRD*+
16E8:  MOVFF  FF5,03
16EC:  MOVLB  1
16EE:  MOVWF  xDC
16F0:  MOVFF  03,1DD
....................    EP_BDxCNT_O(endpoint) = len; 
16F4:  MOVF   xD9,W
16F6:  MULLW  08
16F8:  MOVF   FF3,W
16FA:  CLRF   xDF
16FC:  MOVWF  xDE
16FE:  MOVLW  01
1700:  ADDWF  xDE,W
1702:  MOVWF  01
1704:  MOVLW  00
1706:  ADDWFC xDF,W
1708:  MOVWF  03
170A:  MOVFF  01,FE9
170E:  MOVLW  04
1710:  ADDWF  03,W
1712:  MOVWF  FEA
1714:  MOVFF  1DC,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
1718:  BTFSC  xDD.0
171A:  BSF    xDB.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
171C:  BTFSC  xDD.1
171E:  BSF    xDB.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
1720:  MOVF   xD9,W
1722:  MULLW  08
1724:  MOVF   FF3,W
1726:  CLRF   xDF
1728:  MOVWF  FE9
172A:  MOVLW  04
172C:  ADDWF  xDF,W
172E:  MOVWF  FEA
1730:  MOVFF  1DB,FEF
.................... } 
1734:  MOVLB  0
1736:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
18D8:  MOVLB  1
18DA:  MOVF   xD9,W
18DC:  MULLW  08
18DE:  MOVF   FF3,W
18E0:  CLRF   xDB
18E2:  MOVWF  xDA
18E4:  MOVLW  01
18E6:  ADDWF  xDA,W
18E8:  MOVWF  01
18EA:  MOVLW  00
18EC:  ADDWFC xDB,W
18EE:  MOVWF  03
18F0:  MOVFF  01,FE9
18F4:  MOVLW  04
18F6:  ADDWF  03,W
18F8:  MOVWF  FEA
18FA:  CLRF   03
18FC:  MOVFF  FEF,01
1900:  MOVFF  03,02
.................... } 
1904:  MOVLB  0
1906:  GOTO   192A (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1478:  MOVLB  1
147A:  BCF    xD9.0
147C:  BTFSC  xD8.7
147E:  BSF    xD9.0
....................    endpoint &= 0x7F; 
1480:  BCF    xD8.7
....................     
....................    if (direction)  
1482:  BTFSS  xD9.0
1484:  BRA    14A8
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
1486:  MOVF   xD8,W
1488:  MULLW  08
148A:  MOVF   FF3,W
148C:  CLRF   xDB
148E:  MOVWF  xDA
1490:  MOVLW  04
1492:  ADDWF  xDA,F
1494:  MOVLW  00
1496:  ADDWFC xDB,F
1498:  MOVFF  1DA,FE9
149C:  MOVLW  04
149E:  ADDWF  xDB,W
14A0:  MOVWF  FEA
14A2:  MOVLW  84
14A4:  MOVWF  FEF
....................    } 
....................    else  
14A6:  BRA    14BC
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
14A8:  MOVF   xD8,W
14AA:  MULLW  08
14AC:  MOVF   FF3,W
14AE:  CLRF   xDB
14B0:  MOVWF  FE9
14B2:  MOVLW  04
14B4:  ADDWF  xDB,W
14B6:  MOVWF  FEA
14B8:  MOVLW  84
14BA:  MOVWF  FEF
....................    } 
.................... } 
14BC:  MOVLB  0
14BE:  GOTO   1550 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1430:  MOVLB  1
1432:  BCF    xD9.0
1434:  BTFSC  xD8.7
1436:  BSF    xD9.0
....................    endpoint &= 0x7F; 
1438:  BCF    xD8.7
....................     
....................    if (direction)  
143A:  BTFSS  xD9.0
143C:  BRA    1460
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
143E:  MOVF   xD8,W
1440:  MULLW  08
1442:  MOVF   FF3,W
1444:  CLRF   xDB
1446:  MOVWF  xDA
1448:  MOVLW  04
144A:  ADDWF  xDA,F
144C:  MOVLW  00
144E:  ADDWFC xDB,F
1450:  MOVFF  1DA,FE9
1454:  MOVLW  04
1456:  ADDWF  xDB,W
1458:  MOVWF  FEA
145A:  MOVLW  88
145C:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
145E:  BRA    1472
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
1460:  MOVF   xD8,W
1462:  MULLW  08
1464:  MOVF   FF3,W
1466:  CLRF   xDB
1468:  MOVWF  FE9
146A:  MOVLW  04
146C:  ADDWF  xDB,W
146E:  MOVWF  FEA
1470:  CLRF   FEF
....................    } 
.................... } 
1472:  MOVLB  0
1474:  GOTO   1540 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
14C2:  MOVLB  1
14C4:  BCF    xD9.0
14C6:  BTFSC  xD8.7
14C8:  BSF    xD9.0
....................    endpoint &= 0x7F; 
14CA:  BCF    xD8.7
....................     
....................    if (direction)  
14CC:  BTFSS  xD9.0
14CE:  BRA    14F2
....................    { 
....................       st=EP_BDxST_I(endpoint); 
14D0:  MOVF   xD8,W
14D2:  MULLW  08
14D4:  MOVF   FF3,W
14D6:  CLRF   xDC
14D8:  MOVWF  xDB
14DA:  MOVLW  04
14DC:  ADDWF  xDB,F
14DE:  MOVLW  00
14E0:  ADDWFC xDC,F
14E2:  MOVFF  1DB,FE9
14E6:  MOVLW  04
14E8:  ADDWF  xDC,W
14EA:  MOVWF  FEA
14EC:  MOVFF  FEF,1DA
....................    } 
....................    else  
14F0:  BRA    1506
....................    { 
....................       st=EP_BDxST_O(endpoint); 
14F2:  MOVF   xD8,W
14F4:  MULLW  08
14F6:  MOVF   FF3,W
14F8:  CLRF   xDC
14FA:  MOVWF  FE9
14FC:  MOVLW  04
14FE:  ADDWF  xDC,W
1500:  MOVWF  FEA
1502:  MOVFF  FEF,1DA
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
1506:  BTFSS  xDA.7
1508:  BRA    150E
150A:  BTFSC  xDA.2
150C:  BRA    1512
150E:  MOVLW  00
1510:  BRA    1514
1512:  MOVLW  01
1514:  MOVWF  01
.................... } 
1516:  MOVLB  0
1518:  GOTO   1568 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
1956:  MOVFF  1D9,F6E
....................     
....................    if (address)  
195A:  MOVLB  1
195C:  MOVF   xD9,F
195E:  BZ    196A
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
1960:  MOVLW  04
1962:  MOVLB  0
1964:  MOVWF  xA4
....................    } 
....................    else  
1966:  BRA    1970
1968:  MOVLB  1
....................    { 
....................       usb_state = USB_STATE_POWERED; 
196A:  MOVLW  02
196C:  MOVLB  0
196E:  MOVWF  xA4
....................    } 
.................... } 
1970:  GOTO   197E (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
1124:  MOVLB  1
1126:  MOVF   xD8,F
1128:  BNZ   1136
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
112A:  MOVLW  04
112C:  MOVLB  0
112E:  MOVWF  xA4
....................       usb_disable_endpoints(); 
1130:  RCALL  0F3E
....................    } 
....................    else  
1132:  BRA    12CE
1134:  MOVLB  1
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
1136:  MOVLW  05
1138:  MOVLB  0
113A:  MOVWF  xA4
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
113C:  MOVLW  04
113E:  MOVLB  1
1140:  MOVWF  xDB
1142:  MOVLW  28
1144:  MOVWF  xDA
....................       for (en=1; en<USB_NUM_UEP; en++)  
1146:  MOVLW  01
1148:  MOVWF  xD9
114A:  MOVF   xD9,W
114C:  SUBLW  0F
114E:  BTFSS  FD8.0
1150:  BRA    12CE
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
1152:  MOVFF  1D9,1E1
1156:  MOVLB  0
1158:  RCALL  0EEA
....................          new_uep = 0; 
115A:  MOVLB  1
115C:  CLRF   xDC
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
115E:  CLRF   03
1160:  MOVF   xD9,W
1162:  MOVLB  0
1164:  CALL   010C
1168:  SUBLW  FF
116A:  BZ    1216
....................          { 
....................             new_uep = 0x04; 
116C:  MOVLW  04
116E:  MOVLB  1
1170:  MOVWF  xDC
....................             len = usb_ep_rx_size[en]; 
1172:  BCF    FD8.0
1174:  RLCF   xD9,W
1176:  CLRF   03
1178:  MOVLB  0
117A:  CALL   015C
117E:  TBLRD*+
1180:  MOVFF  FF5,03
1184:  MOVLB  1
1186:  MOVWF  xDD
1188:  MOVFF  03,1DE
....................             EP_BDxCNT_O(en) = len; 
118C:  MOVF   xD9,W
118E:  MULLW  08
1190:  MOVF   FF3,W
1192:  CLRF   xE1
1194:  MOVWF  xE0
1196:  MOVLW  01
1198:  ADDWF  xE0,W
119A:  MOVWF  01
119C:  MOVLW  00
119E:  ADDWFC xE1,W
11A0:  MOVWF  03
11A2:  MOVFF  01,FE9
11A6:  MOVLW  04
11A8:  ADDWF  03,W
11AA:  MOVWF  FEA
11AC:  MOVFF  1DD,FEF
....................             EP_BDxADR_O(en) = addy; 
11B0:  MOVF   xD9,W
11B2:  MULLW  08
11B4:  MOVF   FF3,W
11B6:  CLRF   xE1
11B8:  MOVWF  xE0
11BA:  MOVLW  02
11BC:  ADDWF  xE0,W
11BE:  MOVWF  01
11C0:  MOVLW  00
11C2:  ADDWFC xE1,W
11C4:  MOVWF  03
11C6:  MOVFF  01,FE9
11CA:  MOVLW  04
11CC:  ADDWF  03,W
11CE:  MOVWF  FEA
11D0:  MOVFF  1DB,FEC
11D4:  MOVF   FED,F
11D6:  MOVFF  1DA,FEF
....................             addy += usb_ep_rx_size[en]; 
11DA:  BCF    FD8.0
11DC:  RLCF   xD9,W
11DE:  CLRF   03
11E0:  MOVLB  0
11E2:  CALL   015C
11E6:  TBLRD*+
11E8:  MOVFF  FF5,03
11EC:  MOVLB  1
11EE:  ADDWF  xDA,F
11F0:  MOVF   03,W
11F2:  ADDWFC xDB,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
11F4:  MOVLW  88
11F6:  MOVWF  xDF
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
11F8:  BTFSC  xDE.0
11FA:  BSF    xDF.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
11FC:  BTFSC  xDE.1
11FE:  BSF    xDF.1
....................             EP_BDxST_O(en) = i; 
1200:  MOVF   xD9,W
1202:  MULLW  08
1204:  MOVF   FF3,W
1206:  CLRF   xE1
1208:  MOVWF  FE9
120A:  MOVLW  04
120C:  ADDWF  xE1,W
120E:  MOVWF  FEA
1210:  MOVFF  1DF,FEF
1214:  MOVLB  0
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
1216:  CLRF   03
1218:  MOVLB  1
121A:  MOVF   xD9,W
121C:  MOVLB  0
121E:  CALL   00EC
1222:  SUBLW  FF
1224:  BZ    1296
....................          { 
....................             new_uep |= 0x02; 
1226:  MOVLB  1
1228:  BSF    xDC.1
....................             EP_BDxADR_I(en) = addy; 
122A:  MOVF   xD9,W
122C:  MULLW  08
122E:  MOVF   FF3,W
1230:  CLRF   xE1
1232:  MOVWF  xE0
1234:  MOVLW  04
1236:  ADDWF  xE0,F
1238:  MOVLW  00
123A:  ADDWFC xE1,F
123C:  MOVLW  02
123E:  ADDWF  xE0,W
1240:  MOVWF  01
1242:  MOVLW  00
1244:  ADDWFC xE1,W
1246:  MOVWF  03
1248:  MOVFF  01,FE9
124C:  MOVLW  04
124E:  ADDWF  03,W
1250:  MOVWF  FEA
1252:  MOVFF  1DB,FEC
1256:  MOVF   FED,F
1258:  MOVFF  1DA,FEF
....................             addy += usb_ep_tx_size[en]; 
125C:  BCF    FD8.0
125E:  RLCF   xD9,W
1260:  CLRF   03
1262:  MOVLB  0
1264:  CALL   012C
1268:  TBLRD*+
126A:  MOVFF  FF5,03
126E:  MOVLB  1
1270:  ADDWF  xDA,F
1272:  MOVF   03,W
1274:  ADDWFC xDB,F
....................             EP_BDxST_I(en) = 0x40; 
1276:  MOVF   xD9,W
1278:  MULLW  08
127A:  MOVF   FF3,W
127C:  CLRF   xE1
127E:  MOVWF  xE0
1280:  MOVLW  04
1282:  ADDWF  xE0,F
1284:  MOVLW  00
1286:  ADDWFC xE1,F
1288:  MOVFF  1E0,FE9
128C:  MOVLW  04
128E:  ADDWF  xE1,W
1290:  MOVWF  FEA
1292:  MOVLW  40
1294:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
1296:  MOVLB  1
1298:  MOVF   xDC,W
129A:  SUBLW  06
129C:  BNZ   12A2
129E:  MOVLW  0E
12A0:  MOVWF  xDC
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
12A2:  CLRF   03
12A4:  MOVF   xD9,W
12A6:  MOVLB  0
12A8:  CALL   00EC
12AC:  SUBLW  01
12AE:  BZ    12B6
12B0:  MOVLB  1
12B2:  BSF    xDC.4
12B4:  MOVLB  0
....................           
....................          UEP(en) = new_uep; 
12B6:  CLRF   03
12B8:  MOVLB  1
12BA:  MOVF   xD9,W
12BC:  ADDLW  70
12BE:  MOVWF  FE9
12C0:  MOVLW  0F
12C2:  ADDWFC 03,W
12C4:  MOVWF  FEA
12C6:  MOVFF  1DC,FEF
....................       } 
12CA:  INCF   xD9,F
12CC:  BRA    114A
12CE:  MOVLB  0
....................    } 
.................... } 
12D0:  GOTO   137C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0EEA:  CLRF   03
0EEC:  MOVLB  1
0EEE:  MOVF   xE1,W
0EF0:  ADDLW  70
0EF2:  MOVWF  FE9
0EF4:  MOVLW  0F
0EF6:  ADDWFC 03,W
0EF8:  MOVWF  FEA
0EFA:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0EFC:  MOVFF  1E1,1E2
0F00:  MOVLB  0
0F02:  RCALL  0E96
0F04:  MOVF   01,F
0F06:  BZ    0F3A
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
0F08:  MOVLB  1
0F0A:  MOVF   xE1,W
0F0C:  MULLW  08
0F0E:  MOVF   FF3,W
0F10:  CLRF   xE3
0F12:  MOVWF  FE9
0F14:  MOVLW  04
0F16:  ADDWF  xE3,W
0F18:  MOVWF  FEA
0F1A:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
0F1C:  MOVF   xE1,W
0F1E:  MULLW  08
0F20:  MOVF   FF3,W
0F22:  CLRF   xE3
0F24:  MOVWF  xE2
0F26:  MOVLW  04
0F28:  ADDWF  xE2,F
0F2A:  MOVLW  00
0F2C:  ADDWFC xE3,F
0F2E:  MOVFF  1E2,FE9
0F32:  MOVLW  04
0F34:  ADDWF  xE3,W
0F36:  MOVWF  FEA
0F38:  CLRF   FEF
0F3A:  MOVLB  0
....................    } 
.................... } 
0F3C:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
0F3E:  MOVLW  01
0F40:  MOVLB  1
0F42:  MOVWF  xE0
0F44:  MOVF   xE0,W
0F46:  SUBLW  0F
0F48:  BNC   0F58
....................       usb_disable_endpoint(i); 
0F4A:  MOVFF  1E0,1E1
0F4E:  MOVLB  0
0F50:  RCALL  0EEA
0F52:  MOVLB  1
0F54:  INCF   xE0,F
0F56:  BRA    0F44
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
0F58:  MOVLB  0
0F5A:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
1BF2:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
1BF4:  MOVF   xA4,F
1BF6:  BNZ   1BFA
1BF8:  BRA    1C76
....................    if (UIR)  
1BFA:  MOVF   F68,F
1BFC:  BZ    1C76
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
1BFE:  BTFSS  F68.2
1C00:  BRA    1C0A
1C02:  BTFSS  F69.2
1C04:  BRA    1C0A
1C06:  GOTO   0E50
....................  
....................       if (UCON_SUSPND) return; 
1C0A:  BTFSS  F6D.1
1C0C:  BRA    1C10
1C0E:  BRA    1C76
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
1C10:  BTFSS  F68.5
1C12:  BRA    1C1C
1C14:  BTFSS  F69.5
1C16:  BRA    1C1C
1C18:  GOTO   0E80
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
1C1C:  BTFSS  F68.1
1C1E:  BRA    1C28
1C20:  BTFSS  F69.1
1C22:  BRA    1C28
1C24:  GOTO   0E8E
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
1C28:  BTFSS  F68.0
1C2A:  BRA    1C34
1C2C:  BTFSS  F69.0
1C2E:  BRA    1C34
1C30:  GOTO   0FAA
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
1C34:  BTFSS  F68.4
1C36:  BRA    1C40
1C38:  BTFSS  F69.4
1C3A:  BRA    1C40
1C3C:  GOTO   0FD6
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
1C40:  BTFSS  F68.6
1C42:  BRA    1C4C
1C44:  BTFSS  F69.6
1C46:  BRA    1C4C
1C48:  GOTO   0FE0
....................  
....................       TRNAttempts = 0; 
1C4C:  MOVLB  1
1C4E:  CLRF   xD5
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
1C50:  BTFSS  F68.3
1C52:  BRA    1C68
1C54:  BTFSS  F69.3
1C56:  BRA    1C68
....................          { 
....................             USTATCopy = U1STAT; 
1C58:  MOVFF  F6C,A3
....................             usb_clear_trn(); 
1C5C:  MOVLB  0
1C5E:  CALL   0004
....................             usb_isr_tok_dne(); 
1C62:  BRA    1A72
....................          } 
....................          else 
1C64:  BRA    1C6A
1C66:  MOVLB  1
....................             break; 
1C68:  BRA    1C74
....................       } while (TRNAttempts++ < 4); 
1C6A:  MOVLB  1
1C6C:  MOVF   xD5,W
1C6E:  INCF   xD5,F
1C70:  SUBLW  03
1C72:  BC    1C50
1C74:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
1C76:  GOTO   0084
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
0FE0:  BCF    F68.6
.................... } 
0FE2:  GOTO   1C4C (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
0FAA:  CLRF   F6A
....................    UIR = 0; 
0FAC:  CLRF   F68
....................    UEIE = 0x9F; 
0FAE:  MOVLW  9F
0FB0:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0FB2:  MOVLW  3D
0FB4:  MOVWF  F69
....................  
....................    UADDR = 0; 
0FB6:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
0FB8:  RCALL  0F3E
....................     
....................    usb_token_reset(); 
0FBA:  RCALL  0F7E
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
0FBC:  MOVLW  16
0FBE:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
0FC0:  BTFSS  F68.3
0FC2:  BRA    0FCA
....................       usb_clear_trn(); 
0FC4:  CALL   0004
....................    } 
0FC8:  BRA    0FC0
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0FCA:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
0FCC:  RCALL  0E60
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0FCE:  MOVLW  03
0FD0:  MOVWF  xA4
.................... } 
0FD2:  GOTO   1C34 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
0E60:  MOVLW  08
0E62:  MOVLB  4
0E64:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0E66:  MOVLW  04
0E68:  MOVWF  x03
0E6A:  MOVLW  18
0E6C:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0E6E:  MOVLW  88
0E70:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0E72:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0E74:  MOVLW  04
0E76:  MOVWF  x07
0E78:  MOVLW  20
0E7A:  MOVWF  x06
.................... } 
0E7C:  MOVLB  0
0E7E:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0E8E:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
0E90:  BCF    F68.1
.................... } 
0E92:  GOTO   1C28 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0FD6:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0FD8:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0FDA:  BSF    F6D.1
.................... } 
0FDC:  GOTO   1C40 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
0E50:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
0E52:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
0E54:  BTFSS  F68.2
0E56:  BRA    0E5C
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0E58:  BCF    F68.2
....................    } 
0E5A:  BRA    0E54
.................... } 
0E5C:  GOTO   1C0A (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
0E80:  BTFSS  F70.0
0E82:  BRA    0E88
....................    { 
....................       usb_init_ep0_setup(); 
0E84:  RCALL  0E60
....................       bit_clear(UEP(0), 0); 
0E86:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0E88:  BCF    F68.5
.................... } 
0E8A:  GOTO   1C1C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0FE6:  MOVFF  1DB,A5
0FEA:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
1586:  MOVLW  FE
1588:  MOVWF  xA5
158A:  RETLW  00
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
0FEC:  MOVLW  FF
0FEE:  MOVWF  xA5
0FF0:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
1A72:  RRCF   xA3,W
1A74:  MOVLB  1
1A76:  MOVWF  xD6
1A78:  RRCF   xD6,F
1A7A:  RRCF   xD6,F
1A7C:  MOVLW  1F
1A7E:  ANDWF  xD6,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
1A80:  MOVLB  0
1A82:  MOVF   xA3,F
1A84:  BNZ   1B26
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
1A86:  MOVLB  4
1A88:  MOVF   x00,W
1A8A:  ANDLW  3C
1A8C:  MOVLB  1
1A8E:  MOVWF  xD7
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
1A90:  MOVLW  43
1A92:  MOVLB  4
1A94:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
1A96:  MOVLB  1
1A98:  MOVF   xD7,W
1A9A:  SUBLW  34
1A9C:  BNZ   1AE8
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
1A9E:  MOVLB  4
1AA0:  MOVF   x04,W
1AA2:  ANDLW  80
1AA4:  BZ    1AA8
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
1AA6:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
1AA8:  MOVLB  0
1AAA:  BRA    1644
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
1AAC:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
1AAE:  INCFSZ xA5,W
1AB0:  BRA    1AC0
....................             usb_flush_out(0, USB_DTS_STALL); 
1AB2:  MOVLB  1
1AB4:  CLRF   xD9
1AB6:  MOVLW  03
1AB8:  MOVWF  xDA
1ABA:  MOVLB  0
1ABC:  RCALL  1678
....................          else  
1ABE:  BRA    1AE4
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
1AC0:  MOVLB  1
1AC2:  CLRF   xD9
1AC4:  MOVLW  02
1AC6:  MOVWF  xDA
1AC8:  MOVLB  0
1ACA:  RCALL  1678
....................             if (__setup_0_tx_size != 0xFE) 
1ACC:  MOVF   xA5,W
1ACE:  SUBLW  FE
1AD0:  BZ    1AE4
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
1AD2:  MOVLB  1
1AD4:  CLRF   xE1
1AD6:  CLRF   xE3
1AD8:  MOVFF  A5,1E2
1ADC:  MOVLW  04
1ADE:  MOVWF  xE4
1AE0:  MOVLB  0
1AE2:  RCALL  177C
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
1AE4:  BRA    1B20
1AE6:  MOVLB  1
1AE8:  MOVF   xD7,W
1AEA:  SUBLW  04
1AEC:  BNZ   1B22
....................       { 
....................          usb_isr_tok_out_dne(0); 
1AEE:  CLRF   xD8
1AF0:  MOVLB  0
1AF2:  RCALL  1938
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
1AF4:  MOVLB  1
1AF6:  CLRF   xD9
1AF8:  MOVLW  02
1AFA:  MOVWF  xDA
1AFC:  MOVLB  0
1AFE:  RCALL  1678
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
1B00:  MOVF   xA5,W
1B02:  SUBLW  FE
1B04:  BZ    1B1E
1B06:  INCFSZ xA5,W
1B08:  BRA    1B0C
1B0A:  BRA    1B1E
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
1B0C:  MOVLB  1
1B0E:  CLRF   xE1
1B10:  CLRF   xE3
1B12:  MOVFF  A5,1E2
1B16:  MOVLW  01
1B18:  MOVWF  xE4
1B1A:  MOVLB  0
1B1C:  RCALL  177C
....................          } 
....................       } 
....................       else 
1B1E:  BRA    1B20
1B20:  MOVLB  1
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
1B22:  BRA    1BEC
1B24:  MOVLB  0
1B26:  MOVF   xA3,W
1B28:  SUBLW  04
1B2A:  BNZ   1B5C
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
1B2C:  MOVLW  43
1B2E:  MOVLB  4
1B30:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
1B32:  MOVLW  FF
1B34:  MOVLB  0
1B36:  MOVWF  xA5
....................       usb_isr_tok_in_dne(0); 
1B38:  MOVLB  1
1B3A:  CLRF   xD8
1B3C:  MOVLB  0
1B3E:  RCALL  1A44
....................       if (__setup_0_tx_size!=0xFF) 
1B40:  INCFSZ xA5,W
1B42:  BRA    1B46
1B44:  BRA    1B5A
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
1B46:  MOVLB  1
1B48:  CLRF   xE1
1B4A:  CLRF   xE3
1B4C:  MOVFF  A5,1E2
1B50:  MOVLW  02
1B52:  MOVWF  xE4
1B54:  MOVLB  0
1B56:  RCALL  177C
....................       else 
1B58:  BRA    1B5A
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
1B5A:  BRA    1BEA
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
1B5C:  BTFSC  xA3.2
1B5E:  BRA    1B9A
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
1B60:  MOVLB  1
1B62:  MOVF   xD6,W
1B64:  MULLW  08
1B66:  MOVF   FF3,W
1B68:  CLRF   xD9
1B6A:  MOVWF  01
1B6C:  MOVLW  04
1B6E:  ADDWF  xD9,W
1B70:  MOVWF  03
1B72:  MOVF   xD6,W
1B74:  MULLW  08
1B76:  MOVF   FF3,W
1B78:  CLRF   xDB
1B7A:  MOVWF  FE9
1B7C:  MOVLW  04
1B7E:  ADDWF  xDB,W
1B80:  MOVWF  FEA
1B82:  MOVF   FEF,W
1B84:  ANDLW  43
1B86:  MOVFF  03,FEA
1B8A:  MOVFF  01,FE9
1B8E:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
1B90:  MOVFF  1D6,1D8
1B94:  MOVLB  0
1B96:  RCALL  1938
....................       } 
....................       else  
1B98:  BRA    1BEA
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
1B9A:  MOVLB  1
1B9C:  MOVF   xD6,W
1B9E:  MULLW  08
1BA0:  MOVF   FF3,W
1BA2:  CLRF   xD9
1BA4:  MOVWF  xD8
1BA6:  MOVLW  04
1BA8:  ADDWF  xD8,F
1BAA:  MOVLW  00
1BAC:  ADDWFC xD9,F
1BAE:  MOVFF  1D8,01
1BB2:  MOVLW  04
1BB4:  ADDWF  xD9,W
1BB6:  MOVWF  03
1BB8:  MOVF   xD6,W
1BBA:  MULLW  08
1BBC:  MOVF   FF3,W
1BBE:  CLRF   xDB
1BC0:  MOVWF  xDA
1BC2:  MOVLW  04
1BC4:  ADDWF  xDA,F
1BC6:  MOVLW  00
1BC8:  ADDWFC xDB,F
1BCA:  MOVFF  1DA,FE9
1BCE:  MOVLW  04
1BD0:  ADDWF  xDB,W
1BD2:  MOVWF  FEA
1BD4:  MOVF   FEF,W
1BD6:  ANDLW  43
1BD8:  MOVFF  03,FEA
1BDC:  MOVFF  1D8,FE9
1BE0:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
1BE2:  MOVFF  1D6,1D8
1BE6:  MOVLB  0
1BE8:  RCALL  1A44
1BEA:  MOVLB  1
....................       } 
....................    } 
.................... } 
1BEC:  MOVLB  0
1BEE:  GOTO   1C64 (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1E0A:  MOVF   x9D,W
1E0C:  MOVWF  01
.................... } 
1E0E:  GOTO   1E22 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
0F7E:  MOVLB  1
0F80:  CLRF   xD6
0F82:  MOVF   xD6,W
0F84:  SUBLW  01
0F86:  BNC   0F9C
....................       USB_Interface[i] = 0;   //reset each interface to default 
0F88:  CLRF   03
0F8A:  MOVF   xD6,W
0F8C:  ADDLW  A9
0F8E:  MOVWF  FE9
0F90:  MOVLW  00
0F92:  ADDWFC 03,W
0F94:  MOVWF  FEA
0F96:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
0F98:  INCF   xD6,F
0F9A:  BRA    0F82
....................    usb_cdc_init(); 
0F9C:  MOVLB  0
0F9E:  RCALL  0F5C
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0FA0:  CLRF   x9D
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0FA2:  MOVLW  01
0FA4:  MOVWF  x9E
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0FA6:  CLRF   x9C
.................... } 
0FA8:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0E96:  MOVLB  1
0E98:  BCF    xE3.0
0E9A:  BTFSC  xE2.7
0E9C:  BSF    xE3.0
....................     
....................    endpoint &= 0x7F; 
0E9E:  BCF    xE2.7
....................     
....................    if (endpoint > 16) 
0EA0:  MOVF   xE2,W
0EA2:  SUBLW  10
0EA4:  BC    0EAC
....................       return(FALSE); 
0EA6:  MOVLW  00
0EA8:  MOVWF  01
0EAA:  BRA    0EE6
....................     
....................    if (direction) { //IN 
0EAC:  BTFSS  xE3.0
0EAE:  BRA    0ECC
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
0EB0:  CLRF   03
0EB2:  MOVF   xE2,W
0EB4:  MOVLB  0
0EB6:  CALL   00EC
0EBA:  SUBLW  FF
0EBC:  BNZ   0EC2
0EBE:  MOVLW  00
0EC0:  BRA    0EC4
0EC2:  MOVLW  01
0EC4:  MOVWF  01
0EC6:  MOVLB  1
0EC8:  BRA    0EE6
....................    } 
....................    else {   //OUT 
0ECA:  BRA    0EE6
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
0ECC:  CLRF   03
0ECE:  MOVF   xE2,W
0ED0:  MOVLB  0
0ED2:  CALL   010C
0ED6:  SUBLW  FF
0ED8:  BNZ   0EDE
0EDA:  MOVLW  00
0EDC:  BRA    0EE0
0EDE:  MOVLW  01
0EE0:  MOVWF  01
0EE2:  MOVLB  1
0EE4:  BRA    0EE6
....................    } 
.................... } 
0EE6:  MOVLB  0
0EE8:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
1A44:  MOVLB  1
1A46:  MOVF   xD8,F
1A48:  BNZ   1A62
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
1A4A:  MOVLB  0
1A4C:  DECFSZ x9C,W
1A4E:  BRA    1A56
1A50:  CALL   0FF2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
1A54:  BRA    1A5E
1A56:  MOVF   x9C,W
1A58:  SUBLW  02
1A5A:  BNZ   1A5E
1A5C:  BRA    1974
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
1A5E:  BRA    1A6C
1A60:  MOVLB  1
1A62:  MOVF   xD8,W
1A64:  SUBLW  02
1A66:  BNZ   1A6E
....................       usb_isr_tok_in_cdc_data_dne(); 
1A68:  MOVLB  0
1A6A:  BRA    1A3A
1A6C:  MOVLB  1
....................   } 
....................   #endif 
.................... } 
1A6E:  MOVLB  0
1A70:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
1938:  MOVLB  1
193A:  MOVF   xD8,F
193C:  BNZ   1946
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
193E:  MOVLB  0
1940:  BRA    1858
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
1942:  BRA    1950
1944:  MOVLB  1
1946:  MOVF   xD8,W
1948:  SUBLW  02
194A:  BNZ   1952
....................       usb_isr_tok_out_cdc_data_dne(); 
194C:  MOVLB  0
194E:  BRA    191C
1950:  MOVLB  1
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
1952:  MOVLB  0
1954:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
1644:  CLRF   x9C
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
1646:  MOVLB  4
1648:  MOVF   x18,W
164A:  ANDLW  7F
164C:  XORLW  00
164E:  MOVLB  0
1650:  BZ    1660
1652:  XORLW  01
1654:  BZ    1664
1656:  XORLW  03
1658:  BZ    1668
165A:  XORLW  23
165C:  BZ    166C
165E:  BRA    1670
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
1660:  BRA    12D4
....................          break; 
1662:  BRA    1674
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
1664:  BRA    1390
....................          break; 
1666:  BRA    1674
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
1668:  BRA    151C
....................          break; 
166A:  BRA    1674
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
166C:  BRA    158C
....................          break; 
166E:  BRA    1674
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
1670:  RCALL  0FEC
....................          break; 
1672:  BRA    1674
....................    } 
.................... } 
1674:  GOTO   1AAC (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
12D4:  MOVLB  4
12D6:  MOVF   x19,W
12D8:  XORLW  00
12DA:  MOVLB  0
12DC:  BZ    12F8
12DE:  XORLW  01
12E0:  BZ    130C
12E2:  XORLW  02
12E4:  BZ    1328
12E6:  XORLW  06
12E8:  BZ    1342
12EA:  XORLW  03
12EC:  BZ    1354
12EE:  XORLW  0E
12F0:  BZ    1358
12F2:  XORLW  01
12F4:  BZ    1368
12F6:  BRA    1388
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
12F8:  MOVFF  9E,420
....................             usb_ep0_tx_buffer[1]=0; 
12FC:  MOVLB  4
12FE:  CLRF   x21
....................             usb_request_send_response(2); 
1300:  MOVLW  02
1302:  MOVLB  1
1304:  MOVWF  xDB
1306:  MOVLB  0
1308:  RCALL  0FE6
....................             break; 
130A:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
130C:  MOVLB  4
130E:  DECFSZ x1A,W
1310:  BRA    1322
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
1312:  MOVLW  01
1314:  MOVLB  0
1316:  ANDWF  x9E,F
....................                usb_put_0len_0(); 
1318:  MOVLB  1
131A:  CLRF   xDB
131C:  MOVLB  0
131E:  RCALL  0FE6
....................             } 
....................             else 
1320:  BRA    1326
....................                usb_request_stall(); 
1322:  MOVLB  0
1324:  RCALL  0FEC
....................             break; 
1326:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1328:  MOVLB  4
132A:  DECFSZ x1A,W
132C:  BRA    133C
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
132E:  MOVLB  0
1330:  BSF    x9E.1
....................                usb_put_0len_0(); 
1332:  MOVLB  1
1334:  CLRF   xDB
1336:  MOVLB  0
1338:  RCALL  0FE6
....................             } 
....................             else 
133A:  BRA    1340
....................                usb_request_stall(); 
133C:  MOVLB  0
133E:  RCALL  0FEC
....................             break; 
1340:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1342:  MOVLW  02
1344:  MOVWF  x9C
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1346:  MOVFF  41A,A6
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
134A:  MOVLB  1
134C:  CLRF   xDB
134E:  MOVLB  0
1350:  RCALL  0FE6
....................             break; 
1352:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
1354:  BRA    1080
....................             break; 
1356:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
1358:  MOVFF  9D,420
....................             usb_request_send_response(1); 
135C:  MOVLW  01
135E:  MOVLB  1
1360:  MOVWF  xDB
1362:  MOVLB  0
1364:  RCALL  0FE6
....................             break; 
1366:  BRA    138C
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
1368:  MOVLB  4
136A:  MOVF   x1A,W
136C:  SUBLW  01
136E:  BNC   1384
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
1370:  MOVFF  41A,9D
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
1374:  MOVFF  41A,1D8
1378:  MOVLB  0
137A:  BRA    1124
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
137C:  MOVLB  1
137E:  CLRF   xDB
1380:  MOVLB  0
1382:  RCALL  0FE6
....................             } 
....................             break; 
1384:  MOVLB  0
1386:  BRA    138C
....................  
....................       default: 
....................             usb_request_stall(); 
1388:  RCALL  0FEC
....................             break; 
138A:  BRA    138C
....................    } 
.................... } 
138C:  GOTO   1674 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
1390:  MOVFF  9D,1D8
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
1394:  MOVLB  4
1396:  MOVF   x19,W
1398:  XORLW  00
139A:  MOVLB  0
139C:  BZ    13A8
139E:  XORLW  0A
13A0:  BZ    13BA
13A2:  XORLW  01
13A4:  BZ    13FE
13A6:  BRA    1428
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
13A8:  MOVLB  4
13AA:  CLRF   x20
....................             usb_ep0_tx_buffer[1]=0; 
13AC:  CLRF   x21
....................             usb_request_send_response(2); 
13AE:  MOVLW  02
13B0:  MOVLB  1
13B2:  MOVWF  xDB
13B4:  MOVLB  0
13B6:  RCALL  0FE6
....................             break; 
13B8:  BRA    142C
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
13BA:  MOVLB  1
13BC:  MOVF   xD8,F
13BE:  BZ    13F8
13C0:  MOVLW  01
13C2:  SUBWF  xD8,W
13C4:  CLRF   03
13C6:  MOVLB  0
13C8:  CALL   01E0
13CC:  MOVWF  01
13CE:  MOVLB  4
13D0:  SUBWF  x1C,W
13D2:  BTFSS  FD8.0
13D4:  BRA    13DA
13D6:  MOVLB  1
13D8:  BRA    13F8
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
13DA:  CLRF   03
13DC:  MOVF   x1C,W
13DE:  ADDLW  A9
13E0:  MOVWF  FE9
13E2:  MOVLW  00
13E4:  ADDWFC 03,W
13E6:  MOVWF  FEA
13E8:  MOVFF  FEF,420
....................                usb_request_send_response(1);; //send byte back 
13EC:  MOVLW  01
13EE:  MOVLB  1
13F0:  MOVWF  xDB
13F2:  MOVLB  0
13F4:  RCALL  0FE6
....................             } 
....................             else 
13F6:  BRA    13FC
....................                usb_request_stall(); 
13F8:  MOVLB  0
13FA:  RCALL  0FEC
....................             break; 
13FC:  BRA    142C
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
13FE:  MOVLB  1
1400:  MOVF   xD8,F
1402:  BZ    1422
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1404:  CLRF   03
1406:  MOVLB  4
1408:  MOVF   x1C,W
140A:  ADDLW  A9
140C:  MOVWF  FE9
140E:  MOVLW  00
1410:  ADDWFC 03,W
1412:  MOVWF  FEA
1414:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
1418:  MOVLB  1
141A:  CLRF   xDB
141C:  MOVLB  0
141E:  RCALL  0FE6
....................             } 
....................             else 
1420:  BRA    1426
....................                usb_request_stall(); 
1422:  MOVLB  0
1424:  RCALL  0FEC
....................             break; 
1426:  BRA    142C
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1428:  RCALL  0FEC
....................             break; 
142A:  BRA    142C
....................    } 
.................... } 
142C:  GOTO   1674 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
151C:  MOVFF  41C,1E2
1520:  RCALL  0E96
1522:  MOVF   01,F
1524:  BZ    1582
....................       switch(usb_ep0_rx_buffer[1]) { 
1526:  MOVLB  4
1528:  MOVF   x19,W
152A:  XORLW  01
152C:  MOVLB  0
152E:  BZ    153A
1530:  XORLW  02
1532:  BZ    154A
1534:  XORLW  03
1536:  BZ    155A
1538:  BRA    157E
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
153A:  MOVFF  41C,1D8
153E:  BRA    1430
....................                usb_put_0len_0(); 
1540:  MOVLB  1
1542:  CLRF   xDB
1544:  MOVLB  0
1546:  RCALL  0FE6
....................                break; 
1548:  BRA    1582
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
154A:  MOVFF  41C,1D8
154E:  BRA    1478
....................                      usb_put_0len_0(); 
1550:  MOVLB  1
1552:  CLRF   xDB
1554:  MOVLB  0
1556:  RCALL  0FE6
....................                      break; 
1558:  BRA    1582
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
155A:  MOVLB  4
155C:  CLRF   x20
....................                usb_ep0_tx_buffer[1]=0; 
155E:  CLRF   x21
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
1560:  MOVFF  41C,1D8
1564:  MOVLB  0
1566:  BRA    14C2
1568:  MOVF   01,F
156A:  BZ    1572
....................                   usb_ep0_tx_buffer[0]=1; 
156C:  MOVLW  01
156E:  MOVLB  4
1570:  MOVWF  x20
....................                } 
....................                usb_request_send_response(2); 
1572:  MOVLW  02
1574:  MOVLB  1
1576:  MOVWF  xDB
1578:  MOVLB  0
157A:  RCALL  0FE6
....................                break; 
157C:  BRA    1582
....................  
....................          default: 
....................             usb_request_stall(); 
157E:  RCALL  0FEC
....................             break; 
1580:  BRA    1582
....................       } 
....................    } 
.................... } 
1582:  GOTO   1674 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1080:  CLRF   xA7
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
1082:  CLRF   x9F
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
1084:  MOVLB  4
1086:  MOVF   x1B,W
1088:  XORLW  01
108A:  MOVLB  0
108C:  BZ    109C
108E:  XORLW  03
1090:  BZ    10A6
1092:  XORLW  01
1094:  BZ    10AC
1096:  XORLW  22
1098:  BZ    10D2
109A:  BRA    1100
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
109C:  MOVLW  12
109E:  MOVWF  xA8
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
10A0:  MOVLW  03
10A2:  MOVWF  x9F
....................             break; 
10A4:  BRA    1104
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
10A6:  MOVLW  43
10A8:  MOVWF  xA8
....................             break; 
10AA:  BRA    1104
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
10AC:  MOVLW  02
10AE:  MOVWF  x9F
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
10B0:  CLRF   03
10B2:  MOVLB  4
10B4:  MOVF   x1A,W
10B6:  ADDLW  A0
10B8:  MOVWF  FE9
10BA:  MOVLW  00
10BC:  ADDWFC 03,W
10BE:  MOVWF  FEA
10C0:  MOVFF  FEF,A7
10C4:  MOVLB  0
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
10C6:  CLRF   03
10C8:  MOVF   xA7,W
10CA:  CALL   0234
10CE:  MOVWF  xA8
....................             break; 
10D0:  BRA    1104
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
10D2:  BCF    FD8.0
10D4:  MOVLB  4
10D6:  RLCF   x1A,W
10D8:  CLRF   03
10DA:  MOVLB  0
10DC:  CALL   01F2
10E0:  TBLRD*+
10E2:  MOVFF  FF5,03
10E6:  MOVWF  xA7
....................             if (usb_getdesc_ptr!=0xFF) { 
10E8:  INCFSZ xA7,W
10EA:  BRA    10EE
10EC:  BRA    10FC
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
10EE:  CLRF   03
10F0:  MOVF   xA7,W
10F2:  CALL   018C
10F6:  MOVWF  xA8
....................                break; 
10F8:  BRA    1104
....................             } 
....................             else { 
10FA:  BRA    1100
....................                usb_request_stall(); 
10FC:  RCALL  0FEC
....................                return; 
10FE:  BRA    1120
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
1100:  RCALL  0FEC
....................             return; 
1102:  BRA    1120
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1104:  MOVLB  4
1106:  MOVF   x1F,F
1108:  BNZ   1118
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
110A:  MOVLB  0
110C:  MOVF   xA8,W
110E:  MOVLB  4
1110:  SUBWF  x1E,W
1112:  BC    1118
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
1114:  MOVFF  41E,A8
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1118:  MOVLW  01
111A:  MOVLB  0
111C:  MOVWF  x9C
....................    usb_copy_desc_seg_to_ep(); 
111E:  RCALL  0FF2
.................... } 
1120:  GOTO   138C (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
1974:  CLRF   x9D
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
1976:  CLRF   x9C
....................    usb_set_address(USB_address_pending); 
1978:  MOVFF  A6,1D9
197C:  BRA    1956
....................    #endif 
.................... } 
197E:  GOTO   1A5E (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0FF2:  MOVLB  1
0FF4:  CLRF   xD9
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0FF6:  MOVLB  0
0FF8:  MOVF   xA8,F
0FFA:  BZ    1062
0FFC:  MOVLB  1
0FFE:  MOVF   xD9,W
1000:  SUBLW  07
1002:  BTFSC  FD8.0
1004:  BRA    100A
1006:  MOVLB  0
1008:  BRA    1062
....................       switch(USB_stack_status.getdesc_type) { 
100A:  MOVLB  0
100C:  MOVF   x9F,W
100E:  BZ    101A
1010:  XORLW  02
1012:  BZ    1028
1014:  XORLW  01
1016:  BZ    1036
1018:  BRA    1044
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
101A:  CLRF   03
101C:  MOVF   xA7,W
101E:  CALL   018C
1022:  MOVFF  FE8,1DA
....................             break; 
1026:  BRA    1044
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
1028:  CLRF   03
102A:  MOVF   xA7,W
102C:  CALL   0234
1030:  MOVFF  FE8,1DA
....................             break; 
1034:  BRA    1044
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
1036:  CLRF   03
1038:  MOVF   xA7,W
103A:  CALL   0212
103E:  MOVFF  FE8,1DA
....................             break; 
1042:  BRA    1044
....................       } 
....................       usb_getdesc_ptr++; 
1044:  INCF   xA7,F
....................       usb_getdesc_len--; 
1046:  DECF   xA8,F
....................       usb_ep0_tx_buffer[i++]=c; 
1048:  MOVLB  1
104A:  MOVF   xD9,W
104C:  INCF   xD9,F
104E:  CLRF   03
1050:  ADDLW  20
1052:  MOVWF  FE9
1054:  MOVLW  04
1056:  ADDWFC 03,W
1058:  MOVWF  FEA
105A:  MOVFF  1DA,FEF
....................    } 
105E:  BRA    0FF6
1060:  MOVLB  0
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1062:  MOVF   xA8,F
1064:  BNZ   1078
1066:  MOVLB  1
1068:  MOVF   xD9,W
106A:  SUBLW  08
106C:  BTFSS  FD8.2
106E:  BRA    1074
1070:  MOVLB  0
1072:  BRA    1078
....................          USB_stack_status.dev_req = NONE; 
1074:  MOVLB  0
1076:  CLRF   x9C
....................    } 
....................  
....................    usb_request_send_response(i); 
1078:  MOVFF  1D9,1DB
107C:  RCALL  0FE6
.................... } 
107E:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  unsigned int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... unsigned int8 g_LastCDCDataPacketSize; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
1858:  MOVLB  1
185A:  MOVF   x01,W
185C:  XORLW  01
185E:  MOVLB  0
1860:  BZ    186C
1862:  XORLW  02
1864:  BZ    1892
1866:  XORLW  01
1868:  BZ    18A4
186A:  BRA    18CC
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
186C:  CLRF   FEA
186E:  MOVLW  B4
1870:  MOVWF  FE9
1872:  MOVLW  04
1874:  MOVWF  FE2
1876:  MOVLW  18
1878:  MOVWF  FE1
187A:  MOVLW  08
187C:  MOVWF  01
187E:  MOVFF  FE6,FEE
1882:  DECFSZ 01,F
1884:  BRA    187E
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
1886:  MOVLW  03
1888:  MOVLB  1
188A:  MOVWF  x01
....................          usb_request_get_data(); 
188C:  MOVLB  0
188E:  RCALL  1586
....................         #else 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................         #endif 
....................          break; 
1890:  BRA    18D4
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
1892:  MOVLB  1
1894:  CLRF   xDB
1896:  MOVLB  0
1898:  CALL   0FE6
....................          __usb_cdc_state=0; 
189C:  MOVLB  1
189E:  CLRF   x01
....................          break; 
18A0:  MOVLB  0
18A2:  BRA    18D4
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
18A4:  CLRF   FEA
18A6:  MOVLW  AB
18A8:  MOVWF  FE9
18AA:  MOVLW  04
18AC:  MOVWF  FE2
18AE:  MOVLW  18
18B0:  MOVWF  FE1
18B2:  MOVLW  07
18B4:  MOVWF  01
18B6:  MOVFF  FE6,FEE
18BA:  DECFSZ 01,F
18BC:  BRA    18B6
....................          __usb_cdc_state=0; 
18BE:  MOVLB  1
18C0:  CLRF   x01
....................          usb_put_0len_0(); 
18C2:  CLRF   xDB
18C4:  MOVLB  0
18C6:  CALL   0FE6
....................          break; 
18CA:  BRA    18D4
....................  
....................       default: 
....................          __usb_cdc_state=0; 
18CC:  MOVLB  1
18CE:  CLRF   x01
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
18D0:  MOVLB  0
18D2:  BRA    18D4
....................    } 
.................... } 
18D4:  GOTO   1942 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
158C:  MOVLB  4
158E:  DECFSZ x1C,W
1590:  BRA    1594
1592:  BRA    1598
1594:  MOVF   x1C,F
1596:  BNZ   163E
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
1598:  MOVF   x19,W
159A:  XORLW  00
159C:  MOVLB  0
159E:  BZ    15B6
15A0:  XORLW  01
15A2:  BZ    15C2
15A4:  XORLW  21
15A6:  BZ    15E4
15A8:  XORLW  01
15AA:  BZ    15F2
15AC:  XORLW  03
15AE:  BZ    1618
15B0:  XORLW  01
15B2:  BZ    1626
15B4:  BRA    1638
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
15B6:  MOVLW  01
15B8:  MOVLB  1
15BA:  MOVWF  x01
....................             usb_request_get_data(); 
15BC:  MOVLB  0
15BE:  RCALL  1586
....................             break; 
15C0:  BRA    163C
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
15C2:  MOVLW  04
15C4:  MOVWF  FEA
15C6:  MOVLW  20
15C8:  MOVWF  FE9
15CA:  CLRF   FE2
15CC:  MOVLW  B4
15CE:  MOVWF  FE1
15D0:  MOVLW  08
15D2:  MOVWF  01
15D4:  MOVFF  FE6,FEE
15D8:  DECFSZ 01,F
15DA:  BRA    15D4
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
15DC:  MOVFF  41E,1DB
15E0:  RCALL  0FE6
....................             break; 
15E2:  BRA    163C
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
15E4:  MOVLW  02
15E6:  MOVLB  1
15E8:  MOVWF  x01
....................             usb_cdc_got_set_line_coding=TRUE; 
15EA:  BSF    3F.1
....................             usb_request_get_data(); 
15EC:  MOVLB  0
15EE:  RCALL  1586
....................             break; 
15F0:  BRA    163C
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
15F2:  MOVLW  04
15F4:  MOVWF  FEA
15F6:  MOVLW  20
15F8:  MOVWF  FE9
15FA:  CLRF   FE2
15FC:  MOVLW  AB
15FE:  MOVWF  FE1
1600:  MOVLW  07
1602:  MOVWF  01
1604:  MOVFF  FE6,FEE
1608:  DECFSZ 01,F
160A:  BRA    1604
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
160C:  MOVLW  07
160E:  MOVLB  1
1610:  MOVWF  xDB
1612:  MOVLB  0
1614:  RCALL  0FE6
....................             break; 
1616:  BRA    163C
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
1618:  MOVFF  41A,FF
....................             usb_put_0len_0(); 
161C:  MOVLB  1
161E:  CLRF   xDB
1620:  MOVLB  0
1622:  RCALL  0FE6
....................             break; 
1624:  BRA    163C
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
1626:  MOVFF  41A,B3
162A:  MOVFF  41B,B2
....................             usb_put_0len_0(); 
162E:  MOVLB  1
1630:  CLRF   xDB
1632:  MOVLB  0
1634:  RCALL  0FE6
....................             break; 
1636:  BRA    163C
....................  
....................          default: 
....................             usb_request_stall(); 
1638:  RCALL  0FEC
....................             break; 
163A:  BRA    163C
163C:  MOVLB  4
....................       } 
....................    } 
.................... } 
163E:  MOVLB  0
1640:  GOTO   1674 (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
191C:  BSF    xFC.0
....................    usb_cdc_get_buffer_status.index=0; 
191E:  CLRF   xFE
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
1920:  MOVLW  02
1922:  MOVLB  1
1924:  MOVWF  xD9
1926:  MOVLB  0
1928:  BRA    18D8
192A:  MOVFF  01,FD
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
192E:  MOVF   xFD,F
1930:  BNZ   1934
....................    { 
....................       usb_cdc_get_discard(); 
1932:  BRA    190A
....................    } 
.................... } 
1934:  GOTO   1950 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    //putc('!'); 
....................    if (usb_cdc_put_buffer_nextin /* || (g_LastCDCDataPacketSize == USB_CDC_DATA_IN_SIZE)*/ )  
*
1A3A:  MOVF   xFB,F
1A3C:  BZ    1A40
....................    { 
....................       //printf("FL3 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
1A3E:  BRA    1A16
....................    } 
.................... } 
1A40:  GOTO   1A6C (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................    usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
*
1A16:  MOVLW  02
1A18:  MOVLB  1
1A1A:  MOVWF  xD9
1A1C:  CLRF   xDB
1A1E:  MOVLW  BC
1A20:  MOVWF  xDA
1A22:  CLRF   xDD
1A24:  MOVFF  FB,1DC
1A28:  MOVLW  02
1A2A:  MOVWF  xDE
1A2C:  MOVLB  0
1A2E:  BRA    1982
....................    g_LastCDCDataPacketSize = usb_cdc_put_buffer_nextin; 
1A30:  MOVFF  FB,100
....................    usb_cdc_put_buffer_nextin=0; 
1A34:  CLRF   xFB
.................... } 
1A36:  GOTO   1A40 (RETURN)
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
0F5C:  CLRF   xAE
0F5E:  CLRF   xAD
0F60:  MOVLW  25
0F62:  MOVWF  xAC
0F64:  MOVLW  80
0F66:  MOVWF  xAB
....................    usb_cdc_line_coding.bCharFormat = 0; 
0F68:  CLRF   xAF
....................    usb_cdc_line_coding.bParityType = 0; 
0F6A:  CLRF   xB0
....................    usb_cdc_line_coding.bDataBits = 8; 
0F6C:  MOVLW  08
0F6E:  MOVWF  xB1
....................    (int8)usb_cdc_carrier = 0; 
0F70:  CLRF   xFF
....................    usb_cdc_got_set_line_coding = FALSE; 
0F72:  BCF    3F.1
....................    usb_cdc_break = 0; 
0F74:  CLRF   xB3
0F76:  CLRF   xB2
....................    usb_cdc_put_buffer_nextin = 0; 
0F78:  CLRF   xFB
....................    usb_cdc_get_buffer_status.got = 0; 
0F7A:  BCF    xFC.0
.................... } 
0F7C:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
190A:  BCF    xFC.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
190C:  MOVLW  02
190E:  MOVLB  1
1910:  MOVWF  xD9
1912:  MOVWF  xDA
1914:  MOVLB  0
1916:  RCALL  1678
.................... } 
1918:  GOTO   1934 (RETURN)
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
....................    { 
....................       usb_cdc_get_discard(); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................  #if defined(__PCH__) 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie = INT_GIE; 
....................    INT_GIE = 0; 
....................  #else 
....................    int16 oldSR; 
....................     
....................    oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
....................  
....................    //renable global interrupts 
....................   #if defined(__PCH__) 
....................    INT_GIE = old_gie; 
....................   #else 
....................    SR = oldSR; 
....................   #endif 
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c)  
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
....................    if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c)  
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... { 
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    for (;;) 
....................    { 
....................       c = *ptr++; 
....................       if (!c) 
....................          break; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_out_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... unsigned int indice = 0; 
.................... int COM_init(){ 
.................... 	usb_cdc_init(); 
*
1E12:  CALL   0F5C
....................    usb_init_cs(); 
1E16:  BRA    1DB0
....................    usb_task(); 
1E18:  BRA    1DD8
....................    if(usb_attached()){ 
1E1A:  BSF    F95.3
1E1C:  BTFSS  F83.3
1E1E:  BRA    1E34
....................       if(usb_enumerated()){ 
1E20:  BRA    1E0A
1E22:  MOVF   01,F
1E24:  BZ    1E2E
....................          return (USB_OK); 
1E26:  MOVLW  01
1E28:  MOVWF  01
1E2A:  BRA    1E38
....................       }else{ 
1E2C:  BRA    1E34
....................          return(USB_NO_ENUMERATED); 
1E2E:  MOVLW  00
1E30:  MOVWF  01
1E32:  BRA    1E38
....................       } 
....................    } 
....................    return (USB_NO_ATTACHED); 
1E34:  MOVLW  FF
1E36:  MOVWF  01
.................... } 
1E38:  GOTO   20E2 (RETURN)
....................  
.................... int8 COM_sense(){ 
....................    usb_task(); 
....................    if(usb_attached()){ 
....................       if(usb_enumerated()){ 
....................          return (USB_OK); 
....................       }else{ 
....................          return(USB_NO_ENUMERATED); 
....................       } 
....................    }    
....................    return(USB_NO_ATTACHED); 
.................... } 
....................  
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1){ 
....................    indice = 0; 
....................    if(!COM_READY) return(-1); 
....................    while(indice < leng){ 
....................       if(wait == 1) 
....................          usb_cdc_putc(buffer[indice]); 
....................       else 
....................          usb_cdc_putc_fast(buffer[indice]); 
....................       indice++; 
....................    } 
....................    return (indice); 
.................... } 
....................  
.................... int8 COM_recive(char* buffer, unsigned int8 leng){ 
....................    indice = 0; 
....................    if(!COM_READY) return (-1); 
....................    while(indice < leng){ 
....................       if(usb_cdc_kbhit()){ 
....................          buffer[indice] = usb_cdc_getc(); 
....................          indice++; 
....................       } 
....................    } 
....................    return(indice); 
.................... } 
....................  
.................... void COM_printf(char* message){ 
.................... 	printf(usb_cdc_putc,"%s\n\r",message); 
.................... } 
....................  
.................... #include "analogo_digital.c" 
.................... //#include "Nucleo.h" 
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
.................... #define ACC_x		0 
.................... #define ACC_y		1 
.................... #define ACC_z		2 
.................... #define AD_VEL 	3 
.................... #define AD_REV	4 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(unsigned int canal, int16 *buffer); 
....................  
.................... #endif 
....................  
....................  
.................... #define ADC_TAD_MUL_4      0x10 
.................... #define ADC_INPUT_PORT		0x2F 
....................  
.................... int AD_init_adc(){ 
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); // default 
.................... #endif 
.................... */	 
.................... 	output_a(0x00); 
*
1F1E:  CLRF   F92
1F20:  CLRF   F89
.................... 	set_tris_a(ADC_INPUT_PORT);		//RA0 a RA4 entradas 
1F22:  MOVLW  2F
1F24:  MOVWF  F92
.................... 	setup_adc_ports(AN0_TO_AN4); 
1F26:  MOVF   FC1,W
1F28:  ANDLW  C0
1F2A:  IORLW  0A
1F2C:  MOVWF  FC1
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_4|VSS_VDD);	 
1F2E:  BCF    FC0.0
1F30:  BSF    FC0.1
1F32:  BCF    FC0.2
1F34:  BSF    FC0.7
1F36:  BSF    FC2.0
.................... 	return (0); 
1F38:  MOVLW  00
1F3A:  MOVWF  01
.................... } 
1F3C:  GOTO   20F4 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
02B0:  MOVLB  1
02B2:  RLCF   xB0,W
02B4:  MOVWF  00
02B6:  RLCF   00,F
02B8:  MOVLW  FC
02BA:  ANDWF  00,F
02BC:  MOVF   FC2,W
02BE:  ANDLW  C3
02C0:  IORWF  00,W
02C2:  MOVWF  FC2
.................... 	delay_us(10); 
02C4:  MOVLW  0D
02C6:  MOVWF  00
02C8:  DECFSZ 00,F
02CA:  BRA    02C8
.................... 	read_adc(ADC_START_ONLY); 
02CC:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
02CE:  BCF    xB3.0
02D0:  BTFSS  FC2.1
02D2:  BSF    xB3.0
.................... 	}while(!done); 
02D4:  BTFSS  xB3.0
02D6:  BRA    02CE
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
02D8:  MOVFF  1B2,03
02DC:  MOVFF  1B1,FE9
02E0:  MOVFF  1B2,FEA
02E4:  BTFSC  FC2.1
02E6:  BRA    02E4
02E8:  MOVFF  FC3,FEF
02EC:  MOVFF  FC4,FEC
.................... 	delay_us(20); 
02F0:  MOVLW  1A
02F2:  MOVWF  00
02F4:  DECFSZ 00,F
02F6:  BRA    02F4
02F8:  NOP   
.................... 	return (0); 
02FA:  MOVLW  00
02FC:  MOVWF  01
.................... } 
02FE:  MOVLB  0
0300:  RETLW  00
....................  
.................... #include "ds1307.c" 
.................... //#include "Nucleo.h" 
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
.................... byte DS_vic = 0x00; 
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_sec = 0x00; 
.................... #endif 
....................  
....................  
....................  
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
1F6A:  MOVLB  1
1F6C:  CLRF   x70
....................  
....................   byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
1F6E:  BCF    FF2.6
1F70:  BCF    FF2.7
1F72:  BTFSC  FF2.7
1F74:  BRA    1F70
.................... #endif 
....................  
....................   i2c_start(); 
1F76:  BSF    F93.0
1F78:  MOVLW  04
1F7A:  MOVWF  00
1F7C:  DECFSZ 00,F
1F7E:  BRA    1F7C
1F80:  BSF    F93.1
1F82:  MOVLW  04
1F84:  MOVWF  00
1F86:  DECFSZ 00,F
1F88:  BRA    1F86
1F8A:  BCF    F8A.0
1F8C:  BCF    F93.0
1F8E:  MOVLW  04
1F90:  MOVWF  00
1F92:  DECFSZ 00,F
1F94:  BRA    1F92
1F96:  BCF    F8A.1
1F98:  BCF    F93.1
....................   i2c_write(0xD0); 
1F9A:  MOVLW  D0
1F9C:  MOVWF  xD1
1F9E:  MOVLB  0
1FA0:  CALL   0B64
....................   i2c_write(0x00); 
1FA4:  MOVLB  1
1FA6:  CLRF   xD1
1FA8:  MOVLB  0
1FAA:  CALL   0B64
....................   i2c_start(); 
1FAE:  BSF    F93.0
1FB0:  MOVLW  04
1FB2:  MOVWF  00
1FB4:  DECFSZ 00,F
1FB6:  BRA    1FB4
1FB8:  BSF    F93.1
1FBA:  MOVLW  04
1FBC:  MOVWF  00
1FBE:  DECFSZ 00,F
1FC0:  BRA    1FBE
1FC2:  BTFSS  F81.1
1FC4:  BRA    1FC2
1FC6:  BCF    F8A.0
1FC8:  BCF    F93.0
1FCA:  MOVLW  04
1FCC:  MOVWF  00
1FCE:  DECFSZ 00,F
1FD0:  BRA    1FCE
1FD2:  BCF    F8A.1
1FD4:  BCF    F93.1
....................   i2c_write(0xD1); 
1FD6:  MOVLW  D1
1FD8:  MOVLB  1
1FDA:  MOVWF  xD1
1FDC:  MOVLB  0
1FDE:  CALL   0B64
....................   seconds = ds1307_bcd2bin(i2c_read(0)); 
1FE2:  CLRF   00
1FE4:  CALL   0BDA
1FE8:  MOVFF  01,171
1FEC:  MOVFF  01,1D2
1FF0:  CALL   0C44
1FF4:  MOVFF  01,170
....................   i2c_stop(); 
1FF8:  BCF    F93.0
1FFA:  NOP   
1FFC:  BSF    F93.1
1FFE:  BTFSS  F81.1
2000:  BRA    1FFE
2002:  MOVLW  04
2004:  MOVWF  00
2006:  DECFSZ 00,F
2008:  BRA    2006
200A:  BRA    200C
200C:  NOP   
200E:  BSF    F93.0
2010:  MOVLW  04
2012:  MOVWF  00
2014:  DECFSZ 00,F
2016:  BRA    2014
....................   seconds &= 0x7F; 
2018:  MOVLB  1
201A:  BCF    x70.7
....................  
....................   delay_us(3); 
201C:  MOVLW  03
201E:  MOVWF  00
2020:  DECFSZ 00,F
2022:  BRA    2020
2024:  BRA    2026
....................  
....................   i2c_start(); 
2026:  BSF    F93.0
2028:  MOVLW  04
202A:  MOVWF  00
202C:  DECFSZ 00,F
202E:  BRA    202C
2030:  BSF    F93.1
2032:  MOVLW  04
2034:  MOVWF  00
2036:  DECFSZ 00,F
2038:  BRA    2036
203A:  BCF    F8A.0
203C:  BCF    F93.0
203E:  MOVLW  04
2040:  MOVWF  00
2042:  DECFSZ 00,F
2044:  BRA    2042
2046:  BCF    F8A.1
2048:  BCF    F93.1
....................   i2c_write(0xD0); 
204A:  MOVLW  D0
204C:  MOVWF  xD1
204E:  MOVLB  0
2050:  CALL   0B64
....................   i2c_write(0x00); 
2054:  MOVLB  1
2056:  CLRF   xD1
2058:  MOVLB  0
205A:  CALL   0B64
....................   i2c_write(ds1307_bin2bcd(seconds)); 
205E:  MOVFF  170,171
2062:  BRA    1F40
2064:  MOVFF  01,171
2068:  MOVFF  01,1D1
206C:  CALL   0B64
....................   i2c_start(); 
2070:  BSF    F93.0
2072:  MOVLW  04
2074:  MOVWF  00
2076:  DECFSZ 00,F
2078:  BRA    2076
207A:  BSF    F93.1
207C:  MOVLW  04
207E:  MOVWF  00
2080:  DECFSZ 00,F
2082:  BRA    2080
2084:  BTFSS  F81.1
2086:  BRA    2084
2088:  BCF    F8A.0
208A:  BCF    F93.0
208C:  MOVLW  04
208E:  MOVWF  00
2090:  DECFSZ 00,F
2092:  BRA    2090
2094:  BCF    F8A.1
2096:  BCF    F93.1
....................   i2c_write(0xD0); 
2098:  MOVLW  D0
209A:  MOVLB  1
209C:  MOVWF  xD1
209E:  MOVLB  0
20A0:  CALL   0B64
....................   i2c_write(0x07); 
20A4:  MOVLW  07
20A6:  MOVLB  1
20A8:  MOVWF  xD1
20AA:  MOVLB  0
20AC:  CALL   0B64
....................   i2c_write(val); 
20B0:  MOVFF  16F,1D1
20B4:  CALL   0B64
....................   i2c_stop(); 
20B8:  BCF    F93.0
20BA:  NOP   
20BC:  BSF    F93.1
20BE:  BTFSS  F81.1
20C0:  BRA    20BE
20C2:  MOVLW  04
20C4:  MOVWF  00
20C6:  DECFSZ 00,F
20C8:  BRA    20C6
20CA:  BRA    20CC
20CC:  NOP   
20CE:  BSF    F93.0
20D0:  MOVLW  04
20D2:  MOVWF  00
20D4:  DECFSZ 00,F
20D6:  BRA    20D4
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
20D8:  MOVLW  C0
20DA:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
20DC:  GOTO   2102 (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
*
0C6E:  BCF    FF2.6
0C70:  BCF    FF2.7
0C72:  BTFSC  FF2.7
0C74:  BRA    0C70
.................... #endif 
....................  
....................   i2c_start(); 
0C76:  BSF    F93.0
0C78:  MOVLW  04
0C7A:  MOVWF  00
0C7C:  DECFSZ 00,F
0C7E:  BRA    0C7C
0C80:  BSF    F93.1
0C82:  MOVLW  04
0C84:  MOVWF  00
0C86:  DECFSZ 00,F
0C88:  BRA    0C86
0C8A:  BCF    F8A.0
0C8C:  BCF    F93.0
0C8E:  MOVLW  04
0C90:  MOVWF  00
0C92:  DECFSZ 00,F
0C94:  BRA    0C92
0C96:  BCF    F8A.1
0C98:  BCF    F93.1
....................   i2c_write(0xD0); 
0C9A:  MOVLW  D0
0C9C:  MOVLB  1
0C9E:  MOVWF  xD1
0CA0:  MOVLB  0
0CA2:  RCALL  0B64
....................   i2c_write(0x03); 
0CA4:  MOVLW  03
0CA6:  MOVLB  1
0CA8:  MOVWF  xD1
0CAA:  MOVLB  0
0CAC:  RCALL  0B64
....................   i2c_start(); 
0CAE:  BSF    F93.0
0CB0:  MOVLW  04
0CB2:  MOVWF  00
0CB4:  DECFSZ 00,F
0CB6:  BRA    0CB4
0CB8:  BSF    F93.1
0CBA:  MOVLW  04
0CBC:  MOVWF  00
0CBE:  DECFSZ 00,F
0CC0:  BRA    0CBE
0CC2:  BTFSS  F81.1
0CC4:  BRA    0CC2
0CC6:  BCF    F8A.0
0CC8:  BCF    F93.0
0CCA:  MOVLW  04
0CCC:  MOVWF  00
0CCE:  DECFSZ 00,F
0CD0:  BRA    0CCE
0CD2:  BCF    F8A.1
0CD4:  BCF    F93.1
....................   i2c_write(0xD1); 
0CD6:  MOVLW  D1
0CD8:  MOVLB  1
0CDA:  MOVWF  xD1
0CDC:  MOVLB  0
0CDE:  RCALL  0B64
....................   dow = ds1307_bcd2bin(i2c_read() & 0x7f); 
0CE0:  MOVLW  01
0CE2:  MOVWF  00
0CE4:  RCALL  0BDA
0CE6:  MOVF   01,W
0CE8:  ANDLW  7F
0CEA:  MOVLB  1
0CEC:  MOVWF  xCD
0CEE:  MOVWF  xD2
0CF0:  MOVLB  0
0CF2:  RCALL  0C44
0CF4:  MOVFF  01,26
....................   day = ds1307_bcd2bin(i2c_read() & 0x3f); 
0CF8:  MOVLW  01
0CFA:  MOVWF  00
0CFC:  RCALL  0BDA
0CFE:  MOVF   01,W
0D00:  ANDLW  3F
0D02:  MOVLB  1
0D04:  MOVWF  xCD
0D06:  MOVWF  xD2
0D08:  MOVLB  0
0D0A:  RCALL  0C44
0D0C:  MOVFF  01,43
....................   mth = ds1307_bcd2bin(i2c_read() & 0x1f); 
0D10:  MOVLW  01
0D12:  MOVWF  00
0D14:  RCALL  0BDA
0D16:  MOVF   01,W
0D18:  ANDLW  1F
0D1A:  MOVLB  1
0D1C:  MOVWF  xCD
0D1E:  MOVWF  xD2
0D20:  MOVLB  0
0D22:  RCALL  0C44
0D24:  MOVFF  01,44
....................   year = ds1307_bcd2bin(i2c_read(0)); 
0D28:  CLRF   00
0D2A:  RCALL  0BDA
0D2C:  MOVFF  01,1CD
0D30:  MOVFF  01,1D2
0D34:  RCALL  0C44
0D36:  MOVFF  01,45
....................   i2c_stop(); 
0D3A:  BCF    F93.0
0D3C:  NOP   
0D3E:  BSF    F93.1
0D40:  BTFSS  F81.1
0D42:  BRA    0D40
0D44:  MOVLW  04
0D46:  MOVWF  00
0D48:  DECFSZ 00,F
0D4A:  BRA    0D48
0D4C:  BRA    0D4E
0D4E:  NOP   
0D50:  BSF    F93.0
0D52:  MOVLW  04
0D54:  MOVWF  00
0D56:  DECFSZ 00,F
0D58:  BRA    0D56
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
0D5A:  MOVLW  C0
0D5C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
0D5E:  BCF    FF2.6
0D60:  BCF    FF2.7
0D62:  BTFSC  FF2.7
0D64:  BRA    0D60
.................... #endif 
....................  
....................   i2c_start(); 
0D66:  BSF    F93.0
0D68:  MOVLW  04
0D6A:  MOVWF  00
0D6C:  DECFSZ 00,F
0D6E:  BRA    0D6C
0D70:  BSF    F93.1
0D72:  MOVLW  04
0D74:  MOVWF  00
0D76:  DECFSZ 00,F
0D78:  BRA    0D76
0D7A:  BCF    F8A.0
0D7C:  BCF    F93.0
0D7E:  MOVLW  04
0D80:  MOVWF  00
0D82:  DECFSZ 00,F
0D84:  BRA    0D82
0D86:  BCF    F8A.1
0D88:  BCF    F93.1
....................   i2c_write(0xD0); 
0D8A:  MOVLW  D0
0D8C:  MOVLB  1
0D8E:  MOVWF  xD1
0D90:  MOVLB  0
0D92:  RCALL  0B64
....................   i2c_write(0x00); 
0D94:  MOVLB  1
0D96:  CLRF   xD1
0D98:  MOVLB  0
0D9A:  RCALL  0B64
....................   i2c_start(); 
0D9C:  BSF    F93.0
0D9E:  MOVLW  04
0DA0:  MOVWF  00
0DA2:  DECFSZ 00,F
0DA4:  BRA    0DA2
0DA6:  BSF    F93.1
0DA8:  MOVLW  04
0DAA:  MOVWF  00
0DAC:  DECFSZ 00,F
0DAE:  BRA    0DAC
0DB0:  BTFSS  F81.1
0DB2:  BRA    0DB0
0DB4:  BCF    F8A.0
0DB6:  BCF    F93.0
0DB8:  MOVLW  04
0DBA:  MOVWF  00
0DBC:  DECFSZ 00,F
0DBE:  BRA    0DBC
0DC0:  BCF    F8A.1
0DC2:  BCF    F93.1
....................   i2c_write(0xD1); 
0DC4:  MOVLW  D1
0DC6:  MOVLB  1
0DC8:  MOVWF  xD1
0DCA:  MOVLB  0
0DCC:  RCALL  0B64
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
0DCE:  MOVLW  01
0DD0:  MOVWF  00
0DD2:  RCALL  0BDA
0DD4:  MOVF   01,W
0DD6:  ANDLW  7F
0DD8:  MOVLB  1
0DDA:  MOVWF  xCD
0DDC:  MOVWF  xD2
0DDE:  MOVLB  0
0DE0:  RCALL  0C44
0DE2:  MOVFF  01,48
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
0DE6:  MOVLW  01
0DE8:  MOVWF  00
0DEA:  RCALL  0BDA
0DEC:  MOVF   01,W
0DEE:  ANDLW  7F
0DF0:  MOVLB  1
0DF2:  MOVWF  xCD
0DF4:  MOVWF  xD2
0DF6:  MOVLB  0
0DF8:  RCALL  0C44
0DFA:  MOVFF  01,47
....................   hr = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
0DFE:  CLRF   00
0E00:  RCALL  0BDA
0E02:  MOVF   01,W
0E04:  ANDLW  3F
0E06:  MOVLB  1
0E08:  MOVWF  xCD
0E0A:  MOVWF  xD2
0E0C:  MOVLB  0
0E0E:  RCALL  0C44
0E10:  MOVFF  01,46
....................   i2c_stop(); 
0E14:  BCF    F93.0
0E16:  NOP   
0E18:  BSF    F93.1
0E1A:  BTFSS  F81.1
0E1C:  BRA    0E1A
0E1E:  MOVLW  04
0E20:  MOVWF  00
0E22:  DECFSZ 00,F
0E24:  BRA    0E22
0E26:  BRA    0E28
0E28:  NOP   
0E2A:  BSF    F93.0
0E2C:  MOVLW  04
0E2E:  MOVWF  00
0E30:  DECFSZ 00,F
0E32:  BRA    0E30
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
0E34:  MOVLW  C0
0E36:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................   char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(addr); 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   retval = i2c_read(0); 
....................   i2c_stop(); 
....................  
.................... return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(addr); 
....................   i2c_write(value); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................   byte lday; 
....................   byte lmonth; 
....................   byte lyr; 
....................   byte ldow; 
....................   ds1307_get_date(lday,lmonth,lyr,ldow); 
....................   sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
1F40:  MOVFF  171,172
....................   retval = 0; 
1F44:  MOVLB  1
1F46:  CLRF   x73
....................   while(1){ 
....................     if(temp >= 10){ 
1F48:  MOVF   x72,W
1F4A:  SUBLW  09
1F4C:  BC    1F58
....................       temp -= 10; 
1F4E:  MOVLW  0A
1F50:  SUBWF  x72,F
....................       retval += 0x10; 
1F52:  MOVLW  10
1F54:  ADDWF  x73,F
....................     }else{ 
1F56:  BRA    1F5E
....................       retval += temp; 
1F58:  MOVF   x72,W
1F5A:  ADDWF  x73,F
....................       break; 
1F5C:  BRA    1F60
....................     } 
....................   } 
1F5E:  BRA    1F48
....................   return(retval); 
1F60:  MOVFF  173,01
.................... } 
1F64:  MOVLB  0
1F66:  GOTO   2064 (RETURN)
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
0C44:  MOVFF  1D2,1D3
....................   temp >>= 1; 
0C48:  BCF    FD8.0
0C4A:  MOVLB  1
0C4C:  RRCF   xD3,F
....................   temp &= 0x78; 
0C4E:  MOVLW  78
0C50:  ANDWF  xD3,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
0C52:  RRCF   xD3,W
0C54:  MOVWF  00
0C56:  RRCF   00,F
0C58:  MOVLW  3F
0C5A:  ANDWF  00,F
0C5C:  MOVF   00,W
0C5E:  ADDWF  xD3,W
0C60:  MOVWF  xD4
0C62:  MOVF   xD2,W
0C64:  ANDLW  0F
0C66:  ADDWF  xD4,W
0C68:  MOVWF  01
.................... } 
0C6A:  MOVLB  0
0C6C:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
.................... /* 
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x03); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
....................   year = ds1307_bcd2bin(i2c_read(0)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
....................   temp >>= 1; 
....................   temp &= 0x78; 
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... } 
.................... */ 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "captura_frecuencia.c" 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA_H 
.................... #define CAPTURA_FRECUENCIA_H 
.................... //canales de lectura 
.................... #define CCP_CANAL_1 1 
.................... #define CCP_CANAL_2 2 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_8|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
.................... int semaforo_ccp = 0; 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... void CP_activar_captura(int canal); 
.................... void CP_desativar_captura(); 
.................... int CP_ocupado(); 
.................... int32 CP_obtener_resultado(); 
....................  
.................... #endif 
....................  
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... /* 
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
.................... */ 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... /*struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
.................... */ 
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
1C7A:  INCF   2E,F
.................... } 
....................  
1C7C:  BCF    FA1.1
1C7E:  GOTO   0084
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
1C82:  MOVF   2D,W
1C84:  SUBLW  FF
1C86:  BNZ   1C98
....................    	setup_ccp1(CCP_CAPTURE_FE); 
1C88:  BSF    F94.2
1C8A:  CLRF   FBD
1C8C:  MOVLW  04
1C8E:  MOVWF  FBD
1C90:  CLRF   FB7
1C92:  CLRF   FB6
....................    	Q_CCP = 0; 
1C94:  CLRF   2D
....................    }else if(Q_CCP == 0){ 
1C96:  BRA    1D00
1C98:  MOVF   2D,F
1C9A:  BNZ   1CC4
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
1C9C:  CLRF   01
1C9E:  MOVLB  1
1CA0:  CLRF   xD5
1CA2:  CLRF   xD6
1CA4:  MOVF   FBE,W
1CA6:  ADDWF  xD5,W
1CA8:  MOVWF  33
1CAA:  MOVF   FBF,W
1CAC:  ADDWFC xD6,W
1CAE:  MOVWF  34
1CB0:  MOVLW  00
1CB2:  ADDWFC 2E,W
1CB4:  MOVWF  35
1CB6:  MOVLW  00
1CB8:  ADDWFC 01,W
1CBA:  MOVWF  36
....................    	Q_CCP = 1; 
1CBC:  MOVLW  01
1CBE:  MOVWF  2D
....................    }else if(Q_CCP == 1){ 
1CC0:  BRA    1CFE
1CC2:  MOVLB  0
1CC4:  DECFSZ 2D,W
1CC6:  BRA    1D00
....................    	disable_interrupts(INT_CCP1); 
1CC8:  BCF    F9D.2
....................    	tiempo_inicial = tiempo_final; 
1CCA:  MOVFF  36,32
1CCE:  MOVFF  35,31
1CD2:  MOVFF  34,30
1CD6:  MOVFF  33,2F
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
1CDA:  CLRF   01
1CDC:  MOVLB  1
1CDE:  CLRF   xD5
1CE0:  CLRF   xD6
1CE2:  MOVF   FBE,W
1CE4:  ADDWF  xD5,W
1CE6:  MOVWF  33
1CE8:  MOVF   FBF,W
1CEA:  ADDWFC xD6,W
1CEC:  MOVWF  34
1CEE:  MOVLW  00
1CF0:  ADDWFC 2E,W
1CF2:  MOVWF  35
1CF4:  MOVLW  00
1CF6:  ADDWFC 01,W
1CF8:  MOVWF  36
....................    	Q_CCP = 2; 
1CFA:  MOVLW  02
1CFC:  MOVWF  2D
1CFE:  MOVLB  0
....................    } 
.................... } 
....................  
1D00:  BCF    F9E.2
1D02:  GOTO   0084
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
1D06:  MOVF   2D,W
1D08:  SUBLW  FF
1D0A:  BNZ   1D1C
....................    	setup_ccp1(CCP_CAPTURE_FE); 
1D0C:  BSF    F94.2
1D0E:  CLRF   FBD
1D10:  MOVLW  04
1D12:  MOVWF  FBD
1D14:  CLRF   FB7
1D16:  CLRF   FB6
....................    	Q_CCP = 0; 
1D18:  CLRF   2D
....................    }else if(Q_CCP == 0){ 
1D1A:  BRA    1D84
1D1C:  MOVF   2D,F
1D1E:  BNZ   1D48
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
1D20:  CLRF   01
1D22:  MOVLB  1
1D24:  CLRF   xD5
1D26:  CLRF   xD6
1D28:  MOVF   FBB,W
1D2A:  ADDWF  xD5,W
1D2C:  MOVWF  33
1D2E:  MOVF   FBC,W
1D30:  ADDWFC xD6,W
1D32:  MOVWF  34
1D34:  MOVLW  00
1D36:  ADDWFC 2E,W
1D38:  MOVWF  35
1D3A:  MOVLW  00
1D3C:  ADDWFC 01,W
1D3E:  MOVWF  36
....................    	Q_CCP = 1; 
1D40:  MOVLW  01
1D42:  MOVWF  2D
....................    }else if(Q_CCP == 1){ 
1D44:  BRA    1D82
1D46:  MOVLB  0
1D48:  DECFSZ 2D,W
1D4A:  BRA    1D84
....................    	disable_interrupts(INT_CCP2); 
1D4C:  BCF    FA0.0
....................    	tiempo_inicial = tiempo_final; 
1D4E:  MOVFF  36,32
1D52:  MOVFF  35,31
1D56:  MOVFF  34,30
1D5A:  MOVFF  33,2F
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
1D5E:  CLRF   01
1D60:  MOVLB  1
1D62:  CLRF   xD5
1D64:  CLRF   xD6
1D66:  MOVF   FBB,W
1D68:  ADDWF  xD5,W
1D6A:  MOVWF  33
1D6C:  MOVF   FBC,W
1D6E:  ADDWFC xD6,W
1D70:  MOVWF  34
1D72:  MOVLW  00
1D74:  ADDWFC 2E,W
1D76:  MOVWF  35
1D78:  MOVLW  00
1D7A:  ADDWFC 01,W
1D7C:  MOVWF  36
....................    	Q_CCP = 2; 
1D7E:  MOVLW  02
1D80:  MOVWF  2D
1D82:  MOVLB  0
....................    } 
.................... } 
....................  
1D84:  BCF    FA1.0
1D86:  GOTO   0084
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
....................    T3CON.TMR3ON = 0; 
....................    set_timer3(0); 
....................    setup_ccp1(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1;                        
....................    return 0; 
.................... } 
....................  
.................... void CP_activar_captura(int canal){ 
.................... 	//CODIGO DE MANEJO DE CCP 
.................... 	semaforo_ccp = 1; 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    tiempo_inicial = tiempo_final = 0; 
....................    set_timer3(0);      						//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
.................... } 
....................  
.................... void CP_desativar_captura(){ 
.................... 	//disable_interrupts(INT_CCP1); 
....................    //disable_interrupts(INT_CCP2); 
....................    disable_interrupts(GLOBAL); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    semaforo_ccp = 0; 
.................... } 
....................  
.................... int CP_ocupado(){ return (semaforo_ccp != 0);} 
....................  
.................... int32 CP_obtener_resultado(){ 
.................... 	return (tiempo_final - tiempo_inicial); 
.................... } 
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    set_timer3(0);      					//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
....................    //while(Q_CCP != 2){;}              //espera a que se carguen los valores de los tiempos 
....................    disable_interrupts(INT_CCP1); 
....................    disable_interrupts(INT_CCP2); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
....................    return (0); 
.................... } 
....................  
.................... #include "memoria.c" 
.................... //#include "Nucleo.h" 
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD		0x55 
.................... #define MEMORIA_CMD_VER_INFO		0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD				0x40 
.................... #define MEMORIA_CMD_READ_FILE		0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK			0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON		0x01 
.................... #define MEMORIA_OFF		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT		12 
.................... #define MEMORIA_NAME_TERMINATOR		0x00 
.................... #define MEMORIA_DELIMITADOR			0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE		0x00 
.................... #define MEMORIA_LOW_PERFORMANCE		0x40 
....................  
.................... #define FILE_WR 1 
.................... #define FILE_RD 0 
....................  
.................... //extern char MEM_info[5]; 
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... void MEMORIA_getinfo(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char* filename, short modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char* data, unsigned int size); 
.................... void MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char* buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
....................  
.................... extern void usb_cdc_putc_fast(char c); 
.................... extern char usb_cdc_getc(void); 
.................... extern void usb_cdc_putc(char c); 
.................... extern void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... extern float get_float_usb(); 
.................... extern signed long get_long_usb(); 
.................... extern signed int get_int_usb(); 
.................... extern void get_string_usb(char* s, unsigned int max); 
.................... extern BYTE gethex_usb(); 
.................... extern BYTE gethex1_usb(); 
....................  
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... //borrar para quitar el debug de memoria 
.................... //define debug_memoria 1	 
....................  
.................... // #define MEM_RX PIN_D7 
.................... // #define MEM_TX PIN_D6	 
.................... #define MEMORIA_PIN_RESET PIN_D5 
.................... #use rs232(uart1, stream=MEMORIA, BAUD=9600, TIMEOUT=1000) 
*
0640:  BTFSS  F9E.4
0642:  BRA    0640
0644:  MOVWF  FAD
0646:  GOTO   0652 (RETURN)
*
0676:  MOVLW  0C
0678:  MOVLB  1
067A:  MOVWF  xBA
067C:  MOVLW  85
067E:  MOVWF  xB9
0680:  MOVLW  02
0682:  MOVWF  xBB
0684:  MOVLW  9B
0686:  MOVWF  xBC
0688:  MOVLB  0
068A:  BRA    0654
068C:  MOVLB  1
068E:  DECFSZ xBB,F
0690:  BRA    0684
0692:  DECFSZ xB9,F
0694:  BRA    06A0
0696:  DECFSZ xBA,F
0698:  BRA    06A0
069A:  CLRF   x52
069C:  CLRF   01
069E:  BRA    06B4
06A0:  BTFSS  F9E.5
06A2:  BRA    0680
06A4:  MOVF   FAB,W
06A6:  MOVWF  x52
06A8:  MOVF   FAE,W
06AA:  MOVWF  01
06AC:  BTFSS  x52.1
06AE:  BRA    06B4
06B0:  BCF    FAB.4
06B2:  BSF    FAB.4
06B4:  MOVLB  0
06B6:  RETLW  00
.................... #define time_delay 1000 
....................  
.................... short MEMORIA_OK = FALSE; 
.................... short MEMORIA_HW = FALSE; 
.................... short timeout_error = FALSE; 
.................... short read_flag = 0; //utilizada por un bug en la lectura de archivos desde dispositivo de memoria 
.................... int8 MEM_proceso = INI_HW; 
.................... unsigned int i = 0; 
.................... unsigned int car = 0; 
.................... unsigned int32 tamano = 0; 
.................... char MEM_info[5] = {0x00,0x00,0x00,0x00,0x00}; 
.................... char MEM_file_name[MEMORIA_NAME_LENG_LIMIT]; 
.................... char MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
.................... char MEM_append = MEMORIA_APPEND; 
.................... //char MEM_performance = MEMORIA_HIGH_PERFORMANCE;	//cambiar a low performance 
.................... char MEM_performance = MEMORIA_LOW_PERFORMANCE; 
.................... char MEM_RESPONSE = MEMORIA_NOACK; 
....................  
.................... #ifdef debug_memoria 
.................... void update_proceso(int8 proceso){ 
.................... 	MEM_proceso = proceso; 
.................... 	printf(usb_cdc_putc_fast,"\n\rMp>%d", MEM_proceso); 
.................... 	return; 
.................... } 
.................... #endif 
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL INICIO DEL MODULO DE MEMORIA 
.................... 	====================================== 
.................... */ 
.................... /*==================== reset de memoria ======================*/ 
.................... int MEMORIA_reset(void){ 
.................... 	#ifdef debug_memoria 
.................... 	usb_cdc_putc_fast('r'); 
.................... 	#endif 
.................... 	output_float(PIN_D6); 
....................    output_low(MEMORIA_PIN_RESET); 
....................    delay_ms(1000); 
....................    read_flag = 0; 
....................    output_high(MEMORIA_PIN_RESET); 
....................    delay_ms(3000); 
....................    return(0); 
.................... } 
....................  
.................... /*==================== autobaudrate ======================*/ 
.................... int MEMORIA_init_hw(void){ 
*
1E68:  MOVLW  05
1E6A:  MOVLB  1
1E6C:  MOVWF  x6F
.................... 	int8 envios = 5; 
.................... 	#ifdef debug_memoria 
.................... 	update_proceso(INI_HW); 
.................... 	#else 
.................... 	MEM_proceso = INI_HW; 
1E6E:  CLRF   x53
.................... 	#endif 
.................... 	 
.................... 	do{ 
.................... 		MEMORIA_putc(MEMORIA_CMD_AUTOBAUD); 
1E70:  MOVLW  55
1E72:  MOVWF  xB8
1E74:  MOVLB  0
1E76:  CALL   064A
.................... 		MEM_RESPONSE = MEMORIA_getc(); 
1E7A:  CALL   06B8
1E7E:  MOVFF  01,16E
.................... 		envios --; 
1E82:  MOVLB  1
1E84:  DECF   x6F,F
.................... 		delay_ms(200); 
1E86:  MOVLW  C8
1E88:  MOVWF  x70
1E8A:  MOVLB  0
1E8C:  BRA    1E3C
.................... 	}while((envios > 0) && (MEM_RESPONSE != MEMORIA_ACK) );                                                        
1E8E:  MOVLB  1
1E90:  MOVF   x6F,F
1E92:  BZ    1E9A
1E94:  MOVF   x6E,W
1E96:  SUBLW  06
1E98:  BNZ   1E70
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){                                 
1E9A:  MOVF   x6E,W
1E9C:  SUBLW  06
1E9E:  BZ    1EA6
.................... 		return (1); 
1EA0:  MOVLW  01
1EA2:  MOVWF  01
1EA4:  BRA    1EB4
.................... 	} 
....................     
....................    MEMORIA_HW = TRUE; 
1EA6:  BSF    3F.3
....................    MEMORIA_OK = FALSE; 
1EA8:  BCF    3F.2
....................    read_flag = 0; 
1EAA:  BCF    3F.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(INI_SW); 
.................... 	#else 
.................... 	MEM_proceso = INI_SW; 
1EAC:  MOVLW  01
1EAE:  MOVWF  x53
.................... 	#endif 
.................... 	 
....................    return (0); 
1EB0:  MOVLW  00
1EB2:  MOVWF  01
.................... } 
1EB4:  MOVLB  0
1EB6:  GOTO   20E8 (RETURN)
....................  
.................... /*==================== iniciar memoria ======================*/ 
.................... int MEMORIA_init(void){ 
....................  
....................    if(!MEMORIA_HW || (MEM_proceso != INI_SW)) return (1); 
1EBA:  BTFSS  3F.3
1EBC:  BRA    1ECE
1EBE:  MOVLB  1
1EC0:  DECFSZ x53,W
1EC2:  BRA    1EC6
1EC4:  BRA    1ECA
1EC6:  MOVLB  0
1EC8:  BRA    1ECE
1ECA:  BRA    1ED6
1ECC:  MOVLB  0
1ECE:  MOVLW  01
1ED0:  MOVWF  01
1ED2:  BRA    1F18
1ED4:  MOVLB  1
.................... 	 
.................... 	MEMORIA_putc(MEMORIA_EXT_CMD); 
1ED6:  MOVLW  40
1ED8:  MOVWF  xB8
1EDA:  MOVLB  0
1EDC:  CALL   064A
....................    MEMORIA_putc(MEMORIA_CMD_INITIALIZE); 
1EE0:  MOVLW  69
1EE2:  MOVLB  1
1EE4:  MOVWF  xB8
1EE6:  MOVLB  0
1EE8:  CALL   064A
....................     
....................    MEM_RESPONSE = MEMORIA_getc(); 
1EEC:  CALL   06B8
1EF0:  MOVFF  01,16E
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK) return(2); 
1EF4:  MOVLB  1
1EF6:  MOVF   x6E,W
1EF8:  SUBLW  06
1EFA:  BZ    1F08
1EFC:  MOVLW  02
1EFE:  MOVWF  01
1F00:  MOVLB  0
1F02:  BRA    1F18
....................    else MEMORIA_OK = TRUE; 
1F04:  BRA    1F0C
1F06:  MOVLB  1
1F08:  BSF    3F.2
1F0A:  MOVLB  0
....................     
....................    read_flag = 0; 
1F0C:  BCF    3F.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
1F0E:  MOVLW  02
1F10:  MOVLB  1
1F12:  MOVWF  x53
.................... 	#endif 
....................    return (0); 
1F14:  MOVLW  00
1F16:  MOVWF  01
1F18:  MOVLB  0
.................... } 
1F1A:  GOTO   20EE (RETURN)
....................  
.................... /*====================get info======================*/ 
.................... void MEMORIA_getinfo(){ 
....................  
.................... 	MEMORIA_putc(MEMORIA_CMD_VER_INFO); 
....................    MEM_info[0] = MEMORIA_getc(); 
....................    MEM_info[1] = MEMORIA_getc(); 
....................    MEM_info[2] = MEMORIA_getc(); 
....................    MEM_info[3] = MEMORIA_getc(); 
....................    MEM_info[4] = MEMORIA_getc(); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\rMemInf: %x %x %x %x %x", MEM_info[0],MEM_info[1],MEM_info[2],MEM_info[3],MEM_info[4]); 
....................    #endif 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL MANEJO DE ARCHIVOS 
.................... 	====================================== 
.................... */ 
....................  
.................... /*====================abrir archivo======================*/ 
....................  
.................... int MEMORIA_open(char* filename, short modo){ 
....................  
....................    if(!MEMORIA_OK) return(1); 
*
05D6:  BTFSC  3F.2
05D8:  BRA    05E0
05DA:  MOVLW  01
05DC:  MOVWF  01
05DE:  BRA    063A
....................  
....................    if(modo){ 
05E0:  MOVLB  1
05E2:  MOVF   xB6,F
05E4:  BZ    05EC
....................       #ifdef debug_memoria 
.................... 		update_proceso(WR); 
.................... 		#else 
.................... 		MEM_proceso = WR; 
05E6:  MOVLW  05
05E8:  MOVWF  x53
.................... 		#endif 
....................    }else{ 
05EA:  BRA    05F0
.................... 		#ifdef debug_memoria 
.................... 		update_proceso(RD); 
.................... 		#else 
.................... 		MEM_proceso = RD; 
05EC:  MOVLW  03
05EE:  MOVWF  x53
.................... 		#endif 
....................    } 
....................     
....................    car = strlen(filename); 
05F0:  MOVFF  1B5,1B8
05F4:  MOVFF  1B4,1B7
05F8:  MOVLB  0
05FA:  BRA    051A
05FC:  MOVFF  01,155
....................    car = (car <= MEMORIA_NAME_LENG_LIMIT)? car : MEMORIA_NAME_LENG_LIMIT;  
0600:  MOVLB  1
0602:  MOVF   x55,W
0604:  SUBLW  0C
0606:  BNC   060C
0608:  MOVF   x55,W
060A:  BRA    060E
060C:  MOVLW  0C
060E:  MOVWF  x55
....................    strncpy(MEM_file_name, filename, car); 
0610:  MOVLW  01
0612:  MOVWF  xB8
0614:  MOVLW  5F
0616:  MOVWF  xB7
0618:  MOVFF  1B5,1BA
061C:  MOVFF  1B4,1B9
0620:  MOVFF  155,1BB
0624:  MOVLB  0
0626:  BRA    0556
....................     
....................    i = 0; 
0628:  MOVLB  1
062A:  CLRF   x54
....................    timeout_error = FALSE; 
062C:  BCF    3F.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
062E:  MOVLW  01
0630:  MOVWF  x6B
....................    MEM_RESPONSE = MEMORIA_NOACK; 
0632:  MOVLW  15
0634:  MOVWF  x6E
....................    return (0); 
0636:  MOVLW  00
0638:  MOVWF  01
063A:  MOVLB  0
.................... } 
063C:  GOTO   09EC (RETURN)
....................  
.................... /*==================== cancelar proceso ======================*/ 
....................  
.................... int MEMORIA_cancel(void){ 
....................  
....................    if((MEM_proceso != GET) || (MEM_proceso != SET)){ 
....................       return(-1); 
....................    } 
....................     
....................    if(MEM_proceso == GET){ 
....................       fputc(MEMORIA_NOACK, MEMORIA); 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................  
....................    if(MEM_proceso == SET){ 
....................       while(tamano > 0 ){ 
....................          fputc(0x00,MEMORIA); 
....................          --tamano; 
....................       } 
....................    } 
....................  
....................    tamano = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    return (0); 
.................... } 
....................  
.................... /*==================== enviar comando de escritura ======================*/ 
.................... /* 
....................  *BUG: puede retornar 1 0 en la primera escritura del archivo 
....................  *TODO: corregir para primera escritura  
.................... */ 
.................... int MEMORIA_write(unsigned int size){ 
....................     
....................    if(!MEMORIA_OK)return(-1); 
*
06F2:  BTFSC  3F.2
06F4:  BRA    06FC
06F6:  MOVLW  FF
06F8:  MOVWF  01
06FA:  BRA    07D8
....................    if(MEM_proceso != WR)return(-2); 
06FC:  MOVLB  1
06FE:  MOVF   x53,W
0700:  SUBLW  05
0702:  BZ    070E
0704:  MOVLW  FE
0706:  MOVWF  01
0708:  MOVLB  0
070A:  BRA    07D8
070C:  MOVLB  1
....................        
....................     
....................    //buffer maximo de 100 bytes 
....................    if((size > 0) && (size <= MAX_BUFFER)) 
070E:  MOVF   xB4,F
0710:  BZ    071C
0712:  MOVF   xB4,W
0714:  SUBLW  64
0716:  BNC   071C
....................       MEM_handshaking = MEMORIA_NO_HANDSHAKING; 
0718:  CLRF   x6B
....................    else 
071A:  BRA    0726
....................       return (-3); 
071C:  MOVLW  FD
071E:  MOVWF  01
0720:  MOVLB  0
0722:  BRA    07D8
0724:  MOVLB  1
....................     
....................    tamano = (unsigned int32)size; 
0726:  CLRF   x59
0728:  CLRF   x58
072A:  CLRF   x57
072C:  MOVFF  1B4,156
....................    //tamano = (int32)size; 
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
0730:  MOVLW  40
0732:  MOVWF  xB8
0734:  MOVLB  0
0736:  RCALL  064A
....................    MEMORIA_putc(MEMORIA_CMD_WRITE_FILE); 
0738:  MOVLW  74
073A:  MOVLB  1
073C:  MOVWF  xB8
073E:  MOVLB  0
0740:  RCALL  064A
....................    MEMORIA_putc((MEM_handshaking | MEM_append | MEM_performance)); 
0742:  MOVLB  1
0744:  MOVF   x6B,W
0746:  IORWF  x6C,W
0748:  IORWF  x6D,W
074A:  MOVWF  xB5
074C:  MOVWF  xB8
074E:  MOVLB  0
0750:  RCALL  064A
....................     
....................    for(i = 0; i < car; i++) 
0752:  MOVLB  1
0754:  CLRF   x54
0756:  MOVF   x55,W
0758:  SUBWF  x54,W
075A:  BC    077C
....................       MEMORIA_putc(MEM_file_name[i]); 
075C:  CLRF   03
075E:  MOVF   x54,W
0760:  ADDLW  5F
0762:  MOVWF  FE9
0764:  MOVLW  01
0766:  ADDWFC 03,W
0768:  MOVWF  FEA
076A:  MOVFF  FEF,1B5
076E:  MOVFF  1B5,1B8
0772:  MOVLB  0
0774:  RCALL  064A
0776:  MOVLB  1
0778:  INCF   x54,F
077A:  BRA    0756
....................  
....................    MEMORIA_putc(0x00); 
077C:  CLRF   xB8
077E:  MOVLB  0
0780:  RCALL  064A
....................  
....................    MEMORIA_putc(make8(tamano,3)); 
0782:  MOVFF  159,1B5
0786:  MOVFF  159,1B8
078A:  RCALL  064A
....................    MEMORIA_putc(make8(tamano,2)); 
078C:  MOVFF  158,1B5
0790:  MOVFF  158,1B8
0794:  RCALL  064A
....................    MEMORIA_putc(make8(tamano,1)); 
0796:  MOVFF  157,1B5
079A:  MOVFF  157,1B8
079E:  RCALL  064A
....................    MEMORIA_putc(make8(tamano,0)); 
07A0:  MOVFF  156,1B5
07A4:  MOVFF  156,1B8
07A8:  RCALL  064A
....................  
....................    MEM_RESPONSE = MEMORIA_getc(); 
07AA:  RCALL  06B8
07AC:  MOVFF  01,16E
....................    //reparacion de bug a primera escritura 
....................    if(MEM_RESPONSE == 0x00){ 
07B0:  MOVLB  1
07B2:  MOVF   x6E,F
07B4:  BNZ   07C0
....................    	MEM_RESPONSE = MEMORIA_getc(); 
07B6:  MOVLB  0
07B8:  RCALL  06B8
07BA:  MOVFF  01,16E
07BE:  MOVLB  1
....................    } 
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){ 
07C0:  MOVF   x6E,W
07C2:  SUBLW  06
07C4:  BZ    07D0
....................       return (-4); 
07C6:  MOVLW  FC
07C8:  MOVWF  01
07CA:  MOVLB  0
07CC:  BRA    07D8
07CE:  MOVLB  1
....................    } 
....................    #ifdef debug_memoria 
.................... 	update_proceso(SET); 
.................... 	#else 
.................... 	MEM_proceso = SET; 
07D0:  MOVLW  06
07D2:  MOVWF  x53
.................... 	#endif 
....................    return (0); 
07D4:  MOVLW  00
07D6:  MOVWF  01
07D8:  MOVLB  0
.................... } 
07DA:  GOTO   0A22 (RETURN)
....................  
.................... /*==================== enviar datos de escritura ======================*/ 
.................... /* 
....................  * corrwgir deacuerdo a MEMORIA_write() 
....................  */ 
.................... int MEMORIA_set_data(char *data, unsigned int size){ 
....................  
....................    if(!MEMORIA_OK)return(-5); 
07DE:  BTFSC  3F.2
07E0:  BRA    07E8
07E2:  MOVLW  FB
07E4:  MOVWF  01
07E6:  BRA    088E
....................    if(MEM_proceso != SET) return(-6); 
07E8:  MOVLB  1
07EA:  MOVF   x53,W
07EC:  SUBLW  06
07EE:  BZ    07FA
07F0:  MOVLW  FA
07F2:  MOVWF  01
07F4:  MOVLB  0
07F6:  BRA    088E
07F8:  MOVLB  1
....................    if(tamano <= 0)return(-7); 
07FA:  MOVF   x56,F
07FC:  BNZ   0814
07FE:  MOVF   x57,F
0800:  BNZ   0814
0802:  MOVF   x58,F
0804:  BNZ   0814
0806:  MOVF   x59,F
0808:  BNZ   0814
080A:  MOVLW  F9
080C:  MOVWF  01
080E:  MOVLB  0
0810:  BRA    088E
0812:  MOVLB  1
....................  
....................    i = 0; 
0814:  CLRF   x54
....................    while((tamano > 0)&&(i < size)){ 
0816:  MOVF   x56,F
0818:  BNZ   0826
081A:  MOVF   x57,F
081C:  BNZ   0826
081E:  MOVF   x58,F
0820:  BNZ   0826
0822:  MOVF   x59,F
0824:  BZ    085C
0826:  MOVF   xB6,W
0828:  SUBWF  x54,W
082A:  BC    085C
....................       MEMORIA_putc(data[i]); 
082C:  CLRF   03
082E:  MOVF   x54,W
0830:  ADDWF  xB4,W
0832:  MOVWF  FE9
0834:  MOVF   xB5,W
0836:  ADDWFC 03,W
0838:  MOVWF  FEA
083A:  MOVFF  FEF,1B7
083E:  MOVFF  1B7,1B8
0842:  MOVLB  0
0844:  RCALL  064A
....................       i++; 
0846:  MOVLB  1
0848:  INCF   x54,F
....................       tamano--; 
084A:  MOVLW  FF
084C:  ADDWF  x56,F
084E:  BTFSS  FD8.0
0850:  ADDWF  x57,F
0852:  BTFSS  FD8.0
0854:  ADDWF  x58,F
0856:  BTFSS  FD8.0
0858:  ADDWF  x59,F
....................    } 
085A:  BRA    0816
....................     
....................    //si no hay mas datos 
....................    if(tamano <= 0){ 
085C:  MOVF   x56,F
085E:  BNZ   088A
0860:  MOVF   x57,F
0862:  BNZ   088A
0864:  MOVF   x58,F
0866:  BNZ   088A
0868:  MOVF   x59,F
086A:  BNZ   088A
....................       MEM_RESPONSE = MEMORIA_getc(); 
086C:  MOVLB  0
086E:  RCALL  06B8
0870:  MOVFF  01,16E
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
0874:  MOVLB  1
0876:  MOVF   x6E,W
0878:  SUBLW  06
087A:  BZ    0886
....................          return (-8); 
087C:  MOVLW  F8
087E:  MOVWF  01
0880:  MOVLB  0
0882:  BRA    088E
0884:  MOVLB  1
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
0886:  MOVLW  07
0888:  MOVWF  x53
.................... 		#endif 
....................    } 
....................    return (i); 
088A:  MOVFF  154,01
088E:  MOVLB  0
.................... } 
0890:  GOTO   0A60 (RETURN)
....................  
.................... /*==================== enviar comando de lectura ======================*/ 
....................  
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes){ 
....................    char Umsb = 0, Ulsb = 0, Lmsb = 0,Llsb = 0, dummy= 0; 
....................  
....................    if(!MEMORIA_OK)return(-1); 
....................    if(MEM_proceso != RD)return(-2); 
....................  
....................    if((num_bytes > 0) && (num_bytes <= MAX_BUFFER)) 
....................       MEM_handshaking = num_bytes; 
....................    else 
....................       return (-3); 
....................     
....................     
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_READ_FILE); 
....................    MEMORIA_putc(MEM_handshaking); 
....................     
....................    for(i = 0; i < car; i++) 
....................       MEMORIA_putc(MEM_file_name[i]); 
.................... 	 
.................... 	fputc(0x00, MEMORIA); 
.................... 	// hay un bug al leer por primera vez un archivo 
.................... 	// genera 2 ACK antes del tamao del archivo 
.................... 	if(read_flag == 0){ 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		read_flag = 1; 
.................... 	} 
.................... 	//bug de comunicacion 
.................... 	 
.................... 	Umsb = fgetc(MEMORIA); 
....................    Ulsb = fgetc(MEMORIA); 
....................    Lmsb = fgetc(MEMORIA); 
....................    Llsb = fgetc(MEMORIA); 
....................     
....................    tamano = make32(Umsb,Ulsb,Lmsb,Llsb); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r==%x %x %x %x", Umsb, Ulsb,Lmsb,Llsb); 
.................... 	update_proceso(GET); 
.................... 	#else 
.................... 	MEM_proceso = GET; 
.................... 	#endif 
....................    return (tamano); 
.................... } 
....................  
....................  
.................... /*==================== obtener datos de la lectura ======================*/ 
....................  
.................... int MEMORIA_get_data(char *buffer){    
....................    char c = 0x00; 
....................  
....................    if(!MEMORIA_OK) return(-1); 
....................    if(MEM_proceso != GET) return(-2); 
....................    if(tamano <= 0) return(-3); 
....................  
....................    i = 0; 
....................    MEMORIA_putc(MEMORIA_ACK);//envia un ACK para recivir nuevos datos 
....................    while((i < MEM_handshaking) && (tamano > 0 )){ 
....................       c = MEMORIA_getc(); 
....................       buffer[i] = c; 
....................       i++; 
....................       tamano--; 
....................    } 
....................  
....................    //si alcanzo el total de datos 
....................    if(tamano == 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
....................          return (-4); 
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i);    
.................... } 
....................  
.................... /*==================== cerrar el archivo abierto ======================*/ 
....................  
.................... int MEMORIA_close(void){ 
.................... 	/* 
.................... 	* hay un bug en esta funcion que no contempla limpiar 
.................... 	* la configuracion cuando no ha iniciado el hardware o 
.................... 	* despues de un reset 
.................... 	*/ 
.................... 	/* 
....................    if(!MEMORIA_OK)return (1); 
....................    if(MEM_proceso != CLOSE) return(2); 
....................    */ 
....................    strcpy (MEM_file_name,"");	//cambiar para inicializar a 0 
0894:  MOVLW  01
0896:  MOVWF  FEA
0898:  MOVLW  5F
089A:  MOVWF  FE9
089C:  MOVLW  00
089E:  RCALL  0278
08A0:  TBLRD*-
08A2:  TBLRD*+
08A4:  MOVF   FF5,W
08A6:  MOVWF  FEE
08A8:  IORLW  00
08AA:  BNZ   08A2
....................    i = 0; 
08AC:  MOVLB  1
08AE:  CLRF   x54
....................    car = 0; 
08B0:  CLRF   x55
....................    timeout_error = FALSE; 
08B2:  BCF    3F.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
08B4:  MOVLW  01
08B6:  MOVWF  x6B
....................    MEM_RESPONSE = MEMORIA_NOACK; 
08B8:  MOVLW  15
08BA:  MOVWF  x6E
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
08BC:  MOVLW  02
08BE:  MOVWF  x53
.................... 	#endif 
....................    return(0); 
08C0:  MOVLW  00
08C2:  MOVWF  01
.................... } 
08C4:  MOVLB  0
08C6:  GOTO   0A88 (RETURN)
....................  
.................... /*	====================================== 
.................... 	FUNCIONES FUNCIONES DE CONTROL Y BAJO NIVEL 
.................... 	====================================== 
.................... */ 
....................  
.................... /*==================== memoria ocupada =======================*/ 
.................... /*comprueba que no se este realizando un porceso anterior en la memoria*/ 
.................... int MEMORIA_is_busy(void){ 
....................    return ((MEM_proceso == OPEN )? 0 : 1); 
.................... }  
....................  
.................... /*==================== colocar un caracter en el bus======================*/ 
.................... void MEMORIA_putc(char c){ 
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, "\n\r>%X", c); 
.................... 	#endif 
....................    fputc(c, MEMORIA); 
*
064A:  MOVLB  1
064C:  MOVF   xB8,W
064E:  MOVLB  0
0650:  BRA    0640
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, " e%X", rs232_errors); 
.................... 	#endif 
....................    return; 
.................... } 
0652:  RETLW  00
....................  
.................... /*==================== obtiene un caracter del bus======================*/ 
.................... char MEMORIA_getc(void){ 
*
06B8:  MOVLB  1
06BA:  CLRF   xB7
06BC:  MOVLW  03
06BE:  MOVWF  xB8
.................... 	char c = 0x00, cont = 3; 
....................    timeout_error=FALSE; 
06C0:  BCF    3F.4
....................    while(!kbhit(MEMORIA) && cont > 0 && !c){ 
06C2:  BTFSC  F9E.5
06C4:  BRA    06DC
06C6:  MOVF   xB8,F
06C8:  BZ    06DC
06CA:  MOVF   xB7,F
06CC:  BNZ   06DC
....................    	c = fgetc(MEMORIA); 
06CE:  MOVLB  0
06D0:  RCALL  0676
06D2:  MOVFF  01,1B7
....................    	#ifdef debug_memoria 
....................    	usb_cdc_putc_fast('*'); 
....................    	#endif 
....................    	cont--; 
06D6:  MOVLB  1
06D8:  DECF   xB8,F
....................    } 
06DA:  BRA    06C2
....................     
....................    if(!c) c = fgetc(MEMORIA); 
06DC:  MOVF   xB7,F
06DE:  BNZ   06EA
06E0:  MOVLB  0
06E2:  RCALL  0676
06E4:  MOVFF  01,1B7
06E8:  MOVLB  1
....................     
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r<%x e%x", c, rs232_errors); 
....................    #endif 
....................    return(c); 
06EA:  MOVFF  1B7,01
.................... } 
06EE:  MOVLB  0
06F0:  RETLW  00
....................  
.................... #include "utilidades.c" 
.................... //#include "Nucleo.h" 
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
.................... #define INDICADOR_AMARILLO	PIN_E0 
.................... #define INDICADOR_USB		PIN_E1 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
.................... #define MYDIM 64; 
.................... char MyArray[MYDIM]; 
.................... */ 
....................  
.................... int16 crc_1021(int16 old_crc, int8 data) 
.................... {  
....................   int16 crc; 
....................   int16 x; 
....................   x = make8(old_crc,1) ^ data;  //x = ((old_crc>>8) ^ data) & 0xff;  
....................   x ^= x>>4; 
....................   crc = (old_crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
....................   crc &= 0xffff;  
....................   return crc;  
.................... } 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng){ 
.................... 	unsigned int8 i;  
....................    int16 MyCRC; 
....................     
....................    MyCRC = 0xFFFF;  
....................    for(i=0 ; i<leng ; i++) {  
....................       MyCRC = crc_1021(MyCRC,buffer[i]);  
....................    } 
....................    return (MyCRC); 
.................... } 
....................  
.................... #ifndef SIMULACION 
.................... int1 _debug_usb(void){ 
.................... 	if(COM_sense() == USB_OK){ 
....................       output_bit(INDICADOR_USB, 1); 
....................       return (1); 
.................... 	}else{ 
.................... 		output_bit(INDICADOR_USB, 0); 
.................... 		return (0); 
.................... 	} 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /*======================= implementacion de tareas =======================*/ 
....................  
....................  

Configuration Fuses:
   Word  1: CE3C   IESO FCMEN HSPLL PLL5 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
