CCS PCH C Compiler, Version 4.104, 5967               09-sep-14 10:12

               Filename: D:\Proyecto\Pruebas\Nucleo.lst

               ROM used: 10424 bytes (32%)
                         Largest free fragment is 22344
               RAM used: 620 (30%) at main() level
                         799 (39%) worst case
               Stack:    17 worst case (8 in main + 9 for interrupts)

*
0000:  GOTO   2450
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FA0.1
004A:  GOTO   0054
004E:  BTFSC  FA1.1
0050:  GOTO   1A2C
0054:  BTFSS  F9D.2
0056:  GOTO   0060
005A:  BTFSC  F9E.2
005C:  GOTO   1A34
0060:  BTFSS  FA0.0
0062:  GOTO   006C
0066:  BTFSC  FA1.0
0068:  GOTO   1AD8
006C:  BTFSS  FA0.5
006E:  GOTO   0078
0072:  BTFSC  FA1.5
0074:  GOTO   105A
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "Nucleo.h" 
.................... /*=========================Configuracion del Hardware========================== 
....................  
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentandolo a 96Mhz-> div:2 a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU 
....................  
.................... ==============================================================================*/ 
....................  
.................... /*=================== FILE HEADER ===================================*/ 
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... //#include "PIC18F4550.h" 
.................... #device adc=10 
.................... //#define SIMULACION 1   // comentar esto si se prueba en forma real 
....................  
.................... /*====================fuses de configuracion del dispositivo==================*/ 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN,NOPBADEN,CCP2C1 
.................... /* 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.1V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage programing, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5                     //(PLL prescaler) PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3                  //postscaler PLL div by 4 (whit pll enable)                      
.................... #FUSES USBDIV                  //enable USBDIV, USB clock source come from PLL divide by 2 
.................... #FUSES VREGEN                  //internal regulator USB enable 
.................... #FUSES ICPRT                   
.................... #FUSES CCP2C1                  //CPP input/output multiplexed whit RC1 
....................  
....................  
.................... /*============================ DEFINICIONES DE PINES =========================*/ 
.................... #define PIN_SDA   PIN_B0 
.................... #define PIN_SCL   PIN_B1 
....................  
.................... //#define PIN_XMIT   PIN_C6 
.................... //#define PIN_RCV   PIN_C7 
....................  
.................... #define PIN_XMIT   PIN_D0 
.................... #define PIN_RCV   PIN_D1 
....................  
....................     
.................... #define PIN_LOG   PIN_D2 
....................  
.................... #define SPI_SS      PIN_D7 
.................... #define SPI_MISO   PIN_D6 
.................... #define SPI_MOSI   PIN_D5 
.................... #define SPI_SCL   PIN_D4 
....................  
.................... #define CONFIG_PORT_C   0x83      //v1 
.................... #define CONFIG_PORT_D   0x4E      //v2 
....................  
....................  
.................... /*=================== CONFIGURACION DEL RELOJ DE TRABAJO =====================*/ 
.................... #use delay(clock=16000000)   //cambiar el valor del clock si se cambia la frecuencia de la CPU 
....................  
.................... /*=================== CONFIGURACION LIBRERIAS DE COMUNICACION ================*/ 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
.................... //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#use i2c(master, sda=PIN_B0, scl=PIN_B1) 
.................... //#use fixed_io(b_outputs=PIN_B0, PIN_B1) 
.................... //#use i2c(master, FORCE_HW) 
.................... /*=================== LIBRERIAS ESTANDAR PARA EL MANEJO DE DATOS =============*/ 
....................  
.................... #endif   //ifndef NUCLEO_H 
....................  
.................... #define use_rtos 
.................... #ifdef use_rtos 
....................    #use RTOS(timer=0, minor_cycle=50ms, statistics) 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// Two examples are provided:                                        //// 
.................... ////      ex_usb_serial.c                                              //// 
.................... ////      ex_usb_serial2.c                                             //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /*============================================================================ 
.................... CDC USB descriptor propio para el manejo de datos por usb 
....................  
....................  
....................  
....................  
....................  
.................... ============================================================================*/ 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x000B 
.................... #define  USB_CONFIG_VID       0x04D8 
.................... #define  USB_CONFIG_BUS_POWER 0x64   		//100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #define USB_HID_DEVICE  FALSE 
.................... #define USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................     
....................    /*	 
....................    ////////////////////////////////////////// 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................    /////////////////////////////////////////// 
....................    */ 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
....................          0x0B,0x00, //product id   ==10,11 
....................          0x00,0x01, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //#if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          40, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          '_',0, 
....................          'C',0, 
....................          'o',0, 
....................          'n',0, 
....................          't',0, 
....................          'r',0, 
....................          'o',0, 
....................          'l',0, 
....................          '_',0, 
....................          'D',0, 
....................          'e',0, 
....................          'v',0, 
....................          'i',0, 
....................          'c',0, 
....................          'e',0, 
....................          's',0 
....................  
.................... }; 
.................... //#endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0BD2:  CLRF   03
0BD4:  MOVLB  2
0BD6:  MOVF   x6C,W
0BD8:  ADDLW  70
0BDA:  MOVWF  FE9
0BDC:  MOVLW  0F
0BDE:  ADDWFC 03,W
0BE0:  MOVWF  FEA
0BE2:  MOVF   FEF,F
0BE4:  BZ    0C0A
0BE6:  MOVF   x6C,W
0BE8:  MULLW  08
0BEA:  MOVF   FF3,W
0BEC:  CLRF   x6E
0BEE:  MOVWF  x6D
0BF0:  MOVLW  04
0BF2:  ADDWF  x6D,F
0BF4:  MOVLW  00
0BF6:  ADDWFC x6E,F
0BF8:  MOVFF  26D,FE9
0BFC:  MOVLW  04
0BFE:  ADDWF  x6E,W
0C00:  MOVWF  FEA
0C02:  MOVFF  FEF,26D
0C06:  BTFSS  x6D.7
0C08:  BRA    0C0E
0C0A:  MOVLW  00
0C0C:  BRA    0C10
0C0E:  MOVLW  01
0C10:  MOVWF  01
.................... } 
0C12:  MOVLB  0
0C14:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
14C8:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
14CA:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
14CC:  MOVLW  08
14CE:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
14D0:  MOVF   F94,W
14D2:  IORLW  30
14D4:  MOVLB  2
14D6:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
14D8:  CLRF   28
14DA:  CLRF   16
14DC:  BTFSC  FF2.7
14DE:  BSF    16.7
14E0:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
14E2:  MOVLB  0
14E4:  CALL   03C0
14E8:  BTFSC  16.7
14EA:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
14EC:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
14A6:  CLRF   16
14A8:  BTFSC  FF2.7
14AA:  BSF    16.7
14AC:  BCF    FF2.7
....................    usb_token_reset(); 
14AE:  CALL   03C0
14B2:  BTFSC  16.7
14B4:  BSF    FF2.7
....................    UCON = 0; 
14B6:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
14B8:  MOVLW  14
14BA:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
14BC:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
14BE:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
14C0:  MOVLW  01
14C2:  MOVWF  28
.................... } 
14C4:  GOTO   14FA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
1B8E:  RCALL  14C8
.................... } 
1B90:  GOTO   1B9C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
*
14EE:  BSF    F95.3
14F0:  BTFSS  F83.3
14F2:  BRA    14FC
....................    { 
....................       if (UCON_USBEN==0)  
14F4:  BTFSC  F6D.3
14F6:  BRA    14FA
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
14F8:  BRA    14A6
....................       } 
....................    } 
....................    else  
14FA:  BRA    1502
....................    { 
....................       if (UCON_USBEN==1)   
14FC:  BTFSS  F6D.3
14FE:  BRA    1502
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
1500:  RCALL  14C8
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1502:  DECFSZ 28,W
1504:  BRA    151C
1506:  BTFSC  F6D.5
1508:  BRA    151C
....................    { 
....................       UIR=0; 
150A:  CLRF   F68
....................       UIE=0; 
150C:  CLRF   F69
....................       enable_interrupts(INT_USB); 
150E:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1510:  MOVLW  C0
1512:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1514:  MOVLW  11
1516:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1518:  MOVLW  02
151A:  MOVWF  28
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
151C:  GOTO   152A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0C16:  MOVFF  267,26C
0C1A:  RCALL  0BD2
0C1C:  MOVF   01,F
0C1E:  BZ    0CE8
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0C20:  MOVLB  2
0C22:  MOVF   x67,W
0C24:  MULLW  08
0C26:  MOVF   FF3,W
0C28:  CLRF   x6D
0C2A:  MOVWF  x6C
0C2C:  MOVLW  04
0C2E:  ADDWF  x6C,F
0C30:  MOVLW  00
0C32:  ADDWFC x6D,F
0C34:  MOVLW  01
0C36:  ADDWF  x6C,W
0C38:  MOVWF  01
0C3A:  MOVLW  00
0C3C:  ADDWFC x6D,W
0C3E:  MOVWF  03
0C40:  MOVFF  01,FE9
0C44:  MOVLW  04
0C46:  ADDWF  03,W
0C48:  MOVWF  FEA
0C4A:  MOVFF  268,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0C4E:  MOVF   x6A,W
0C50:  SUBLW  02
0C52:  BNZ   0C82
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0C54:  MOVF   x67,W
0C56:  MULLW  08
0C58:  MOVF   FF3,W
0C5A:  CLRF   x6D
0C5C:  MOVWF  x6C
0C5E:  MOVLW  04
0C60:  ADDWF  x6C,F
0C62:  MOVLW  00
0C64:  ADDWFC x6D,F
0C66:  MOVFF  26C,FE9
0C6A:  MOVLW  04
0C6C:  ADDWF  x6D,W
0C6E:  MOVWF  FEA
0C70:  MOVFF  FEF,26B
....................          if (bit_test(i,6)) 
0C74:  BTFSS  x6B.6
0C76:  BRA    0C7C
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0C78:  CLRF   x6A
....................          else 
0C7A:  BRA    0C80
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0C7C:  MOVLW  01
0C7E:  MOVWF  x6A
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0C80:  BRA    0CA8
0C82:  MOVF   x6A,W
0C84:  SUBLW  04
0C86:  BNZ   0CA8
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0C88:  MOVF   x67,W
0C8A:  MULLW  08
0C8C:  MOVF   FF3,W
0C8E:  CLRF   x6D
0C90:  MOVWF  FE9
0C92:  MOVLW  04
0C94:  ADDWF  x6D,W
0C96:  MOVWF  FEA
0C98:  MOVFF  FEF,26B
....................          if (bit_test(i,6)) 
0C9C:  BTFSS  x6B.6
0C9E:  BRA    0CA6
....................             tgl = USB_DTS_DATA1; 
0CA0:  MOVLW  01
0CA2:  MOVWF  x6A
....................          else 
0CA4:  BRA    0CA8
....................             tgl = USB_DTS_DATA0; 
0CA6:  CLRF   x6A
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0CA8:  DECFSZ x6A,W
0CAA:  BRA    0CB2
....................          i=0xC8;  //DATA1, UOWN 
0CAC:  MOVLW  C8
0CAE:  MOVWF  x6B
....................       else //if (tgl == USB_DTS_DATA0)  
0CB0:  BRA    0CB6
....................          i=0x88; //DATA0, UOWN 
0CB2:  MOVLW  88
0CB4:  MOVWF  x6B
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0CB6:  BTFSC  x69.0
0CB8:  BSF    x6B.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0CBA:  BTFSC  x69.1
0CBC:  BSF    x6B.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0CBE:  MOVF   x67,W
0CC0:  MULLW  08
0CC2:  MOVF   FF3,W
0CC4:  CLRF   x6D
0CC6:  MOVWF  x6C
0CC8:  MOVLW  04
0CCA:  ADDWF  x6C,F
0CCC:  MOVLW  00
0CCE:  ADDWFC x6D,F
0CD0:  MOVFF  26C,FE9
0CD4:  MOVLW  04
0CD6:  ADDWF  x6D,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  26B,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0CDE:  MOVLW  01
0CE0:  MOVWF  01
0CE2:  BRA    0CEE
....................    } 
....................    else  
0CE4:  BRA    0CE6
0CE6:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0CE8:  MOVLW  00
0CEA:  MOVWF  01
0CEC:  MOVLB  2
.................... } 
0CEE:  MOVLB  0
0CF0:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
0DF0:  MOVFF  25F,26C
0DF4:  RCALL  0BD2
0DF6:  MOVF   01,F
0DF8:  BZ    0E7C
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0DFA:  MOVLB  2
0DFC:  MOVF   x5F,W
0DFE:  MULLW  08
0E00:  MOVF   FF3,W
0E02:  CLRF   x68
0E04:  MOVWF  x67
0E06:  MOVLW  04
0E08:  ADDWF  x67,F
0E0A:  MOVLW  00
0E0C:  ADDWFC x68,F
0E0E:  MOVLW  02
0E10:  ADDWF  x67,W
0E12:  MOVWF  01
0E14:  MOVLW  00
0E16:  ADDWFC x68,W
0E18:  MOVWF  03
0E1A:  MOVFF  01,FE9
0E1E:  MOVLW  04
0E20:  ADDWF  03,W
0E22:  MOVWF  FEA
0E24:  MOVFF  FEC,03
0E28:  MOVF   FED,F
0E2A:  MOVFF  FEF,265
0E2E:  MOVFF  03,266
....................       memcpy(buff_add, ptr, len);      
0E32:  MOVFF  266,FEA
0E36:  MOVFF  265,FE9
0E3A:  MOVFF  261,FE2
0E3E:  MOVFF  260,FE1
0E42:  MOVFF  263,02
0E46:  MOVFF  262,01
0E4A:  MOVF   01,F
0E4C:  BZ    0E52
0E4E:  INCF   02,F
0E50:  BRA    0E56
0E52:  MOVF   02,F
0E54:  BZ    0E62
0E56:  MOVFF  FE6,FEE
0E5A:  DECFSZ 01,F
0E5C:  BRA    0E56
0E5E:  DECFSZ 02,F
0E60:  BRA    0E56
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
0E62:  MOVFF  25F,267
0E66:  MOVFF  263,269
0E6A:  MOVFF  262,268
0E6E:  MOVFF  264,26A
0E72:  MOVLB  0
0E74:  RCALL  0C16
0E76:  MOVF   01,W
0E78:  BRA    0E80
....................    } 
....................    else  
0E7A:  BRA    0E7C
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0E7C:  MOVLW  00
0E7E:  MOVWF  01
.................... } 
0E80:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0B08:  MOVLB  2
0B0A:  MOVF   x5E,W
0B0C:  MULLW  08
0B0E:  MOVF   FF3,W
0B10:  CLRF   x64
0B12:  MOVWF  FE9
0B14:  MOVLW  04
0B16:  ADDWF  x64,W
0B18:  MOVWF  FEA
0B1A:  MOVFF  FEF,260
....................    if (tgl == USB_DTS_TOGGLE)  
0B1E:  MOVF   x5F,W
0B20:  SUBLW  02
0B22:  BNZ   0B30
....................    { 
....................       if (bit_test(i,6)) 
0B24:  BTFSS  x60.6
0B26:  BRA    0B2C
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0B28:  CLRF   x5F
....................       else 
0B2A:  BRA    0B30
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0B2C:  MOVLW  01
0B2E:  MOVWF  x5F
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0B30:  MOVF   x5F,W
0B32:  SUBLW  03
0B34:  BNZ   0B5C
....................    { 
....................       i = 0x84; 
0B36:  MOVLW  84
0B38:  MOVWF  x60
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0B3A:  MOVF   x5E,W
0B3C:  MULLW  08
0B3E:  MOVF   FF3,W
0B40:  CLRF   x64
0B42:  MOVWF  x63
0B44:  MOVLW  04
0B46:  ADDWF  x63,F
0B48:  MOVLW  00
0B4A:  ADDWFC x64,F
0B4C:  MOVFF  263,FE9
0B50:  MOVLW  04
0B52:  ADDWF  x64,W
0B54:  MOVWF  FEA
0B56:  MOVLW  84
0B58:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0B5A:  BRA    0B6A
0B5C:  DECFSZ x5F,W
0B5E:  BRA    0B66
....................       i = 0xC8;  //DATA1, UOWN 
0B60:  MOVLW  C8
0B62:  MOVWF  x60
....................    else //if (tgl == USB_DTS_DATA0)  
0B64:  BRA    0B6A
....................       i = 0x88; //DATA0, UOWN 
0B66:  MOVLW  88
0B68:  MOVWF  x60
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0B6A:  BCF    FD8.0
0B6C:  RLCF   x5E,W
0B6E:  CLRF   03
0B70:  MOVFF  FF2,263
0B74:  BCF    FF2.7
0B76:  MOVLB  0
0B78:  CALL   012A
0B7C:  TBLRD*+
0B7E:  MOVFF  FF5,03
0B82:  MOVLB  2
0B84:  BTFSC  x63.7
0B86:  BSF    FF2.7
0B88:  MOVWF  x61
0B8A:  MOVFF  03,262
....................    EP_BDxCNT_O(endpoint) = len; 
0B8E:  MOVF   x5E,W
0B90:  MULLW  08
0B92:  MOVF   FF3,W
0B94:  CLRF   x64
0B96:  MOVWF  x63
0B98:  MOVLW  01
0B9A:  ADDWF  x63,W
0B9C:  MOVWF  01
0B9E:  MOVLW  00
0BA0:  ADDWFC x64,W
0BA2:  MOVWF  03
0BA4:  MOVFF  01,FE9
0BA8:  MOVLW  04
0BAA:  ADDWF  03,W
0BAC:  MOVWF  FEA
0BAE:  MOVFF  261,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0BB2:  BTFSC  x62.0
0BB4:  BSF    x60.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0BB6:  BTFSC  x62.1
0BB8:  BSF    x60.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0BBA:  MOVF   x5E,W
0BBC:  MULLW  08
0BBE:  MOVF   FF3,W
0BC0:  CLRF   x64
0BC2:  MOVWF  FE9
0BC4:  MOVLW  04
0BC6:  ADDWF  x64,W
0BC8:  MOVWF  FEA
0BCA:  MOVFF  260,FEF
.................... } 
0BCE:  MOVLB  0
0BD0:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
0D62:  MOVLB  2
0D64:  MOVF   x5F,W
0D66:  MULLW  08
0D68:  MOVF   FF3,W
0D6A:  CLRF   x61
0D6C:  MOVWF  x60
0D6E:  MOVLW  01
0D70:  ADDWF  x60,W
0D72:  MOVWF  01
0D74:  MOVLW  00
0D76:  ADDWFC x61,W
0D78:  MOVWF  03
0D7A:  MOVFF  01,FE9
0D7E:  MOVLW  04
0D80:  ADDWF  03,W
0D82:  MOVWF  FEA
0D84:  CLRF   03
0D86:  MOVFF  FEF,01
0D8A:  MOVFF  03,02
.................... } 
0D8E:  MOVLB  0
0D90:  GOTO   0DA2 (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0910:  MOVLB  2
0912:  BCF    x5F.0
0914:  BTFSC  x5E.7
0916:  BSF    x5F.0
....................    endpoint &= 0x7F; 
0918:  BCF    x5E.7
....................     
....................    if (direction)  
091A:  BTFSS  x5F.0
091C:  BRA    0940
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
091E:  MOVF   x5E,W
0920:  MULLW  08
0922:  MOVF   FF3,W
0924:  CLRF   x61
0926:  MOVWF  x60
0928:  MOVLW  04
092A:  ADDWF  x60,F
092C:  MOVLW  00
092E:  ADDWFC x61,F
0930:  MOVFF  260,FE9
0934:  MOVLW  04
0936:  ADDWF  x61,W
0938:  MOVWF  FEA
093A:  MOVLW  84
093C:  MOVWF  FEF
....................    } 
....................    else  
093E:  BRA    0954
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
0940:  MOVF   x5E,W
0942:  MULLW  08
0944:  MOVF   FF3,W
0946:  CLRF   x61
0948:  MOVWF  FE9
094A:  MOVLW  04
094C:  ADDWF  x61,W
094E:  MOVWF  FEA
0950:  MOVLW  84
0952:  MOVWF  FEF
....................    } 
.................... } 
0954:  MOVLB  0
0956:  GOTO   09E8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08C8:  MOVLB  2
08CA:  BCF    x5F.0
08CC:  BTFSC  x5E.7
08CE:  BSF    x5F.0
....................    endpoint &= 0x7F; 
08D0:  BCF    x5E.7
....................     
....................    if (direction)  
08D2:  BTFSS  x5F.0
08D4:  BRA    08F8
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
08D6:  MOVF   x5E,W
08D8:  MULLW  08
08DA:  MOVF   FF3,W
08DC:  CLRF   x61
08DE:  MOVWF  x60
08E0:  MOVLW  04
08E2:  ADDWF  x60,F
08E4:  MOVLW  00
08E6:  ADDWFC x61,F
08E8:  MOVFF  260,FE9
08EC:  MOVLW  04
08EE:  ADDWF  x61,W
08F0:  MOVWF  FEA
08F2:  MOVLW  88
08F4:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
08F6:  BRA    090A
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
08F8:  MOVF   x5E,W
08FA:  MULLW  08
08FC:  MOVF   FF3,W
08FE:  CLRF   x61
0900:  MOVWF  FE9
0902:  MOVLW  04
0904:  ADDWF  x61,W
0906:  MOVWF  FEA
0908:  CLRF   FEF
....................    } 
.................... } 
090A:  MOVLB  0
090C:  GOTO   09D8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
095A:  MOVLB  2
095C:  BCF    x5F.0
095E:  BTFSC  x5E.7
0960:  BSF    x5F.0
....................    endpoint &= 0x7F; 
0962:  BCF    x5E.7
....................     
....................    if (direction)  
0964:  BTFSS  x5F.0
0966:  BRA    098A
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0968:  MOVF   x5E,W
096A:  MULLW  08
096C:  MOVF   FF3,W
096E:  CLRF   x62
0970:  MOVWF  x61
0972:  MOVLW  04
0974:  ADDWF  x61,F
0976:  MOVLW  00
0978:  ADDWFC x62,F
097A:  MOVFF  261,FE9
097E:  MOVLW  04
0980:  ADDWF  x62,W
0982:  MOVWF  FEA
0984:  MOVFF  FEF,260
....................    } 
....................    else  
0988:  BRA    099E
....................    { 
....................       st=EP_BDxST_O(endpoint); 
098A:  MOVF   x5E,W
098C:  MULLW  08
098E:  MOVF   FF3,W
0990:  CLRF   x62
0992:  MOVWF  FE9
0994:  MOVLW  04
0996:  ADDWF  x62,W
0998:  MOVWF  FEA
099A:  MOVFF  FEF,260
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
099E:  BTFSS  x60.7
09A0:  BRA    09A6
09A2:  BTFSC  x60.2
09A4:  BRA    09AA
09A6:  MOVLW  00
09A8:  BRA    09AC
09AA:  MOVLW  01
09AC:  MOVWF  01
.................... } 
09AE:  MOVLB  0
09B0:  GOTO   0A00 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
0DC8:  MOVFF  25F,F6E
....................     
....................    if (address)  
0DCC:  MOVLB  2
0DCE:  MOVF   x5F,F
0DD0:  BZ    0DD8
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0DD2:  MOVLW  04
0DD4:  MOVWF  28
....................    } 
....................    else  
0DD6:  BRA    0DDC
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0DD8:  MOVLW  02
0DDA:  MOVWF  28
....................    } 
.................... } 
0DDC:  MOVLB  0
0DDE:  GOTO   0DEC (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
0594:  MOVLB  2
0596:  MOVF   x5E,F
0598:  BNZ   05A6
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
059A:  MOVLW  04
059C:  MOVWF  28
....................       usb_disable_endpoints(); 
059E:  MOVLB  0
05A0:  RCALL  0380
....................    } 
....................    else  
05A2:  BRA    0760
05A4:  MOVLB  2
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
05A6:  MOVLW  05
05A8:  MOVWF  28
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
05AA:  MOVLW  04
05AC:  MOVWF  x61
05AE:  MOVLW  28
05B0:  MOVWF  x60
....................       for (en=1; en<USB_NUM_UEP; en++)  
05B2:  MOVLW  01
05B4:  MOVWF  x5F
05B6:  MOVF   x5F,W
05B8:  SUBLW  0F
05BA:  BTFSS  FD8.0
05BC:  BRA    0760
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
05BE:  MOVFF  25F,267
05C2:  MOVLB  0
05C4:  RCALL  032C
....................          new_uep = 0; 
05C6:  MOVLB  2
05C8:  CLRF   x62
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
05CA:  CLRF   03
05CC:  MOVF   x5F,W
05CE:  MOVFF  FF2,266
05D2:  BCF    FF2.7
05D4:  MOVLB  0
05D6:  RCALL  00DA
05D8:  MOVLB  2
05DA:  BTFSC  x66.7
05DC:  BSF    FF2.7
05DE:  SUBLW  FF
05E0:  BZ    0698
....................          { 
....................             new_uep = 0x04; 
05E2:  MOVLW  04
05E4:  MOVWF  x62
....................             len = usb_ep_rx_size[en]; 
05E6:  BCF    FD8.0
05E8:  RLCF   x5F,W
05EA:  CLRF   03
05EC:  MOVFF  FF2,266
05F0:  BCF    FF2.7
05F2:  MOVLB  0
05F4:  RCALL  012A
05F6:  TBLRD*+
05F8:  MOVFF  FF5,03
05FC:  MOVLB  2
05FE:  BTFSC  x66.7
0600:  BSF    FF2.7
0602:  MOVWF  x63
0604:  MOVFF  03,264
....................             EP_BDxCNT_O(en) = len; 
0608:  MOVF   x5F,W
060A:  MULLW  08
060C:  MOVF   FF3,W
060E:  CLRF   x67
0610:  MOVWF  x66
0612:  MOVLW  01
0614:  ADDWF  x66,W
0616:  MOVWF  01
0618:  MOVLW  00
061A:  ADDWFC x67,W
061C:  MOVWF  03
061E:  MOVFF  01,FE9
0622:  MOVLW  04
0624:  ADDWF  03,W
0626:  MOVWF  FEA
0628:  MOVFF  263,FEF
....................             EP_BDxADR_O(en) = addy; 
062C:  MOVF   x5F,W
062E:  MULLW  08
0630:  MOVF   FF3,W
0632:  CLRF   x67
0634:  MOVWF  x66
0636:  MOVLW  02
0638:  ADDWF  x66,W
063A:  MOVWF  01
063C:  MOVLW  00
063E:  ADDWFC x67,W
0640:  MOVWF  03
0642:  MOVFF  01,FE9
0646:  MOVLW  04
0648:  ADDWF  03,W
064A:  MOVWF  FEA
064C:  MOVFF  261,FEC
0650:  MOVF   FED,F
0652:  MOVFF  260,FEF
....................             addy += usb_ep_rx_size[en]; 
0656:  BCF    FD8.0
0658:  RLCF   x5F,W
065A:  CLRF   03
065C:  MOVFF  FF2,266
0660:  BCF    FF2.7
0662:  MOVLB  0
0664:  RCALL  012A
0666:  TBLRD*+
0668:  MOVFF  FF5,03
066C:  MOVLB  2
066E:  BTFSC  x66.7
0670:  BSF    FF2.7
0672:  ADDWF  x60,F
0674:  MOVF   03,W
0676:  ADDWFC x61,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0678:  MOVLW  88
067A:  MOVWF  x65
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
067C:  BTFSC  x64.0
067E:  BSF    x65.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
0680:  BTFSC  x64.1
0682:  BSF    x65.1
....................             EP_BDxST_O(en) = i; 
0684:  MOVF   x5F,W
0686:  MULLW  08
0688:  MOVF   FF3,W
068A:  CLRF   x67
068C:  MOVWF  FE9
068E:  MOVLW  04
0690:  ADDWF  x67,W
0692:  MOVWF  FEA
0694:  MOVFF  265,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0698:  CLRF   03
069A:  MOVF   x5F,W
069C:  MOVFF  FF2,266
06A0:  BCF    FF2.7
06A2:  MOVLB  0
06A4:  RCALL  00BA
06A6:  MOVLB  2
06A8:  BTFSC  x66.7
06AA:  BSF    FF2.7
06AC:  SUBLW  FF
06AE:  BZ    0726
....................          { 
....................             new_uep |= 0x02; 
06B0:  BSF    x62.1
....................             EP_BDxADR_I(en) = addy; 
06B2:  MOVF   x5F,W
06B4:  MULLW  08
06B6:  MOVF   FF3,W
06B8:  CLRF   x67
06BA:  MOVWF  x66
06BC:  MOVLW  04
06BE:  ADDWF  x66,F
06C0:  MOVLW  00
06C2:  ADDWFC x67,F
06C4:  MOVLW  02
06C6:  ADDWF  x66,W
06C8:  MOVWF  01
06CA:  MOVLW  00
06CC:  ADDWFC x67,W
06CE:  MOVWF  03
06D0:  MOVFF  01,FE9
06D4:  MOVLW  04
06D6:  ADDWF  03,W
06D8:  MOVWF  FEA
06DA:  MOVFF  261,FEC
06DE:  MOVF   FED,F
06E0:  MOVFF  260,FEF
....................             addy += usb_ep_tx_size[en]; 
06E4:  BCF    FD8.0
06E6:  RLCF   x5F,W
06E8:  CLRF   03
06EA:  MOVFF  FF2,266
06EE:  BCF    FF2.7
06F0:  MOVLB  0
06F2:  RCALL  00FA
06F4:  TBLRD*+
06F6:  MOVFF  FF5,03
06FA:  MOVLB  2
06FC:  BTFSC  x66.7
06FE:  BSF    FF2.7
0700:  ADDWF  x60,F
0702:  MOVF   03,W
0704:  ADDWFC x61,F
....................             EP_BDxST_I(en) = 0x40; 
0706:  MOVF   x5F,W
0708:  MULLW  08
070A:  MOVF   FF3,W
070C:  CLRF   x67
070E:  MOVWF  x66
0710:  MOVLW  04
0712:  ADDWF  x66,F
0714:  MOVLW  00
0716:  ADDWFC x67,F
0718:  MOVFF  266,FE9
071C:  MOVLW  04
071E:  ADDWF  x67,W
0720:  MOVWF  FEA
0722:  MOVLW  40
0724:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
0726:  MOVF   x62,W
0728:  SUBLW  06
072A:  BNZ   0730
072C:  MOVLW  0E
072E:  MOVWF  x62
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
0730:  CLRF   03
0732:  MOVF   x5F,W
0734:  MOVFF  FF2,266
0738:  BCF    FF2.7
073A:  MOVLB  0
073C:  RCALL  00BA
073E:  MOVLB  2
0740:  BTFSC  x66.7
0742:  BSF    FF2.7
0744:  SUBLW  01
0746:  BTFSS  FD8.2
0748:  BSF    x62.4
....................           
....................          UEP(en) = new_uep; 
074A:  CLRF   03
074C:  MOVF   x5F,W
074E:  ADDLW  70
0750:  MOVWF  FE9
0752:  MOVLW  0F
0754:  ADDWFC 03,W
0756:  MOVWF  FEA
0758:  MOVFF  262,FEF
....................       } 
075C:  INCF   x5F,F
075E:  BRA    05B6
0760:  MOVLB  0
....................    } 
.................... } 
0762:  GOTO   080A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
032C:  CLRF   03
032E:  MOVLB  2
0330:  MOVF   x67,W
0332:  ADDLW  70
0334:  MOVWF  FE9
0336:  MOVLW  0F
0338:  ADDWFC 03,W
033A:  MOVWF  FEA
033C:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
033E:  MOVFF  267,268
0342:  MOVLB  0
0344:  RCALL  02C8
0346:  MOVF   01,F
0348:  BZ    037C
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
034A:  MOVLB  2
034C:  MOVF   x67,W
034E:  MULLW  08
0350:  MOVF   FF3,W
0352:  CLRF   x69
0354:  MOVWF  FE9
0356:  MOVLW  04
0358:  ADDWF  x69,W
035A:  MOVWF  FEA
035C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
035E:  MOVF   x67,W
0360:  MULLW  08
0362:  MOVF   FF3,W
0364:  CLRF   x69
0366:  MOVWF  x68
0368:  MOVLW  04
036A:  ADDWF  x68,F
036C:  MOVLW  00
036E:  ADDWFC x69,F
0370:  MOVFF  268,FE9
0374:  MOVLW  04
0376:  ADDWF  x69,W
0378:  MOVWF  FEA
037A:  CLRF   FEF
037C:  MOVLB  0
....................    } 
.................... } 
037E:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
0380:  MOVLW  01
0382:  MOVLB  2
0384:  MOVWF  x66
0386:  MOVF   x66,W
0388:  SUBLW  0F
038A:  BNC   039A
....................       usb_disable_endpoint(i); 
038C:  MOVFF  266,267
0390:  MOVLB  0
0392:  RCALL  032C
0394:  MOVLB  2
0396:  INCF   x66,F
0398:  BRA    0386
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
039A:  MOVLB  0
039C:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
105A:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
105C:  MOVF   28,F
105E:  BNZ   1062
1060:  BRA    10DE
....................    if (UIR)  
1062:  MOVF   F68,F
1064:  BZ    10DE
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
1066:  BTFSS  F68.2
1068:  BRA    1072
106A:  BTFSS  F69.2
106C:  BRA    1072
106E:  GOTO   0282
....................  
....................       if (UCON_SUSPND) return; 
1072:  BTFSS  F6D.1
1074:  BRA    1078
1076:  BRA    10DE
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
1078:  BTFSS  F68.5
107A:  BRA    1084
107C:  BTFSS  F69.5
107E:  BRA    1084
1080:  GOTO   02B2
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
1084:  BTFSS  F68.1
1086:  BRA    1090
1088:  BTFSS  F69.1
108A:  BRA    1090
108C:  GOTO   02C0
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
1090:  BTFSS  F68.0
1092:  BRA    109C
1094:  BTFSS  F69.0
1096:  BRA    109C
1098:  GOTO   03EC
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
109C:  BTFSS  F68.4
109E:  BRA    10A8
10A0:  BTFSS  F69.4
10A2:  BRA    10A8
10A4:  GOTO   0416
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
10A8:  BTFSS  F68.6
10AA:  BRA    10B4
10AC:  BTFSS  F69.6
10AE:  BRA    10B4
10B0:  GOTO   0420
....................  
....................       TRNAttempts = 0; 
10B4:  MOVLB  2
10B6:  CLRF   x5B
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
10B8:  BTFSS  F68.3
10BA:  BRA    10D0
10BC:  BTFSS  F69.3
10BE:  BRA    10D0
....................          { 
....................             USTATCopy = U1STAT; 
10C0:  MOVFF  F6C,27
....................             usb_clear_trn(); 
10C4:  MOVLB  0
10C6:  CALL   0004
....................             usb_isr_tok_dne(); 
10CA:  BRA    0EE0
....................          } 
....................          else 
10CC:  BRA    10D2
10CE:  MOVLB  2
....................             break; 
10D0:  BRA    10DC
....................       } while (TRNAttempts++ < 4); 
10D2:  MOVLB  2
10D4:  MOVF   x5B,W
10D6:  INCF   x5B,F
10D8:  SUBLW  03
10DA:  BC    10B8
10DC:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
10DE:  GOTO   0078
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
0420:  BCF    F68.6
.................... } 
0422:  GOTO   10B4 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
03EC:  CLRF   F6A
....................    UIR = 0; 
03EE:  CLRF   F68
....................    UEIE = 0x9F; 
03F0:  MOVLW  9F
03F2:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
03F4:  MOVLW  3D
03F6:  MOVWF  F69
....................  
....................    UADDR = 0; 
03F8:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
03FA:  RCALL  0380
....................     
....................    usb_token_reset(); 
03FC:  RCALL  03C0
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
03FE:  MOVLW  16
0400:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
0402:  BTFSS  F68.3
0404:  BRA    040A
....................       usb_clear_trn(); 
0406:  RCALL  0004
....................    } 
0408:  BRA    0402
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
040A:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
040C:  RCALL  0292
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
040E:  MOVLW  03
0410:  MOVWF  28
.................... } 
0412:  GOTO   109C (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
0292:  MOVLW  08
0294:  MOVLB  4
0296:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0298:  MOVLW  04
029A:  MOVWF  x03
029C:  MOVLW  18
029E:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
02A0:  MOVLW  88
02A2:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
02A4:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
02A6:  MOVLW  04
02A8:  MOVWF  x07
02AA:  MOVLW  20
02AC:  MOVWF  x06
.................... } 
02AE:  MOVLB  0
02B0:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
02C0:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
02C2:  BCF    F68.1
.................... } 
02C4:  GOTO   1090 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0416:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0418:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
041A:  BSF    F6D.1
.................... } 
041C:  GOTO   10A8 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
0282:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
0284:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
0286:  BTFSS  F68.2
0288:  BRA    028E
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
028A:  BCF    F68.2
....................    } 
028C:  BRA    0286
.................... } 
028E:  GOTO   1072 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
02B2:  BTFSS  F70.0
02B4:  BRA    02BA
....................    { 
....................       usb_init_ep0_setup(); 
02B6:  RCALL  0292
....................       bit_clear(UEP(0), 0); 
02B8:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
02BA:  BCF    F68.5
.................... } 
02BC:  GOTO   1084 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0426:  MOVFF  261,29
042A:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
0A1E:  MOVLW  FE
0A20:  MOVWF  29
0A22:  RETLW  00
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
042C:  MOVLW  FF
042E:  MOVWF  29
0430:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0EE0:  RRCF   27,W
0EE2:  MOVLB  2
0EE4:  MOVWF  x5C
0EE6:  RRCF   x5C,F
0EE8:  RRCF   x5C,F
0EEA:  MOVLW  1F
0EEC:  ANDWF  x5C,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0EEE:  MOVF   27,F
0EF0:  BNZ   0F90
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0EF2:  MOVLB  4
0EF4:  MOVF   x00,W
0EF6:  ANDLW  3C
0EF8:  MOVLB  2
0EFA:  MOVWF  x5D
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0EFC:  MOVLW  43
0EFE:  MOVLB  4
0F00:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0F02:  MOVLB  2
0F04:  MOVF   x5D,W
0F06:  SUBLW  34
0F08:  BNZ   0F54
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0F0A:  MOVLB  4
0F0C:  MOVF   x04,W
0F0E:  ANDLW  80
0F10:  BZ    0F14
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0F12:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0F14:  MOVLB  0
0F16:  BRA    0AD4
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0F18:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0F1A:  INCFSZ 29,W
0F1C:  BRA    0F2C
....................             usb_flush_out(0, USB_DTS_STALL); 
0F1E:  MOVLB  2
0F20:  CLRF   x5E
0F22:  MOVLW  03
0F24:  MOVWF  x5F
0F26:  MOVLB  0
0F28:  RCALL  0B08
....................          else  
0F2A:  BRA    0F50
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0F2C:  MOVLB  2
0F2E:  CLRF   x5E
0F30:  MOVLW  02
0F32:  MOVWF  x5F
0F34:  MOVLB  0
0F36:  RCALL  0B08
....................             if (__setup_0_tx_size != 0xFE) 
0F38:  MOVF   29,W
0F3A:  SUBLW  FE
0F3C:  BZ    0F50
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0F3E:  MOVLB  2
0F40:  CLRF   x67
0F42:  CLRF   x69
0F44:  MOVFF  29,268
0F48:  MOVLW  04
0F4A:  MOVWF  x6A
0F4C:  MOVLB  0
0F4E:  RCALL  0C16
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
0F50:  BRA    0F8C
0F52:  MOVLB  2
0F54:  MOVF   x5D,W
0F56:  SUBLW  04
0F58:  BNZ   0F8E
....................       { 
....................          usb_isr_tok_out_dne(0); 
0F5A:  CLRF   x5E
0F5C:  MOVLB  0
0F5E:  RCALL  0DAA
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0F60:  MOVLB  2
0F62:  CLRF   x5E
0F64:  MOVLW  02
0F66:  MOVWF  x5F
0F68:  MOVLB  0
0F6A:  RCALL  0B08
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0F6C:  MOVF   29,W
0F6E:  SUBLW  FE
0F70:  BZ    0F8A
0F72:  INCFSZ 29,W
0F74:  BRA    0F78
0F76:  BRA    0F8A
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0F78:  MOVLB  2
0F7A:  CLRF   x67
0F7C:  CLRF   x69
0F7E:  MOVFF  29,268
0F82:  MOVLW  01
0F84:  MOVWF  x6A
0F86:  MOVLB  0
0F88:  RCALL  0C16
....................          } 
....................       } 
....................       else 
0F8A:  BRA    0F8C
0F8C:  MOVLB  2
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
0F8E:  BRA    1054
0F90:  MOVF   27,W
0F92:  SUBLW  04
0F94:  BNZ   0FC6
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
0F96:  MOVLW  43
0F98:  MOVLB  4
0F9A:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
0F9C:  MOVLW  FF
0F9E:  MOVWF  29
....................       usb_isr_tok_in_dne(0); 
0FA0:  MOVLB  2
0FA2:  CLRF   x5E
0FA4:  MOVLB  0
0FA6:  RCALL  0EAE
....................       if (__setup_0_tx_size!=0xFF) 
0FA8:  INCFSZ 29,W
0FAA:  BRA    0FAE
0FAC:  BRA    0FC2
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0FAE:  MOVLB  2
0FB0:  CLRF   x67
0FB2:  CLRF   x69
0FB4:  MOVFF  29,268
0FB8:  MOVLW  02
0FBA:  MOVWF  x6A
0FBC:  MOVLB  0
0FBE:  RCALL  0C16
....................       else 
0FC0:  BRA    0FC2
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
0FC2:  BRA    1052
0FC4:  MOVLB  2
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0FC6:  BTFSC  27.2
0FC8:  BRA    1004
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
0FCA:  MOVF   x5C,W
0FCC:  MULLW  08
0FCE:  MOVF   FF3,W
0FD0:  CLRF   x5F
0FD2:  MOVWF  01
0FD4:  MOVLW  04
0FD6:  ADDWF  x5F,W
0FD8:  MOVWF  03
0FDA:  MOVF   x5C,W
0FDC:  MULLW  08
0FDE:  MOVF   FF3,W
0FE0:  CLRF   x61
0FE2:  MOVWF  FE9
0FE4:  MOVLW  04
0FE6:  ADDWF  x61,W
0FE8:  MOVWF  FEA
0FEA:  MOVF   FEF,W
0FEC:  ANDLW  43
0FEE:  MOVFF  03,FEA
0FF2:  MOVFF  01,FE9
0FF6:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
0FF8:  MOVFF  25C,25E
0FFC:  MOVLB  0
0FFE:  RCALL  0DAA
....................       } 
....................       else  
1000:  BRA    1052
1002:  MOVLB  2
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
1004:  MOVF   x5C,W
1006:  MULLW  08
1008:  MOVF   FF3,W
100A:  CLRF   x5F
100C:  MOVWF  x5E
100E:  MOVLW  04
1010:  ADDWF  x5E,F
1012:  MOVLW  00
1014:  ADDWFC x5F,F
1016:  MOVFF  25E,01
101A:  MOVLW  04
101C:  ADDWF  x5F,W
101E:  MOVWF  03
1020:  MOVF   x5C,W
1022:  MULLW  08
1024:  MOVF   FF3,W
1026:  CLRF   x61
1028:  MOVWF  x60
102A:  MOVLW  04
102C:  ADDWF  x60,F
102E:  MOVLW  00
1030:  ADDWFC x61,F
1032:  MOVFF  260,FE9
1036:  MOVLW  04
1038:  ADDWF  x61,W
103A:  MOVWF  FEA
103C:  MOVF   FEF,W
103E:  ANDLW  43
1040:  MOVFF  03,FEA
1044:  MOVFF  25E,FE9
1048:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
104A:  MOVFF  25C,25E
104E:  MOVLB  0
1050:  RCALL  0EAE
1052:  MOVLB  2
....................       } 
....................    } 
.................... } 
1054:  MOVLB  0
1056:  GOTO   10CC (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1520:  MOVF   21,W
1522:  MOVWF  01
.................... } 
1524:  GOTO   1532 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
03C0:  MOVLB  2
03C2:  CLRF   x5C
03C4:  MOVF   x5C,W
03C6:  SUBLW  01
03C8:  BNC   03DE
....................       USB_Interface[i] = 0;   //reset each interface to default 
03CA:  CLRF   03
03CC:  MOVF   x5C,W
03CE:  ADDLW  2D
03D0:  MOVWF  FE9
03D2:  MOVLW  00
03D4:  ADDWFC 03,W
03D6:  MOVWF  FEA
03D8:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
03DA:  INCF   x5C,F
03DC:  BRA    03C4
....................    usb_cdc_init(); 
03DE:  MOVLB  0
03E0:  RCALL  039E
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
03E2:  CLRF   21
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
03E4:  MOVLW  01
03E6:  MOVWF  22
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
03E8:  CLRF   20
.................... } 
03EA:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
02C8:  MOVLB  2
02CA:  BCF    x69.0
02CC:  BTFSC  x68.7
02CE:  BSF    x69.0
....................     
....................    endpoint &= 0x7F; 
02D0:  BCF    x68.7
....................     
....................    if (endpoint > 16) 
02D2:  MOVF   x68,W
02D4:  SUBLW  10
02D6:  BC    02DE
....................       return(FALSE); 
02D8:  MOVLW  00
02DA:  MOVWF  01
02DC:  BRA    0328
....................     
....................    if (direction) { //IN 
02DE:  BTFSS  x69.0
02E0:  BRA    0306
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
02E2:  CLRF   03
02E4:  MOVF   x68,W
02E6:  MOVFF  FF2,26A
02EA:  BCF    FF2.7
02EC:  MOVLB  0
02EE:  RCALL  00BA
02F0:  MOVLB  2
02F2:  BTFSC  x6A.7
02F4:  BSF    FF2.7
02F6:  SUBLW  FF
02F8:  BNZ   02FE
02FA:  MOVLW  00
02FC:  BRA    0300
02FE:  MOVLW  01
0300:  MOVWF  01
0302:  BRA    0328
....................    } 
....................    else {   //OUT 
0304:  BRA    0328
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
0306:  CLRF   03
0308:  MOVF   x68,W
030A:  MOVFF  FF2,26A
030E:  BCF    FF2.7
0310:  MOVLB  0
0312:  RCALL  00DA
0314:  MOVLB  2
0316:  BTFSC  x6A.7
0318:  BSF    FF2.7
031A:  SUBLW  FF
031C:  BNZ   0322
031E:  MOVLW  00
0320:  BRA    0324
0322:  MOVLW  01
0324:  MOVWF  01
0326:  BRA    0328
....................    } 
.................... } 
0328:  MOVLB  0
032A:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
0EAE:  MOVLB  2
0EB0:  MOVF   x5E,F
0EB2:  BNZ   0ED0
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0EB4:  DECFSZ 20,W
0EB6:  BRA    0EC2
0EB8:  MOVLB  0
0EBA:  CALL   0432
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0EBE:  BRA    0ECC
0EC0:  MOVLB  2
0EC2:  MOVF   20,W
0EC4:  SUBLW  02
0EC6:  BNZ   0ECE
0EC8:  MOVLB  0
0ECA:  BRA    0DE2
0ECC:  MOVLB  2
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0ECE:  BRA    0EDC
0ED0:  MOVF   x5E,W
0ED2:  SUBLW  02
0ED4:  BNZ   0EDC
....................       usb_isr_tok_in_cdc_data_dne(); 
0ED6:  MOVLB  0
0ED8:  BRA    0EA4
0EDA:  MOVLB  2
....................   } 
....................   #endif 
.................... } 
0EDC:  MOVLB  0
0EDE:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0DAA:  MOVLB  2
0DAC:  MOVF   x5E,F
0DAE:  BNZ   0DB8
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0DB0:  MOVLB  0
0DB2:  BRA    0CF2
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0DB4:  BRA    0DC2
0DB6:  MOVLB  2
0DB8:  MOVF   x5E,W
0DBA:  SUBLW  02
0DBC:  BNZ   0DC4
....................       usb_isr_tok_out_cdc_data_dne(); 
0DBE:  MOVLB  0
0DC0:  BRA    0D94
0DC2:  MOVLB  2
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0DC4:  MOVLB  0
0DC6:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0AD4:  CLRF   20
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0AD6:  MOVLB  4
0AD8:  MOVF   x18,W
0ADA:  ANDLW  7F
0ADC:  XORLW  00
0ADE:  MOVLB  0
0AE0:  BZ    0AF0
0AE2:  XORLW  01
0AE4:  BZ    0AF4
0AE6:  XORLW  03
0AE8:  BZ    0AF8
0AEA:  XORLW  23
0AEC:  BZ    0AFC
0AEE:  BRA    0B00
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0AF0:  BRA    0766
....................          break; 
0AF2:  BRA    0B04
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0AF4:  BRA    081E
....................          break; 
0AF6:  BRA    0B04
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0AF8:  BRA    09B4
....................          break; 
0AFA:  BRA    0B04
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
0AFC:  BRA    0A24
....................          break; 
0AFE:  BRA    0B04
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0B00:  RCALL  042C
....................          break; 
0B02:  BRA    0B04
....................    } 
.................... } 
0B04:  GOTO   0F18 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0766:  MOVLB  4
0768:  MOVF   x19,W
076A:  XORLW  00
076C:  MOVLB  0
076E:  BZ    078A
0770:  XORLW  01
0772:  BZ    079E
0774:  XORLW  02
0776:  BZ    07B8
0778:  XORLW  06
077A:  BZ    07D0
077C:  XORLW  03
077E:  BZ    07E2
0780:  XORLW  0E
0782:  BZ    07E6
0784:  XORLW  01
0786:  BZ    07F6
0788:  BRA    0816
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
078A:  MOVFF  22,420
....................             usb_ep0_tx_buffer[1]=0; 
078E:  MOVLB  4
0790:  CLRF   x21
....................             usb_request_send_response(2); 
0792:  MOVLW  02
0794:  MOVLB  2
0796:  MOVWF  x61
0798:  MOVLB  0
079A:  RCALL  0426
....................             break; 
079C:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
079E:  MOVLB  4
07A0:  DECFSZ x1A,W
07A2:  BRA    07B2
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
07A4:  MOVLW  01
07A6:  ANDWF  22,F
....................                usb_put_0len_0(); 
07A8:  MOVLB  2
07AA:  CLRF   x61
07AC:  MOVLB  0
07AE:  RCALL  0426
....................             } 
....................             else 
07B0:  BRA    07B6
....................                usb_request_stall(); 
07B2:  MOVLB  0
07B4:  RCALL  042C
....................             break; 
07B6:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
07B8:  MOVLB  4
07BA:  DECFSZ x1A,W
07BC:  BRA    07CA
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
07BE:  BSF    22.1
....................                usb_put_0len_0(); 
07C0:  MOVLB  2
07C2:  CLRF   x61
07C4:  MOVLB  0
07C6:  RCALL  0426
....................             } 
....................             else 
07C8:  BRA    07CE
....................                usb_request_stall(); 
07CA:  MOVLB  0
07CC:  RCALL  042C
....................             break; 
07CE:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
07D0:  MOVLW  02
07D2:  MOVWF  20
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
07D4:  MOVFF  41A,2A
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
07D8:  MOVLB  2
07DA:  CLRF   x61
07DC:  MOVLB  0
07DE:  RCALL  0426
....................             break; 
07E0:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
07E2:  BRA    04CC
....................             break; 
07E4:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
07E6:  MOVFF  21,420
....................             usb_request_send_response(1); 
07EA:  MOVLW  01
07EC:  MOVLB  2
07EE:  MOVWF  x61
07F0:  MOVLB  0
07F2:  RCALL  0426
....................             break; 
07F4:  BRA    081A
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
07F6:  MOVLB  4
07F8:  MOVF   x1A,W
07FA:  SUBLW  01
07FC:  BNC   0812
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
07FE:  MOVFF  41A,21
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0802:  MOVFF  41A,25E
0806:  MOVLB  0
0808:  BRA    0594
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
080A:  MOVLB  2
080C:  CLRF   x61
080E:  MOVLB  0
0810:  RCALL  0426
....................             } 
....................             break; 
0812:  MOVLB  0
0814:  BRA    081A
....................  
....................       default: 
....................             usb_request_stall(); 
0816:  RCALL  042C
....................             break; 
0818:  BRA    081A
....................    } 
.................... } 
081A:  GOTO   0B04 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
081E:  MOVFF  21,25E
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
0822:  MOVLB  4
0824:  MOVF   x19,W
0826:  XORLW  00
0828:  MOVLB  0
082A:  BZ    0836
082C:  XORLW  0A
082E:  BZ    0848
0830:  XORLW  01
0832:  BZ    0896
0834:  BRA    08C0
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
0836:  MOVLB  4
0838:  CLRF   x20
....................             usb_ep0_tx_buffer[1]=0; 
083A:  CLRF   x21
....................             usb_request_send_response(2); 
083C:  MOVLW  02
083E:  MOVLB  2
0840:  MOVWF  x61
0842:  MOVLB  0
0844:  RCALL  0426
....................             break; 
0846:  BRA    08C4
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0848:  MOVLB  2
084A:  MOVF   x5E,F
084C:  BZ    0890
084E:  MOVLW  01
0850:  SUBWF  x5E,W
0852:  CLRF   03
0854:  MOVFF  FF2,25F
0858:  BCF    FF2.7
085A:  MOVLB  0
085C:  RCALL  01C0
085E:  MOVLB  2
0860:  BTFSC  x5F.7
0862:  BSF    FF2.7
0864:  MOVWF  01
0866:  MOVLB  4
0868:  SUBWF  x1C,W
086A:  BTFSS  FD8.0
086C:  BRA    0872
086E:  MOVLB  2
0870:  BRA    0890
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
0872:  CLRF   03
0874:  MOVF   x1C,W
0876:  ADDLW  2D
0878:  MOVWF  FE9
087A:  MOVLW  00
087C:  ADDWFC 03,W
087E:  MOVWF  FEA
0880:  MOVFF  FEF,420
....................                usb_request_send_response(1);; //send byte back 
0884:  MOVLW  01
0886:  MOVLB  2
0888:  MOVWF  x61
088A:  MOVLB  0
088C:  RCALL  0426
....................             } 
....................             else 
088E:  BRA    0894
....................                usb_request_stall(); 
0890:  MOVLB  0
0892:  RCALL  042C
....................             break; 
0894:  BRA    08C4
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0896:  MOVLB  2
0898:  MOVF   x5E,F
089A:  BZ    08BA
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
089C:  CLRF   03
089E:  MOVLB  4
08A0:  MOVF   x1C,W
08A2:  ADDLW  2D
08A4:  MOVWF  FE9
08A6:  MOVLW  00
08A8:  ADDWFC 03,W
08AA:  MOVWF  FEA
08AC:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
08B0:  MOVLB  2
08B2:  CLRF   x61
08B4:  MOVLB  0
08B6:  RCALL  0426
....................             } 
....................             else 
08B8:  BRA    08BE
....................                usb_request_stall(); 
08BA:  MOVLB  0
08BC:  RCALL  042C
....................             break; 
08BE:  BRA    08C4
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
08C0:  RCALL  042C
....................             break; 
08C2:  BRA    08C4
....................    } 
.................... } 
08C4:  GOTO   0B04 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
09B4:  MOVFF  41C,268
09B8:  RCALL  02C8
09BA:  MOVF   01,F
09BC:  BZ    0A1A
....................       switch(usb_ep0_rx_buffer[1]) { 
09BE:  MOVLB  4
09C0:  MOVF   x19,W
09C2:  XORLW  01
09C4:  MOVLB  0
09C6:  BZ    09D2
09C8:  XORLW  02
09CA:  BZ    09E2
09CC:  XORLW  03
09CE:  BZ    09F2
09D0:  BRA    0A16
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
09D2:  MOVFF  41C,25E
09D6:  BRA    08C8
....................                usb_put_0len_0(); 
09D8:  MOVLB  2
09DA:  CLRF   x61
09DC:  MOVLB  0
09DE:  RCALL  0426
....................                break; 
09E0:  BRA    0A1A
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
09E2:  MOVFF  41C,25E
09E6:  BRA    0910
....................                      usb_put_0len_0(); 
09E8:  MOVLB  2
09EA:  CLRF   x61
09EC:  MOVLB  0
09EE:  RCALL  0426
....................                      break; 
09F0:  BRA    0A1A
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
09F2:  MOVLB  4
09F4:  CLRF   x20
....................                usb_ep0_tx_buffer[1]=0; 
09F6:  CLRF   x21
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
09F8:  MOVFF  41C,25E
09FC:  MOVLB  0
09FE:  BRA    095A
0A00:  MOVF   01,F
0A02:  BZ    0A0A
....................                   usb_ep0_tx_buffer[0]=1; 
0A04:  MOVLW  01
0A06:  MOVLB  4
0A08:  MOVWF  x20
....................                } 
....................                usb_request_send_response(2); 
0A0A:  MOVLW  02
0A0C:  MOVLB  2
0A0E:  MOVWF  x61
0A10:  MOVLB  0
0A12:  RCALL  0426
....................                break; 
0A14:  BRA    0A1A
....................  
....................          default: 
....................             usb_request_stall(); 
0A16:  RCALL  042C
....................             break; 
0A18:  BRA    0A1A
....................       } 
....................    } 
.................... } 
0A1A:  GOTO   0B04 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
04CC:  CLRF   2B
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
04CE:  CLRF   23
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
04D0:  MOVLB  4
04D2:  MOVF   x1B,W
04D4:  XORLW  01
04D6:  MOVLB  0
04D8:  BZ    04E8
04DA:  XORLW  03
04DC:  BZ    04F2
04DE:  XORLW  01
04E0:  BZ    04F8
04E2:  XORLW  22
04E4:  BZ    052A
04E6:  BRA    0574
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
04E8:  MOVLW  12
04EA:  MOVWF  2C
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
04EC:  MOVLW  03
04EE:  MOVWF  23
....................             break; 
04F0:  BRA    0578
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
04F2:  MOVLW  43
04F4:  MOVWF  2C
....................             break; 
04F6:  BRA    0578
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
04F8:  MOVLW  02
04FA:  MOVWF  23
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
04FC:  CLRF   03
04FE:  MOVLB  4
0500:  MOVF   x1A,W
0502:  ADDLW  24
0504:  MOVWF  FE9
0506:  MOVLW  00
0508:  ADDWFC 03,W
050A:  MOVWF  FEA
050C:  MOVFF  FEF,2B
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
0510:  CLRF   03
0512:  MOVF   2B,W
0514:  MOVFF  FF2,25E
0518:  BCF    FF2.7
051A:  MOVLB  0
051C:  RCALL  0214
051E:  MOVLB  2
0520:  BTFSC  x5E.7
0522:  BSF    FF2.7
0524:  MOVWF  2C
....................             break; 
0526:  MOVLB  0
0528:  BRA    0578
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
052A:  BCF    FD8.0
052C:  MOVLB  4
052E:  RLCF   x1A,W
0530:  CLRF   03
0532:  MOVFF  FF2,25E
0536:  BCF    FF2.7
0538:  MOVLB  0
053A:  RCALL  01D2
053C:  TBLRD*+
053E:  MOVFF  FF5,03
0542:  MOVLB  2
0544:  BTFSC  x5E.7
0546:  BSF    FF2.7
0548:  MOVWF  2B
....................             if (usb_getdesc_ptr!=0xFF) { 
054A:  INCFSZ 2B,W
054C:  BRA    0550
054E:  BRA    056E
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0550:  CLRF   03
0552:  MOVF   2B,W
0554:  MOVFF  FF2,25E
0558:  BCF    FF2.7
055A:  MOVLB  0
055C:  RCALL  016C
055E:  MOVLB  2
0560:  BTFSC  x5E.7
0562:  BSF    FF2.7
0564:  MOVWF  2C
....................                break; 
0566:  MOVLB  0
0568:  BRA    0578
....................             } 
....................             else { 
056A:  BRA    0574
056C:  MOVLB  2
....................                usb_request_stall(); 
056E:  MOVLB  0
0570:  RCALL  042C
....................                return; 
0572:  BRA    0590
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
0574:  RCALL  042C
....................             return; 
0576:  BRA    0590
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0578:  MOVLB  4
057A:  MOVF   x1F,F
057C:  BNZ   0588
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
057E:  MOVF   2C,W
0580:  SUBWF  x1E,W
0582:  BC    0588
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
0584:  MOVFF  41E,2C
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0588:  MOVLW  01
058A:  MOVWF  20
....................    usb_copy_desc_seg_to_ep(); 
058C:  MOVLB  0
058E:  RCALL  0432
.................... } 
0590:  GOTO   081A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0DE2:  CLRF   21
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0DE4:  CLRF   20
....................    usb_set_address(USB_address_pending); 
0DE6:  MOVFF  2A,25F
0DEA:  BRA    0DC8
....................    #endif 
.................... } 
0DEC:  GOTO   0ECC (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0432:  MOVLB  2
0434:  CLRF   x5F
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0436:  MOVF   2C,F
0438:  BZ    04B6
043A:  MOVF   x5F,W
043C:  SUBLW  07
043E:  BNC   04B6
....................       switch(USB_stack_status.getdesc_type) { 
0440:  MOVF   23,W
0442:  XORLW  00
0444:  MOVLB  0
0446:  BZ    0452
0448:  XORLW  02
044A:  BZ    046A
044C:  XORLW  01
044E:  BZ    0482
0450:  BRA    049A
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0452:  CLRF   03
0454:  MOVF   2B,W
0456:  MOVFF  FF2,261
045A:  BCF    FF2.7
045C:  RCALL  016C
045E:  MOVLB  2
0460:  BTFSC  x61.7
0462:  BSF    FF2.7
0464:  MOVWF  x60
....................             break; 
0466:  MOVLB  0
0468:  BRA    049A
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
046A:  CLRF   03
046C:  MOVF   2B,W
046E:  MOVFF  FF2,261
0472:  BCF    FF2.7
0474:  RCALL  0214
0476:  MOVLB  2
0478:  BTFSC  x61.7
047A:  BSF    FF2.7
047C:  MOVWF  x60
....................             break; 
047E:  MOVLB  0
0480:  BRA    049A
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
0482:  CLRF   03
0484:  MOVF   2B,W
0486:  MOVFF  FF2,261
048A:  BCF    FF2.7
048C:  RCALL  01F2
048E:  MOVLB  2
0490:  BTFSC  x61.7
0492:  BSF    FF2.7
0494:  MOVWF  x60
....................             break; 
0496:  MOVLB  0
0498:  BRA    049A
....................       } 
....................       usb_getdesc_ptr++; 
049A:  INCF   2B,F
....................       usb_getdesc_len--; 
049C:  DECF   2C,F
....................       usb_ep0_tx_buffer[i++]=c; 
049E:  MOVLB  2
04A0:  MOVF   x5F,W
04A2:  INCF   x5F,F
04A4:  CLRF   03
04A6:  ADDLW  20
04A8:  MOVWF  FE9
04AA:  MOVLW  04
04AC:  ADDWFC 03,W
04AE:  MOVWF  FEA
04B0:  MOVFF  260,FEF
....................    } 
04B4:  BRA    0436
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
04B6:  MOVF   2C,F
04B8:  BNZ   04C2
04BA:  MOVF   x5F,W
04BC:  SUBLW  08
04BE:  BZ    04C2
....................          USB_stack_status.dev_req = NONE; 
04C0:  CLRF   20
....................    } 
....................  
....................    usb_request_send_response(i); 
04C2:  MOVFF  25F,261
04C6:  MOVLB  0
04C8:  RCALL  0426
.................... } 
04CA:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  unsigned int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... unsigned int8 g_LastCDCDataPacketSize; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
0CF2:  MOVF   x86,W
0CF4:  XORLW  01
0CF6:  BZ    0D02
0CF8:  XORLW  02
0CFA:  BZ    0D24
0CFC:  XORLW  01
0CFE:  BZ    0D32
0D00:  BRA    0D5A
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
0D02:  CLRF   FEA
0D04:  MOVLW  38
0D06:  MOVWF  FE9
0D08:  MOVLW  04
0D0A:  MOVWF  FE2
0D0C:  MOVLW  18
0D0E:  MOVWF  FE1
0D10:  MOVLW  08
0D12:  MOVWF  01
0D14:  MOVFF  FE6,FEE
0D18:  DECFSZ 01,F
0D1A:  BRA    0D14
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
0D1C:  MOVLW  03
0D1E:  MOVWF  x86
....................          usb_request_get_data(); 
0D20:  RCALL  0A1E
....................         #else 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................         #endif 
....................          break; 
0D22:  BRA    0D5E
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
0D24:  MOVLB  2
0D26:  CLRF   x61
0D28:  MOVLB  0
0D2A:  CALL   0426
....................          __usb_cdc_state=0; 
0D2E:  CLRF   x86
....................          break; 
0D30:  BRA    0D5E
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0D32:  CLRF   FEA
0D34:  MOVLW  2F
0D36:  MOVWF  FE9
0D38:  MOVLW  04
0D3A:  MOVWF  FE2
0D3C:  MOVLW  18
0D3E:  MOVWF  FE1
0D40:  MOVLW  07
0D42:  MOVWF  01
0D44:  MOVFF  FE6,FEE
0D48:  DECFSZ 01,F
0D4A:  BRA    0D44
....................          __usb_cdc_state=0; 
0D4C:  CLRF   x86
....................          usb_put_0len_0(); 
0D4E:  MOVLB  2
0D50:  CLRF   x61
0D52:  MOVLB  0
0D54:  CALL   0426
....................          break; 
0D58:  BRA    0D5E
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0D5A:  CLRF   x86
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
0D5C:  BRA    0D5E
....................    } 
.................... } 
0D5E:  GOTO   0DB4 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
0A24:  MOVLB  4
0A26:  DECFSZ x1C,W
0A28:  BRA    0A2C
0A2A:  BRA    0A30
0A2C:  MOVF   x1C,F
0A2E:  BNZ   0ACE
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
0A30:  MOVF   x19,W
0A32:  XORLW  00
0A34:  MOVLB  0
0A36:  BZ    0A4E
0A38:  XORLW  01
0A3A:  BZ    0A56
0A3C:  XORLW  21
0A3E:  BZ    0A78
0A40:  XORLW  01
0A42:  BZ    0A82
0A44:  XORLW  03
0A46:  BZ    0AA8
0A48:  XORLW  01
0A4A:  BZ    0AB6
0A4C:  BRA    0AC8
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
0A4E:  MOVLW  01
0A50:  MOVWF  x86
....................             usb_request_get_data(); 
0A52:  RCALL  0A1E
....................             break; 
0A54:  BRA    0ACC
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
0A56:  MOVLW  04
0A58:  MOVWF  FEA
0A5A:  MOVLW  20
0A5C:  MOVWF  FE9
0A5E:  CLRF   FE2
0A60:  MOVLW  38
0A62:  MOVWF  FE1
0A64:  MOVLW  08
0A66:  MOVWF  01
0A68:  MOVFF  FE6,FEE
0A6C:  DECFSZ 01,F
0A6E:  BRA    0A68
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
0A70:  MOVFF  41E,261
0A74:  RCALL  0426
....................             break; 
0A76:  BRA    0ACC
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
0A78:  MOVLW  02
0A7A:  MOVWF  x86
....................             usb_cdc_got_set_line_coding=TRUE; 
0A7C:  BSF    x83.0
....................             usb_request_get_data(); 
0A7E:  RCALL  0A1E
....................             break; 
0A80:  BRA    0ACC
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0A82:  MOVLW  04
0A84:  MOVWF  FEA
0A86:  MOVLW  20
0A88:  MOVWF  FE9
0A8A:  CLRF   FE2
0A8C:  MOVLW  2F
0A8E:  MOVWF  FE1
0A90:  MOVLW  07
0A92:  MOVWF  01
0A94:  MOVFF  FE6,FEE
0A98:  DECFSZ 01,F
0A9A:  BRA    0A94
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0A9C:  MOVLW  07
0A9E:  MOVLB  2
0AA0:  MOVWF  x61
0AA2:  MOVLB  0
0AA4:  RCALL  0426
....................             break; 
0AA6:  BRA    0ACC
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0AA8:  MOVFF  41A,84
....................             usb_put_0len_0(); 
0AAC:  MOVLB  2
0AAE:  CLRF   x61
0AB0:  MOVLB  0
0AB2:  RCALL  0426
....................             break; 
0AB4:  BRA    0ACC
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0AB6:  MOVFF  41A,37
0ABA:  MOVFF  41B,36
....................             usb_put_0len_0(); 
0ABE:  MOVLB  2
0AC0:  CLRF   x61
0AC2:  MOVLB  0
0AC4:  RCALL  0426
....................             break; 
0AC6:  BRA    0ACC
....................  
....................          default: 
....................             usb_request_stall(); 
0AC8:  RCALL  042C
....................             break; 
0ACA:  BRA    0ACC
0ACC:  MOVLB  4
....................       } 
....................    } 
.................... } 
0ACE:  MOVLB  0
0AD0:  GOTO   0B04 (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
0D94:  BSF    x80.0
....................    usb_cdc_get_buffer_status.index=0; 
0D96:  CLRF   x82
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0D98:  MOVLW  02
0D9A:  MOVLB  2
0D9C:  MOVWF  x5F
0D9E:  MOVLB  0
0DA0:  BRA    0D62
0DA2:  MOVFF  01,81
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
0DA6:  GOTO   0DC2 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    //putc('!'); 
....................    if (usb_cdc_put_buffer_nextin /* || (g_LastCDCDataPacketSize == USB_CDC_DATA_IN_SIZE)*/ )  
*
0EA4:  MOVF   x7F,F
0EA6:  BZ    0EAA
....................    { 
....................       //printf("FL3 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
0EA8:  RCALL  0E82
....................    } 
.................... } 
0EAA:  GOTO   0EDA (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................    usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
*
0E82:  MOVLW  02
0E84:  MOVLB  2
0E86:  MOVWF  x5F
0E88:  CLRF   x61
0E8A:  MOVLW  40
0E8C:  MOVWF  x60
0E8E:  CLRF   x63
0E90:  MOVFF  7F,262
0E94:  MOVLW  02
0E96:  MOVWF  x64
0E98:  MOVLB  0
0E9A:  RCALL  0DF0
....................    g_LastCDCDataPacketSize = usb_cdc_put_buffer_nextin; 
0E9C:  MOVFF  7F,85
....................    usb_cdc_put_buffer_nextin=0; 
0EA0:  CLRF   x7F
.................... } 
0EA2:  RETLW  00
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
039E:  CLRF   32
03A0:  CLRF   31
03A2:  MOVLW  25
03A4:  MOVWF  30
03A6:  MOVLW  80
03A8:  MOVWF  2F
....................    usb_cdc_line_coding.bCharFormat = 0; 
03AA:  CLRF   33
....................    usb_cdc_line_coding.bParityType = 0; 
03AC:  CLRF   34
....................    usb_cdc_line_coding.bDataBits = 8; 
03AE:  MOVLW  08
03B0:  MOVWF  35
....................    (int8)usb_cdc_carrier = 0; 
03B2:  CLRF   x84
....................    usb_cdc_got_set_line_coding = FALSE; 
03B4:  BCF    x83.0
....................    usb_cdc_break = 0; 
03B6:  CLRF   37
03B8:  CLRF   36
....................    usb_cdc_put_buffer_nextin = 0; 
03BA:  CLRF   x7F
....................    usb_cdc_get_buffer_status.got = 0; 
03BC:  BCF    x80.0
.................... } 
03BE:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
1EDC:  BCF    x80.0
1EDE:  CLRF   16
1EE0:  BTFSC  FF2.7
1EE2:  BSF    16.7
1EE4:  BCF    FF2.7
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
1EE6:  MOVLW  02
1EE8:  MOVLB  2
1EEA:  MOVWF  x5E
1EEC:  MOVWF  x5F
1EEE:  MOVLB  0
1EF0:  CALL   0B08
1EF4:  BTFSC  16.7
1EF6:  BSF    FF2.7
.................... } 
1EF8:  GOTO   1F22 (RETURN)
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
1EFC:  BTFSC  x80.0
1EFE:  BRA    1F02
1F00:  BRA    1EFC
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
1F02:  MOVF   x82,W
1F04:  INCF   x82,F
1F06:  CLRF   03
1F08:  ADDLW  30
1F0A:  MOVWF  FE9
1F0C:  MOVLW  04
1F0E:  ADDWFC 03,W
1F10:  MOVWF  FEA
1F12:  MOVFF  FEF,1BB
1F16:  MOVLB  1
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
1F18:  MOVLB  0
1F1A:  MOVF   x81,W
1F1C:  SUBWF  x82,W
1F1E:  BNC   1F22
....................    { 
....................       usb_cdc_get_discard(); 
1F20:  BRA    1EDC
....................    } 
....................  
....................    return(c); 
1F22:  MOVLB  1
1F24:  MOVFF  1BB,01
.................... } 
1F28:  MOVLB  0
1F2A:  RETLW  00
....................  
.................... void usb_cdc_putc_fast(char c)  
.................... { 
....................  #if defined(__PCH__) 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie = INT_GIE; 
*
1568:  MOVLB  2
156A:  BCF    x4A.0
156C:  BTFSC  FF2.7
156E:  BSF    x4A.0
....................    INT_GIE = 0; 
1570:  BCF    FF2.7
....................  #else 
....................    int16 oldSR; 
....................     
....................    oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
1572:  MOVLB  0
1574:  MOVF   x7F,W
1576:  SUBLW  3E
1578:  BC    157E
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
157A:  MOVLW  3E
157C:  MOVWF  x7F
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
157E:  MOVF   x7F,W
1580:  INCF   x7F,F
1582:  CLRF   03
1584:  ADDLW  40
1586:  MOVWF  FE9
1588:  MOVLW  00
158A:  ADDWFC 03,W
158C:  MOVWF  FEA
158E:  MOVFF  249,FEF
....................  
....................    //renable global interrupts 
....................   #if defined(__PCH__) 
....................    INT_GIE = old_gie; 
1592:  BCF    FF2.7
1594:  MOVLB  2
1596:  BTFSC  x4A.0
1598:  BSF    FF2.7
159A:  CLRF   16
159C:  BTFSC  FF2.7
159E:  BSF    16.7
15A0:  BCF    FF2.7
....................   #else 
....................    SR = oldSR; 
....................   #endif 
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free()) { 
15A2:  MOVLW  02
15A4:  MOVWF  x6C
15A6:  MOVLB  0
15A8:  CALL   0BD2
15AC:  BTFSC  16.7
15AE:  BSF    FF2.7
15B0:  MOVF   01,F
15B2:  BZ    15C2
15B4:  CLRF   16
15B6:  BTFSC  FF2.7
15B8:  BSF    16.7
15BA:  BCF    FF2.7
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
15BC:  RCALL  0E82
15BE:  BTFSC  16.7
15C0:  BSF    FF2.7
....................    } 
....................    //putc('*'); 
.................... } 
15C2:  RETLW  00
....................  
.................... void usb_cdc_putc(char c)  
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
*
1F2C:  MOVF   x7F,W
1F2E:  SUBLW  3E
1F30:  BC    1F60
1F32:  CLRF   16
1F34:  BTFSC  FF2.7
1F36:  BSF    16.7
1F38:  BCF    FF2.7
....................       if (usb_cdc_put_buffer_free())  
1F3A:  MOVLW  02
1F3C:  MOVLB  2
1F3E:  MOVWF  x6C
1F40:  MOVLB  0
1F42:  CALL   0BD2
1F46:  BTFSC  16.7
1F48:  BSF    FF2.7
1F4A:  MOVF   01,F
1F4C:  BZ    1F5E
1F4E:  CLRF   16
1F50:  BTFSC  FF2.7
1F52:  BSF    16.7
1F54:  BCF    FF2.7
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
1F56:  CALL   0E82
1F5A:  BTFSC  16.7
1F5C:  BSF    FF2.7
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
1F5E:  BRA    1F2C
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
1F60:  MOVFF  1BB,249
1F64:  CALL   1568
.................... } 
1F68:  RETLW  00
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
.................... //#include "memoria.h" 
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
110C:  MOVLW  08
110E:  MOVWF  01
1110:  MOVLW  04
1112:  MOVWF  00
1114:  DECFSZ 00,F
1116:  BRA    1114
1118:  BCF    F8A.1
111A:  BCF    F93.1
111C:  MOVLW  04
111E:  MOVWF  00
1120:  DECFSZ 00,F
1122:  BRA    1120
1124:  MOVLB  1
1126:  RLCF   xD3,F
1128:  BCF    F8A.0
112A:  BTFSC  FD8.0
112C:  BSF    F93.0
112E:  BTFSS  FD8.0
1130:  BCF    F93.0
1132:  BSF    F93.1
1134:  BTFSS  F81.1
1136:  BRA    1134
1138:  DECFSZ 01,F
113A:  BRA    113E
113C:  BRA    1142
113E:  MOVLB  0
1140:  BRA    1110
1142:  MOVLW  04
1144:  MOVWF  00
1146:  DECFSZ 00,F
1148:  BRA    1146
114A:  BCF    F8A.1
114C:  BCF    F93.1
114E:  NOP   
1150:  BSF    F93.0
1152:  MOVLW  04
1154:  MOVWF  00
1156:  DECFSZ 00,F
1158:  BRA    1156
115A:  MOVLW  04
115C:  MOVWF  00
115E:  DECFSZ 00,F
1160:  BRA    115E
1162:  BSF    F93.1
1164:  BTFSS  F81.1
1166:  BRA    1164
1168:  CLRF   01
116A:  MOVLW  04
116C:  MOVWF  00
116E:  DECFSZ 00,F
1170:  BRA    116E
1172:  BTFSC  F81.0
1174:  BSF    01.0
1176:  BCF    F8A.1
1178:  BCF    F93.1
117A:  BCF    F8A.0
117C:  BCF    F93.0
117E:  MOVLB  0
1180:  RETLW  00
1182:  MOVLW  08
1184:  MOVLB  1
1186:  MOVWF  xD4
1188:  MOVFF  00,1D5
118C:  BSF    F93.0
118E:  MOVLW  04
1190:  MOVWF  00
1192:  DECFSZ 00,F
1194:  BRA    1192
1196:  BSF    F93.1
1198:  BTFSS  F81.1
119A:  BRA    1198
119C:  BTFSC  F81.0
119E:  BSF    FD8.0
11A0:  BTFSS  F81.0
11A2:  BCF    FD8.0
11A4:  RLCF   01,F
11A6:  MOVLW  04
11A8:  MOVWF  00
11AA:  DECFSZ 00,F
11AC:  BRA    11AA
11AE:  BCF    F93.1
11B0:  BCF    F8A.1
11B2:  DECFSZ xD4,F
11B4:  BRA    118C
11B6:  BSF    F93.0
11B8:  MOVLW  04
11BA:  MOVWF  00
11BC:  DECFSZ 00,F
11BE:  BRA    11BC
11C0:  BCF    F8A.0
11C2:  MOVF   xD5,W
11C4:  BTFSS  FD8.2
11C6:  BCF    F93.0
11C8:  NOP   
11CA:  BSF    F93.1
11CC:  BTFSS  F81.1
11CE:  BRA    11CC
11D0:  MOVLW  04
11D2:  MOVWF  00
11D4:  DECFSZ 00,F
11D6:  BRA    11D4
11D8:  BCF    F8A.1
11DA:  BCF    F93.1
11DC:  MOVLW  04
11DE:  MOVWF  00
11E0:  DECFSZ 00,F
11E2:  BRA    11E0
11E4:  BCF    F8A.0
11E6:  BCF    F93.0
11E8:  MOVLB  0
11EA:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_seg = 0x00; 
....................  
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(unsigned int canal, int16 *buffer); 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA_H 
.................... #define CAPTURA_FRECUENCIA_H 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... /* 
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
.................... */ 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... /*struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
.................... */ 
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
.................... //canales de lectura 
.................... #define CCP_CANAL_1 1 
.................... #define CCP_CANAL_2 2 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_8|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
.................... 	Q=-1:   ccp inabilitado 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
.................... int semaforo_ccp = 0; 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... void CP_activar_captura(int canal); 
.................... void CP_desativar_captura(); 
.................... int CP_ocupado(); 
.................... int CP_done(); 
.................... int32 CP_obtener_resultado(); 
....................  
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "configuracion.h" 
.................... #ifndef CONFIGURACION_H 
.................... #define CONFIGURACION_H 
....................  
.................... // opciones de configuracion 
.................... #define CONF_SALIR    '9' 
.................... #define CONF_SET_FECHA  '1' 
.................... #define CONF_GET_FECHA  '2' 
.................... #define CONF_SET_CANAL  '3' 
.................... #define CONF_GET_CANAL  '4' 
.................... #define CONF_SET_DATO   '5' 
.................... #define CONF_GET_DATO   '6' 
....................  
.................... #define CONF_ACK        0x06 
.................... #define CONF_NOACK    0x15 
....................  
.................... //direccion del byte de canales activos y bit de canales 
.................... #define CONF_DIR_CANAl        0x08 
.................... #define CONF_CCP_VEL_BIT    0 
.................... #define CONF_CCP_REV_BIT    1 
.................... #define CONF_CCP_BIT            2 
.................... #define CONF_AD_VEL_BIT        3 
.................... #define CONF_AD_REV_BIT        4 
....................  
.................... // numeracion de sensores 
.................... #define ACC_x        0 
.................... #define ACC_y        1 
.................... #define ACC_z        2 
.................... #define AD_VEL     3 
.................... #define AD_REV        4 
.................... #define CCP_VEl     5 
.................... #define CCP_REV     6 
....................  
....................  
.................... // para el switch de log 
.................... #define LOG_ENABLE    1 
.................... #define LOG_DISABLE    0 
.................... #define LOG_LINE ("\n\r%X:%X:%X:%X:%X:%X:%X:%X:%LX:%LX") 
....................  
.................... // definicion de pines de indicadores 
.................... #define INDICADOR_POWER    PIN_E0 
.................... #define INDICADOR_USB        PIN_E1 
.................... #define INDICADOR_RUN        PIN_E2 
....................  
.................... // esto es para debug 
.................... #ifdef SIMULACION 
....................     #define cout     
....................     #define cin        getc               
.................... #else 
....................     #define cout    usb_cdc_putc_fast, 
....................     #define cin        usb_cdc_getc 
....................     #define putc    usb_cdc_putc 
.................... #endif 
....................  
.................... // definciones utilizadas en el nucleo 
.................... int1 salida = 0; 
.................... byte CONF_CANAL_ACTIVO = 0; 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................     int canal_ccp = CCP_CANAL_1; 
.................... #endif    //CAPTURA_FRECUENCIA_H 
....................  
.................... int myerror = 0; 
.................... int16 lectura = 0; 
.................... char noLog[] = "\n\rno se puede guardar"; 
.................... char testfile[] = "prueba"; 
.................... char buffer_log[39]; 
.................... //int32 resultado = 0; 
.................... struct Log { 
....................     byte dia; 
....................     byte mes; 
....................     byte anio; 
....................     byte hor; 
....................     byte min; 
....................     byte seg; 
....................     int8 sensor; 
....................     int8 no_data; 
....................     int32 value; 
....................     int16 crc; 
.................... } data; 
....................  
.................... void iniciar_perifericos(); 
.................... int sensor_activo(int sensor); 
.................... void modo_configuracion(); 
.................... #endif 
....................  
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
....................  
.................... #ifdef use_rtos 
.................... void activar_tareas(); 
.................... void desactivar_tareas(); 
....................  
....................  
.................... //ifdef MEMORIA_H 
.................... void guardar(){ 
*
15E8:  MOVLB  2
15EA:  CLRF   x45
15EC:  CLRF   x46
....................    unsigned int nBytes = 0, escritos = 0; 
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
15EE:  BSF    F95.2
15F0:  BTFSS  F83.2
15F2:  BRA    1740
....................       sprintf(buffer_log,LOG_LINE, 
....................             DS_dia, DS_mes, DS_anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
15F4:  MOVLB  0
15F6:  CLRF   xF4
15F8:  MOVLW  BE
15FA:  MOVWF  xF3
15FC:  MOVLW  0A
15FE:  MOVLB  2
1600:  MOVWF  x49
1602:  MOVLB  0
1604:  RCALL  1440
1606:  MOVLW  0D
1608:  MOVLB  2
160A:  MOVWF  x49
160C:  MOVLB  0
160E:  RCALL  1440
1610:  MOVFF  88,247
1614:  MOVLW  37
1616:  MOVLB  2
1618:  MOVWF  x48
161A:  MOVLB  0
161C:  RCALL  1460
161E:  MOVLW  3A
1620:  MOVLB  2
1622:  MOVWF  x49
1624:  MOVLB  0
1626:  RCALL  1440
1628:  MOVFF  89,247
162C:  MOVLW  37
162E:  MOVLB  2
1630:  MOVWF  x48
1632:  MOVLB  0
1634:  RCALL  1460
1636:  MOVLW  3A
1638:  MOVLB  2
163A:  MOVWF  x49
163C:  MOVLB  0
163E:  RCALL  1440
1640:  MOVFF  8A,247
1644:  MOVLW  37
1646:  MOVLB  2
1648:  MOVWF  x48
164A:  MOVLB  0
164C:  RCALL  1460
164E:  MOVLW  3A
1650:  MOVLB  2
1652:  MOVWF  x49
1654:  MOVLB  0
1656:  RCALL  1440
1658:  MOVFF  E8,247
165C:  MOVLW  37
165E:  MOVLB  2
1660:  MOVWF  x48
1662:  MOVLB  0
1664:  RCALL  1460
1666:  MOVLW  3A
1668:  MOVLB  2
166A:  MOVWF  x49
166C:  MOVLB  0
166E:  RCALL  1440
1670:  MOVFF  E9,247
1674:  MOVLW  37
1676:  MOVLB  2
1678:  MOVWF  x48
167A:  MOVLB  0
167C:  RCALL  1460
167E:  MOVLW  3A
1680:  MOVLB  2
1682:  MOVWF  x49
1684:  MOVLB  0
1686:  RCALL  1440
1688:  MOVFF  EA,247
168C:  MOVLW  37
168E:  MOVLB  2
1690:  MOVWF  x48
1692:  MOVLB  0
1694:  RCALL  1460
1696:  MOVLW  3A
1698:  MOVLB  2
169A:  MOVWF  x49
169C:  MOVLB  0
169E:  RCALL  1440
16A0:  MOVFF  EB,247
16A4:  MOVLW  37
16A6:  MOVLB  2
16A8:  MOVWF  x48
16AA:  MOVLB  0
16AC:  RCALL  1460
16AE:  MOVLW  3A
16B0:  MOVLB  2
16B2:  MOVWF  x49
16B4:  MOVLB  0
16B6:  RCALL  1440
16B8:  MOVFF  EC,247
16BC:  MOVLW  37
16BE:  MOVLB  2
16C0:  MOVWF  x48
16C2:  MOVLB  0
16C4:  RCALL  1460
16C6:  MOVLW  3A
16C8:  MOVLB  2
16CA:  MOVWF  x49
16CC:  MOVLB  0
16CE:  RCALL  1440
16D0:  MOVFF  F0,247
16D4:  MOVLW  37
16D6:  MOVLB  2
16D8:  MOVWF  x48
16DA:  MOVLB  0
16DC:  RCALL  1460
16DE:  MOVFF  EF,247
16E2:  MOVLW  37
16E4:  MOVLB  2
16E6:  MOVWF  x48
16E8:  MOVLB  0
16EA:  RCALL  1460
16EC:  MOVFF  EE,247
16F0:  MOVLW  37
16F2:  MOVLB  2
16F4:  MOVWF  x48
16F6:  MOVLB  0
16F8:  RCALL  1460
16FA:  MOVFF  ED,247
16FE:  MOVLW  37
1700:  MOVLB  2
1702:  MOVWF  x48
1704:  MOVLB  0
1706:  RCALL  1460
1708:  MOVLW  3A
170A:  MOVLB  2
170C:  MOVWF  x49
170E:  MOVLB  0
1710:  RCALL  1440
1712:  MOVFF  F2,247
1716:  MOVLW  37
1718:  MOVLB  2
171A:  MOVWF  x48
171C:  MOVLB  0
171E:  RCALL  1460
1720:  MOVFF  F1,247
1724:  MOVLW  37
1726:  MOVLB  2
1728:  MOVWF  x48
172A:  MOVLB  0
172C:  RCALL  1460
....................              
....................       #ifdef MEMORIA_H 
....................       nBytes = strlen(buffer_log); 
....................       if((myerror = MEMORIA_open(testfile, FILE_WR)) != 0){ 
....................          printf(usb_cdc_putc_fast,"\n\rMO%d",myerror); 
....................       }else{ 
....................          if( (myerror = MEMORIA_write(nBytes)) != 0 ){ 
....................             printf(usb_cdc_putc_fast,"\n\rMW%d",myerror); 
....................          }else{ 
....................             escritos = MEMORIA_set_data(buffer_log, nBytes); 
....................             printf(usb_cdc_putc_fast,"\n\rMS%d", escritos); 
....................             MEMORIA_close(); 
....................          } 
....................       } 
....................       #endif   //MEMORIA_H 
....................        
....................       if(_debug_usb()){ 
172E:  RCALL  154A
1730:  MOVF   01,F
1732:  BZ    173C
....................          printf(cout buffer_log); 
1734:  CLRF   FEA
1736:  MOVLW  BE
1738:  MOVWF  FE9
173A:  RCALL  15C4
....................       } 
....................    }else{ 
173C:  BRA    1750
173E:  MOVLB  2
....................       if(_debug_usb()){ 
1740:  MOVLB  0
1742:  RCALL  154A
1744:  MOVF   01,F
1746:  BZ    1750
....................          printf(cout nolog); 
1748:  CLRF   FEA
174A:  MOVLW  A1
174C:  MOVWF  FE9
174E:  RCALL  15C4
....................       } 
....................    } 
....................    //if(_debug_usb()){printf(usb_cdc_putc_fast,"%s %u",buffer_log, nBytes);} 
.................... } 
1750:  RETLW  00
....................  
.................... /* 
.................... #else 
.................... void guardar(){ 
....................    if(_debug_usb()){ 
....................       if(input(PIN_LOG) == LOG_ENABLE){ 
....................          sprintf(buffer_log,LOG_LINE, 
....................             data.dia, data.mes, data.anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
....................          printf(cout buffer_log); 
....................       } else { 
....................          printf(cout nolog); 
....................       } 
....................    } 
.................... } 
.................... #endif 
.................... */ 
....................  
.................... #task (rate=500ms, max=5ms) 
.................... void proceso2(){    
....................    salida = (salida)? 0 : 1; 
*
10E2:  BTFSS  x83.1
10E4:  BRA    10EA
10E6:  MOVLW  00
10E8:  BRA    10EC
10EA:  MOVLW  01
10EC:  BCF    x83.1
10EE:  BTFSC  FE8.0
10F0:  BSF    x83.1
....................    if(salida) output_bit(INDICADOR_RUN, 1); 
10F2:  BTFSS  x83.1
10F4:  BRA    10FC
10F6:  BSF    F8D.2
10F8:  BCF    F96.2
....................    else output_bit(INDICADOR_RUN, 0); 
10FA:  BRA    1100
10FC:  BCF    F8D.2
10FE:  BCF    F96.2
....................    //rtos_yield(); 
.................... } 
1100:  MOVLW  E2
1102:  MOVWF  xFA
1104:  MOVLW  10
1106:  MOVWF  xFB
1108:  GOTO   27FA
.................... /* 
.................... #task (rate=100ms, max=50ms) 
.................... void testMemoria(){ 
....................    data.sensor = 255; 
....................    data.value = rand(); 
....................    data.crc = rand(); 
....................    ++data.no_data; 
....................    guardar(); 
....................    rtos_yield(); 
.................... }  
.................... */ 
....................  
.................... #ifdef DS1307_H 
.................... #task (rate=500ms, max=50ms) 
.................... void reloj(){ 
....................    ds1307_get_date(DS_dia, DS_mes, DS_anio, DS_vic); 
....................    ds1307_get_time(DS_hor, DS_min, DS_seg); 
....................    data.dia = DS_dia; 
*
13C8:  MOVFF  88,E5
....................    data.mes = DS_mes; 
13CC:  MOVFF  89,E6
....................    data.anio = DS_anio; 
13D0:  MOVFF  8A,E7
....................    data.hor = DS_hor; 
13D4:  MOVFF  8B,E8
....................    data.min = DS_min; 
13D8:  MOVFF  8C,E9
....................    data.seg = DS_seg; 
13DC:  MOVFF  8D,EA
....................    //rtos_yield(); 
.................... } 
13E0:  MOVLW  16
13E2:  MOVLB  1
13E4:  MOVWF  x09
13E6:  MOVLW  12
13E8:  MOVWF  x0A
13EA:  GOTO   27FA
.................... #endif   //DS1307_H 
....................  
.................... #ifdef ANALOGO_DIGITAL_H 
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea1() 
....................    { 
....................       AD_leer_canal(ACC_x,&lectura); 
*
1752:  MOVLB  2
1754:  CLRF   x2F
1756:  CLRF   x31
1758:  MOVLW  9F
175A:  MOVWF  x30
175C:  MOVLB  0
175E:  RCALL  13EE
....................       data.sensor = ACC_x; 
1760:  CLRF   xEB
....................       data.value = lectura; 
1762:  CLRF   xF0
1764:  CLRF   xEF
1766:  MOVFF  A0,EE
176A:  MOVFF  9F,ED
....................       ++data.no_data; 
176E:  INCF   xEC,F
....................       guardar(); 
1770:  RCALL  15E8
....................       //rtos_yield(); 
....................    } 
1772:  MOVLW  52
1774:  MOVLB  1
1776:  MOVWF  x18
1778:  MOVLW  17
177A:  MOVWF  x19
177C:  GOTO   27FA
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea2(){ 
....................       AD_leer_canal(ACC_y,&lectura); 
1780:  MOVLW  01
1782:  MOVLB  2
1784:  MOVWF  x2F
1786:  CLRF   x31
1788:  MOVLW  9F
178A:  MOVWF  x30
178C:  MOVLB  0
178E:  RCALL  13EE
....................       data.sensor = ACC_y; 
1790:  MOVLW  01
1792:  MOVWF  xEB
....................       data.value = lectura; 
1794:  CLRF   xF0
1796:  CLRF   xEF
1798:  MOVFF  A0,EE
179C:  MOVFF  9F,ED
....................       ++data.no_data; 
17A0:  INCF   xEC,F
....................       guardar(); 
17A2:  RCALL  15E8
....................       //rtos_yield(); 
....................    } 
17A4:  MOVLW  80
17A6:  MOVLB  1
17A8:  MOVWF  x27
17AA:  MOVLW  17
17AC:  MOVWF  x28
17AE:  GOTO   27FA
....................     
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea3(){ 
....................       AD_leer_canal(ACC_z,&lectura); 
17B2:  MOVLW  02
17B4:  MOVLB  2
17B6:  MOVWF  x2F
17B8:  CLRF   x31
17BA:  MOVLW  9F
17BC:  MOVWF  x30
17BE:  MOVLB  0
17C0:  RCALL  13EE
....................       data.sensor = ACC_z; 
17C2:  MOVLW  02
17C4:  MOVWF  xEB
....................       data.value = lectura; 
17C6:  CLRF   xF0
17C8:  CLRF   xEF
17CA:  MOVFF  A0,EE
17CE:  MOVFF  9F,ED
....................       ++data.no_data; 
17D2:  INCF   xEC,F
....................       guardar(); 
17D4:  RCALL  15E8
....................       //rtos_yield(); 
....................    } 
17D6:  MOVLW  B2
17D8:  MOVLB  1
17DA:  MOVWF  x36
17DC:  MOVLW  17
17DE:  MOVWF  x37
17E0:  GOTO   27FA
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_VEL(){ 
....................       if(!sensor_activo(AD_VEL)){return;} 
*
182C:  MOVLW  03
182E:  MOVLB  2
1830:  MOVWF  x45
1832:  MOVLB  0
1834:  RCALL  17E4
1836:  MOVF   01,F
1838:  BNZ   183C
183A:  BRA    1860
....................       AD_leer_canal(AD_VEL,&lectura); 
183C:  MOVLW  03
183E:  MOVLB  2
1840:  MOVWF  x2F
1842:  CLRF   x31
1844:  MOVLW  9F
1846:  MOVWF  x30
1848:  MOVLB  0
184A:  RCALL  13EE
....................       data.sensor = AD_VEL; 
184C:  MOVLW  03
184E:  MOVWF  xEB
....................       data.value = lectura; 
1850:  CLRF   xF0
1852:  CLRF   xEF
1854:  MOVFF  A0,EE
1858:  MOVFF  9F,ED
....................       ++data.no_data; 
185C:  INCF   xEC,F
....................       guardar(); 
185E:  RCALL  15E8
....................       //rtos_yield(); 
....................    } 
1860:  MOVLW  2C
1862:  MOVLB  1
1864:  MOVWF  x45
1866:  MOVLW  18
1868:  MOVWF  x46
186A:  GOTO   27FA
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_REV(){ 
....................       if(!sensor_activo(AD_REV)){return;} 
186E:  MOVLW  04
1870:  MOVLB  2
1872:  MOVWF  x45
1874:  MOVLB  0
1876:  RCALL  17E4
1878:  MOVF   01,F
187A:  BNZ   187E
187C:  BRA    18A2
....................       AD_leer_canal(AD_REV,&lectura); 
187E:  MOVLW  04
1880:  MOVLB  2
1882:  MOVWF  x2F
1884:  CLRF   x31
1886:  MOVLW  9F
1888:  MOVWF  x30
188A:  MOVLB  0
188C:  RCALL  13EE
....................       data.sensor = AD_REV; 
188E:  MOVLW  04
1890:  MOVWF  xEB
....................       data.value = lectura; 
1892:  CLRF   xF0
1894:  CLRF   xEF
1896:  MOVFF  A0,EE
189A:  MOVFF  9F,ED
....................       ++data.no_data; 
189E:  INCF   xEC,F
....................       guardar(); 
18A0:  RCALL  15E8
....................       //rtos_yield(); 
....................    } 
18A2:  MOVLW  6E
18A4:  MOVLB  1
18A6:  MOVWF  x54
18A8:  MOVLW  18
18AA:  MOVWF  x55
18AC:  GOTO   27FA
.................... #endif   //ANALOGO_DIGITAL_H 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................    #task (rate=850ms, max=50ms) 
....................    void rpm(){ 
....................       // agregar una condicion para comprobar que esta tarea este abilitada para 
....................       // ejecutarse 
....................       if(!(sensor_activo(CCP_VEL)||sensor_activo(CCP_REV))){return;} 
*
198C:  MOVLW  05
198E:  MOVLB  2
1990:  MOVWF  x45
1992:  MOVLB  0
1994:  RCALL  17E4
1996:  MOVF   01,F
1998:  BNZ   19AA
199A:  MOVLW  06
199C:  MOVLB  2
199E:  MOVWF  x45
19A0:  MOVLB  0
19A2:  RCALL  17E4
19A4:  MOVF   01,F
19A6:  BNZ   19AA
19A8:  BRA    1A1E
....................        
....................       if(!CP_ocupado()){ 
19AA:  BRA    18B0
19AC:  MOVF   01,F
19AE:  BNZ   19F0
....................          desactivar_tareas(); 
19B0:  BRA    18C0
....................          if(canal_ccp == CCP_CANAL_1){ 
19B2:  DECFSZ x9D,W
19B4:  BRA    19CE
....................             canal_ccp = (sensor_activo(CCP_VEL))? CCP_CANAL_2 : CCP_CANAL_1; 
19B6:  MOVLW  05
19B8:  MOVLB  2
19BA:  MOVWF  x45
19BC:  MOVLB  0
19BE:  RCALL  17E4
19C0:  MOVF   01,F
19C2:  BZ    19C8
19C4:  MOVLW  02
19C6:  BRA    19CA
19C8:  MOVLW  01
19CA:  MOVWF  x9D
....................          }else   if(canal_ccp == CCP_CANAL_2){ 
19CC:  BRA    19EA
19CE:  MOVF   x9D,W
19D0:  SUBLW  02
19D2:  BNZ   19EA
....................             canal_ccp = (sensor_activo(CCP_REV))? CCP_CANAL_1 : CCP_CANAL_2; 
19D4:  MOVLW  06
19D6:  MOVLB  2
19D8:  MOVWF  x45
19DA:  MOVLB  0
19DC:  RCALL  17E4
19DE:  MOVF   01,F
19E0:  BZ    19E6
19E2:  MOVLW  01
19E4:  BRA    19E8
19E6:  MOVLW  02
19E8:  MOVWF  x9D
....................          } 
....................           
....................          //canal_ccp = (canal_ccp == CCP_CANAL_1)? CCP_CANAL_2 : CCP_CANAL_1; 
....................          CP_activar_captura(canal_ccp); 
19EA:  MOVFF  9D,245
19EE:  BRA    18DA
....................       } 
....................       //rtos_await(Q_CCP == 2);                        
....................       if(!CP_done()){ 
19F0:  BRA    1914
19F2:  MOVF   01,F
19F4:  BNZ   19F8
....................          //rtos_yield(); 
....................          return; 
19F6:  BRA    1A1E
....................       }   
....................       data.value = CP_obtener_resultado(); 
19F8:  BRA    1926
19FA:  MOVFF  03,F0
19FE:  MOVFF  02,EF
1A02:  MOVFF  01,EE
1A06:  MOVFF  00,ED
....................       CP_desativar_captura(); 
1A0A:  BRA    1942
....................       data.sensor = (canal_ccp == CCP_CANAL_1)? CCP_REV: CCP_VEL; 
1A0C:  DECFSZ x9D,W
1A0E:  BRA    1A14
1A10:  MOVLW  06
1A12:  BRA    1A16
1A14:  MOVLW  05
1A16:  MOVWF  xEB
....................       data.no_data++; 
1A18:  INCF   xEC,F
....................       guardar(); 
1A1A:  RCALL  15E8
....................       activar_tareas(); 
1A1C:  BRA    1972
....................       //rtos_yield(); 
....................    } 
1A1E:  MOVLW  8C
1A20:  MOVLB  1
1A22:  MOVWF  x63
1A24:  MOVLW  19
1A26:  MOVWF  x64
1A28:  GOTO   27FA
.................... #endif   //CAPTURA_FRECUENCIA_H 
....................  
.................... void activar_tareas(){ 
....................    rtos_enable(reloj); 
*
1972:  MOVLB  1
1974:  BCF    x04.7
....................    rtos_enable(proceso2); 
1976:  MOVLB  0
1978:  BCF    xF5.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_enable(Tarea1); 
197A:  MOVLB  1
197C:  BCF    x13.7
....................    rtos_enable(Tarea2); 
197E:  BCF    x22.7
....................    rtos_enable(Tarea3); 
1980:  BCF    x31.7
....................    rtos_enable(leer_AD_REV); 
1982:  BCF    x4F.7
....................    rtos_enable(leer_AD_VEL); 
1984:  BCF    x40.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
1986:  MOVLB  0
1988:  GOTO   1A1E (RETURN)
....................  
.................... void desactivar_tareas(){ 
....................    rtos_disable(reloj); 
*
18C0:  MOVLB  1
18C2:  BSF    x04.7
....................    rtos_disable(proceso2); 
18C4:  MOVLB  0
18C6:  BSF    xF5.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_disable(Tarea1); 
18C8:  MOVLB  1
18CA:  BSF    x13.7
....................    rtos_disable(Tarea2); 
18CC:  BSF    x22.7
....................    rtos_disable(Tarea3); 
18CE:  BSF    x31.7
....................    rtos_disable(leer_AD_REV); 
18D0:  BSF    x4F.7
....................    rtos_disable(leer_AD_VEL); 
18D2:  BSF    x40.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
18D4:  MOVLB  0
18D6:  GOTO   19B2 (RETURN)
....................  
.................... #endif   //use_rtos 
....................  
.................... //#include "test.c"   // comentar esto en la aplicacion final 
....................  
.................... /*======================= configuracon de dispositivos =======================*/ 
.................... void setup_devices(){ 
....................    iniciar_perifericos(); 
*
1E84:  BRA    1E2E
....................     
....................    setup_psp(PSP_DISABLED); 
1E86:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
1E88:  BCF    FD1.0
....................    setup_spi(SPI_SS_DISABLED); 
1E8A:  BCF    FC6.5
1E8C:  BCF    F94.7
1E8E:  BSF    F93.0
1E90:  BCF    F93.1
1E92:  MOVLW  01
1E94:  MOVWF  FC6
1E96:  MOVLW  00
1E98:  MOVWF  FC7
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
1E9A:  MOVLW  88
1E9C:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
1E9E:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
1EA0:  MOVLW  00
1EA2:  MOVWF  FCA
1EA4:  MOVLW  00
1EA6:  MOVWF  FCB
....................    #ifndef CAPTURA_FRECUENCIA_H 
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    setup_ccp1(CCP_OFF); 
....................    #endif 
....................    setup_comparator(NC_NC_NC_NC); 
1EA8:  MOVLW  07
1EAA:  MOVWF  FB4
1EAC:  MOVF   F92,W
1EAE:  MOVWF  F92
1EB0:  MOVLW  0D
1EB2:  MOVWF  00
1EB4:  DECFSZ 00,F
1EB6:  BRA    1EB4
1EB8:  MOVF   FB4,W
1EBA:  BCF    FA1.6
....................    setup_vref(FALSE); 
1EBC:  CLRF   FB5
....................     
....................    /*===================para los indicadores========================*/ 
....................    set_tris_e(0x00); 
1EBE:  MOVLW  00
1EC0:  MOVWF  F96
....................    set_tris_b(0x00); 
1EC2:  MOVWF  F93
....................    set_tris_c(CONFIG_PORT_C);      //configuracion para el modulo de memoria y CCP. mirar Nucleo.h 
1EC4:  MOVLW  83
1EC6:  MOVWF  F94
....................    set_tris_d(CONFIG_PORT_D); 
1EC8:  MOVLW  4E
1ECA:  MOVWF  F95
....................    output_bit(INDICADOR_USB, 0); 
1ECC:  BCF    F8D.1
1ECE:  BCF    F96.1
....................    output_bit(INDICADOR_POWER, 1); 
1ED0:  BSF    F8D.0
1ED2:  BCF    F96.0
....................    output_bit(INDICADOR_RUN, 1); 
1ED4:  BSF    F8D.2
1ED6:  BCF    F96.2
....................    //output_low(SPI_SCL); 
....................    //output_high(SPI_SS); 
....................    //output_low(SPI_MOSI); 
....................    //output_high(SPI_MISO); 
....................    //delay_ms(3000); 
....................     
....................     
....................    return; 
.................... } 
1ED8:  GOTO   2632 (RETURN)
....................  
.................... /*=========================================================================== 
.................... ||                               MAIN                                        || 
.................... =============================================================================*/ 
.................... void main(void) { 
*
2450:  CLRF   FF8
2452:  BCF    FD0.7
2454:  BSF    07.7
2456:  CLRF   FEA
2458:  CLRF   FE9
245A:  CLRF   28
245C:  CLRF   2C
245E:  CLRF   x7F
2460:  CLRF   x86
2462:  CLRF   x87
2464:  CLRF   x88
2466:  CLRF   x89
2468:  CLRF   x8A
246A:  CLRF   x8B
246C:  CLRF   x8C
246E:  CLRF   x8D
2470:  MOVLW  FD
2472:  MOVWF  x8E
2474:  MOVLW  05
2476:  MOVWF  x8F
2478:  MOVWF  x90
247A:  MOVLW  FF
247C:  MOVWF  x91
247E:  CLRF   x92
2480:  CLRF   x96
2482:  CLRF   x95
2484:  CLRF   x94
2486:  CLRF   x93
2488:  CLRF   x9A
248A:  CLRF   x99
248C:  CLRF   x98
248E:  CLRF   x97
2490:  CLRF   x9B
2492:  BCF    x83.1
2494:  CLRF   x9C
2496:  MOVLW  01
2498:  MOVWF  x9D
249A:  CLRF   x9E
249C:  CLRF   xA0
249E:  CLRF   x9F
24A0:  MOVLB  1
24A2:  CLRF   x6D
24A4:  MOVF   FC1,W
24A6:  ANDLW  C0
24A8:  IORLW  0F
24AA:  MOVWF  FC1
24AC:  MOVLW  07
24AE:  MOVWF  FB4
24B0:  MOVLW  03
24B2:  MOVWF  18
24B4:  CLRF   19
24B6:  CLRF   1A
24B8:  CLRF   1B
24BA:  CLRF   24
24BC:  MOVLW  04
24BE:  MOVWF  25
24C0:  MOVLW  0C
24C2:  MOVWF  26
24C4:  MOVLW  0A
24C6:  MOVLB  0
24C8:  MOVWF  xA1
24CA:  MOVLW  0D
24CC:  MOVWF  xA2
24CE:  MOVLW  6E
24D0:  MOVWF  xA3
24D2:  MOVLW  6F
24D4:  MOVWF  xA4
24D6:  MOVLW  20
24D8:  MOVWF  xA5
24DA:  MOVLW  73
24DC:  MOVWF  xA6
24DE:  MOVLW  65
24E0:  MOVWF  xA7
24E2:  MOVLW  20
24E4:  MOVWF  xA8
24E6:  MOVLW  70
24E8:  MOVWF  xA9
24EA:  MOVLW  75
24EC:  MOVWF  xAA
24EE:  MOVLW  65
24F0:  MOVWF  xAB
24F2:  MOVLW  64
24F4:  MOVWF  xAC
24F6:  MOVLW  65
24F8:  MOVWF  xAD
24FA:  MOVLW  20
24FC:  MOVWF  xAE
24FE:  MOVLW  67
2500:  MOVWF  xAF
2502:  MOVLW  75
2504:  MOVWF  xB0
2506:  MOVLW  61
2508:  MOVWF  xB1
250A:  MOVLW  72
250C:  MOVWF  xB2
250E:  MOVLW  64
2510:  MOVWF  xB3
2512:  MOVLW  61
2514:  MOVWF  xB4
2516:  MOVLW  72
2518:  MOVWF  xB5
251A:  CLRF   xB6
251C:  MOVLW  70
251E:  MOVWF  xB7
2520:  MOVLW  72
2522:  MOVWF  xB8
2524:  MOVLW  75
2526:  MOVWF  xB9
2528:  MOVLW  65
252A:  MOVWF  xBA
252C:  MOVLW  62
252E:  MOVWF  xBB
2530:  MOVLW  61
2532:  MOVWF  xBC
2534:  CLRF   xBD
2536:  CLRF   xF3
2538:  CLRF   xF4
253A:  MOVLW  4C
253C:  MOVLB  1
253E:  MOVWF  x6E
2540:  MOVLW  75
2542:  MOVWF  x6F
2544:  MOVLW  6E
2546:  MOVWF  x70
2548:  MOVLW  65
254A:  MOVWF  x71
254C:  MOVLW  73
254E:  MOVWF  x72
2550:  CLRF   x73
2552:  CLRF   x74
2554:  CLRF   x75
2556:  CLRF   x76
2558:  CLRF   x77
255A:  CLRF   x78
255C:  MOVLW  4D
255E:  MOVWF  x79
2560:  MOVLW  61
2562:  MOVWF  x7A
2564:  MOVLW  72
2566:  MOVWF  x7B
2568:  MOVLW  74
256A:  MOVWF  x7C
256C:  MOVLW  65
256E:  MOVWF  x7D
2570:  MOVLW  73
2572:  MOVWF  x7E
2574:  CLRF   x7F
2576:  CLRF   x80
2578:  CLRF   x81
257A:  CLRF   x82
257C:  CLRF   x83
257E:  MOVLW  4D
2580:  MOVWF  x84
2582:  MOVLW  69
2584:  MOVWF  x85
2586:  MOVLW  E9
2588:  MOVWF  x86
258A:  MOVLW  72
258C:  MOVWF  x87
258E:  MOVLW  63
2590:  MOVWF  x88
2592:  MOVLW  6F
2594:  MOVWF  x89
2596:  MOVLW  6C
2598:  MOVWF  x8A
259A:  MOVLW  65
259C:  MOVWF  x8B
259E:  MOVLW  73
25A0:  MOVWF  x8C
25A2:  CLRF   x8D
25A4:  CLRF   x8E
25A6:  MOVLW  4A
25A8:  MOVWF  x8F
25AA:  MOVLW  75
25AC:  MOVWF  x90
25AE:  MOVLW  65
25B0:  MOVWF  x91
25B2:  MOVLW  76
25B4:  MOVWF  x92
25B6:  MOVLW  65
25B8:  MOVWF  x93
25BA:  MOVLW  73
25BC:  MOVWF  x94
25BE:  CLRF   x95
25C0:  CLRF   x96
25C2:  CLRF   x97
25C4:  CLRF   x98
25C6:  CLRF   x99
25C8:  MOVLW  56
25CA:  MOVWF  x9A
25CC:  MOVLW  69
25CE:  MOVWF  x9B
25D0:  MOVLW  65
25D2:  MOVWF  x9C
25D4:  MOVLW  72
25D6:  MOVWF  x9D
25D8:  MOVLW  6E
25DA:  MOVWF  x9E
25DC:  MOVLW  65
25DE:  MOVWF  x9F
25E0:  MOVLW  73
25E2:  MOVWF  xA0
25E4:  CLRF   xA1
25E6:  CLRF   xA2
25E8:  CLRF   xA3
25EA:  CLRF   xA4
25EC:  MOVLW  53
25EE:  MOVWF  xA5
25F0:  MOVLW  E1
25F2:  MOVWF  xA6
25F4:  MOVLW  62
25F6:  MOVWF  xA7
25F8:  MOVLW  61
25FA:  MOVWF  xA8
25FC:  MOVLW  64
25FE:  MOVWF  xA9
2600:  MOVLW  6F
2602:  MOVWF  xAA
2604:  CLRF   xAB
2606:  CLRF   xAC
2608:  CLRF   xAD
260A:  CLRF   xAE
260C:  CLRF   xAF
260E:  MOVLW  44
2610:  MOVWF  xB0
2612:  MOVLW  6F
2614:  MOVWF  xB1
2616:  MOVLW  6D
2618:  MOVWF  xB2
261A:  MOVLW  69
261C:  MOVWF  xB3
261E:  MOVLW  6E
2620:  MOVWF  xB4
2622:  MOVLW  67
2624:  MOVWF  xB5
2626:  MOVLW  6F
2628:  MOVWF  xB6
262A:  CLRF   xB7
262C:  CLRF   xB8
....................    setup_devices(); 
262E:  MOVLB  0
2630:  BRA    1E84
....................    #ifdef use_rtos 
....................    _debug_usb(); 
2632:  CALL   154A
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
2636:  BSF    F95.2
2638:  BTFSS  F83.2
263A:  BRA    2640
....................       modo_configuracion();   // si esta el log activo entra en modo configuracion 
263C:  BRA    20D2
....................    }else{ 
263E:  BRA    28B6
....................       rtos_run(); //A partir de aqu comenzar la ejecucin de las tareas 
2640:  CLRF   xF5
2642:  CLRF   xF7
2644:  MOVLW  0A
2646:  MOVWF  xF6
2648:  CLRF   xF9
264A:  CLRF   xF8
264C:  CLRF   xFF
264E:  CLRF   xFE
2650:  CLRF   xFD
2652:  CLRF   xFC
2654:  MOVLW  FF
2656:  MOVLB  1
2658:  MOVWF  x01
265A:  MOVWF  x00
265C:  CLRF   x03
265E:  CLRF   x02
2660:  MOVLW  E2
2662:  MOVLB  0
2664:  MOVWF  xFA
2666:  MOVLW  10
2668:  MOVWF  xFB
266A:  MOVLB  1
266C:  CLRF   x04
266E:  CLRF   x06
2670:  MOVLW  0A
2672:  MOVWF  x05
2674:  CLRF   x08
2676:  CLRF   x07
2678:  CLRF   x0E
267A:  CLRF   x0D
267C:  CLRF   x0C
267E:  CLRF   x0B
2680:  MOVLW  FF
2682:  MOVWF  x10
2684:  MOVWF  x0F
2686:  CLRF   x12
2688:  CLRF   x11
268A:  MOVLW  16
268C:  MOVWF  x09
268E:  MOVLW  12
2690:  MOVWF  x0A
2692:  CLRF   x13
2694:  CLRF   x15
2696:  MOVLW  06
2698:  MOVWF  x14
269A:  CLRF   x17
269C:  CLRF   x16
269E:  CLRF   x1D
26A0:  CLRF   x1C
26A2:  CLRF   x1B
26A4:  CLRF   x1A
26A6:  MOVLW  FF
26A8:  MOVWF  x1F
26AA:  MOVWF  x1E
26AC:  CLRF   x21
26AE:  CLRF   x20
26B0:  MOVLW  52
26B2:  MOVWF  x18
26B4:  MOVLW  17
26B6:  MOVWF  x19
26B8:  CLRF   x22
26BA:  CLRF   x24
26BC:  MOVLW  06
26BE:  MOVWF  x23
26C0:  CLRF   x26
26C2:  CLRF   x25
26C4:  CLRF   x2C
26C6:  CLRF   x2B
26C8:  CLRF   x2A
26CA:  CLRF   x29
26CC:  MOVLW  FF
26CE:  MOVWF  x2E
26D0:  MOVWF  x2D
26D2:  CLRF   x30
26D4:  CLRF   x2F
26D6:  MOVLW  80
26D8:  MOVWF  x27
26DA:  MOVLW  17
26DC:  MOVWF  x28
26DE:  CLRF   x31
26E0:  CLRF   x33
26E2:  MOVLW  06
26E4:  MOVWF  x32
26E6:  CLRF   x35
26E8:  CLRF   x34
26EA:  CLRF   x3B
26EC:  CLRF   x3A
26EE:  CLRF   x39
26F0:  CLRF   x38
26F2:  MOVLW  FF
26F4:  MOVWF  x3D
26F6:  MOVWF  x3C
26F8:  CLRF   x3F
26FA:  CLRF   x3E
26FC:  MOVLW  B2
26FE:  MOVWF  x36
2700:  MOVLW  17
2702:  MOVWF  x37
2704:  CLRF   x40
2706:  CLRF   x42
2708:  MOVLW  09
270A:  MOVWF  x41
270C:  CLRF   x44
270E:  CLRF   x43
2710:  CLRF   x4A
2712:  CLRF   x49
2714:  CLRF   x48
2716:  CLRF   x47
2718:  MOVLW  FF
271A:  MOVWF  x4C
271C:  MOVWF  x4B
271E:  CLRF   x4E
2720:  CLRF   x4D
2722:  MOVLW  2C
2724:  MOVWF  x45
2726:  MOVLW  18
2728:  MOVWF  x46
272A:  CLRF   x4F
272C:  CLRF   x51
272E:  MOVLW  09
2730:  MOVWF  x50
2732:  CLRF   x53
2734:  CLRF   x52
2736:  CLRF   x59
2738:  CLRF   x58
273A:  CLRF   x57
273C:  CLRF   x56
273E:  MOVLW  FF
2740:  MOVWF  x5B
2742:  MOVWF  x5A
2744:  CLRF   x5D
2746:  CLRF   x5C
2748:  MOVLW  6E
274A:  MOVWF  x54
274C:  MOVLW  18
274E:  MOVWF  x55
2750:  CLRF   x5E
2752:  CLRF   x60
2754:  MOVLW  11
2756:  MOVWF  x5F
2758:  CLRF   x62
275A:  CLRF   x61
275C:  CLRF   x68
275E:  CLRF   x67
2760:  CLRF   x66
2762:  CLRF   x65
2764:  MOVLW  FF
2766:  MOVWF  x6A
2768:  MOVWF  x69
276A:  CLRF   x6C
276C:  CLRF   x6B
276E:  MOVLW  8C
2770:  MOVWF  x63
2772:  MOVLW  19
2774:  MOVWF  x64
2776:  CLRF   17
2778:  MOVLW  81
277A:  MOVWF  FD5
277C:  MOVLW  0B
277E:  MOVWF  FD7
2780:  MOVLW  DC
2782:  MOVWF  FD6
2784:  BCF    FF2.2
2786:  MOVLW  81
2788:  MOVWF  FD5
278A:  MOVLW  0B
278C:  MOVWF  FD7
278E:  MOVLW  DC
2790:  MOVWF  FD6
2792:  BCF    FF2.2
2794:  CLRF   19
2796:  MOVLW  08
2798:  MOVWF  18
279A:  BCF    FD8.0
279C:  RLCF   17,W
279E:  MOVWF  00
27A0:  MOVLB  0
27A2:  CALL   0258
27A6:  MOVWF  02
27A8:  MOVLW  01
27AA:  ADDWF  00,W
27AC:  CALL   0258
27B0:  MOVWF  03
27B2:  MOVFF  03,FEA
27B6:  MOVFF  02,FE9
27BA:  MOVFF  FEF,02
27BE:  INCF   FE9,F
27C0:  MOVFF  FEF,00
27C4:  MOVFF  FEC,01
27C8:  INCF   FEC,F
27CA:  MOVFF  FEF,03
27CE:  BNZ   27D4
27D0:  INCF   FEC,F
27D2:  MOVF   FED,F
27D4:  MOVF   FEC,W
27D6:  SUBWF  01,W
27D8:  BNZ   2892
27DA:  MOVF   00,W
27DC:  SUBWF  03,W
27DE:  BNZ   2892
27E0:  MOVF   FED,F
27E2:  MOVF   FED,F
27E4:  CLRF   FEE
27E6:  CLRF   FEE
27E8:  BTFSC  02.7
27EA:  BRA    2892
27EC:  MOVF   FEC,F
27EE:  MOVFF  FEC,FFA
27F2:  MOVF   FED,F
27F4:  MOVFF  FEF,FE8
27F8:  MOVWF  FF9
27FA:  MOVLB  0
27FC:  BCF    FD8.0
27FE:  RLCF   17,W
2800:  MOVWF  00
2802:  CALL   0258
2806:  MOVWF  02
2808:  MOVLW  01
280A:  ADDWF  00,W
280C:  CALL   0258
2810:  MOVWF  03
2812:  MOVFF  03,FEA
2816:  MOVFF  02,FE9
281A:  BTFSS  FF2.2
281C:  BRA    2820
281E:  BSF    FEF.4
2820:  MOVLW  07
2822:  ADDWF  FE9,F
2824:  MOVLW  00
2826:  ADDWFC FEA,F
2828:  MOVF   FD6,W
282A:  MOVFF  FD7,03
282E:  ADDLW  24
2830:  MOVWF  01
2832:  MOVLW  0B
2834:  SUBWFB 03,W
2836:  MOVWF  02
2838:  MOVF   01,W
283A:  ADDWF  FEF,F
283C:  MOVF   02,W
283E:  ADDWFC FEC,W
2840:  MOVWF  FEF
2842:  MOVLW  00
2844:  ADDWFC FEC,W
2846:  MOVWF  FEF
2848:  MOVLW  00
284A:  ADDWFC FEC,W
284C:  MOVWF  FEF
284E:  MOVF   FED,F
2850:  MOVF   FED,F
2852:  MOVF   FED,F
2854:  MOVF   FEC,W
2856:  MOVF   FEC,W
2858:  MOVF   FEC,W
285A:  MOVF   FEC,W
285C:  MOVF   02,W
285E:  SUBWF  FEC,W
2860:  BNC   2876
2862:  BNZ   286C
2864:  MOVF   FED,F
2866:  MOVF   01,W
2868:  SUBWF  FEE,W
286A:  BNC   2876
286C:  MOVF   FED,F
286E:  MOVF   01,W
2870:  MOVWF  FEF
2872:  MOVF   02,W
2874:  MOVWF  FEC
2876:  MOVF   FEE,F
2878:  MOVF   FEC,W
287A:  SUBWF  02,W
287C:  BNC   2892
287E:  BNZ   2888
2880:  MOVF   FED,F
2882:  MOVF   01,W
2884:  SUBWF  FEE,W
2886:  BC    2892
2888:  MOVF   FED,F
288A:  MOVF   01,W
288C:  MOVWF  FEF
288E:  MOVF   02,W
2890:  MOVWF  FEC
2892:  INCF   17,F
2894:  MOVLW  08
2896:  SUBWF  17,W
2898:  BTFSC  FD8.2
289A:  BRA    28A0
289C:  MOVLB  1
289E:  BRA    279A
28A0:  CLRF   17
28A2:  MOVF   FD6,W
28A4:  MOVFF  FD7,03
28A8:  BTFSS  FF2.2
28AA:  BRA    28B0
28AC:  MOVLB  1
28AE:  BRA    278A
28B0:  BRA    28A2
28B2:  MOVLW  FF
28B4:  MOVWF  17
....................    } 
....................    #else 
....................    while(1){ 
....................       if(_debug_usb()){ 
....................          test_comunicacion(); 
....................          test_reloj(); 
....................          //test_ADC(); 
....................          //test_memoria(); 
....................          //test_ccp(); 
....................          delay_ms(333); 
....................       }else{ 
....................          salida = (salida)? 0 : 1; 
....................          if(salida) output_bit(INDICADOR_RUN, 1); 
....................          else output_bit(INDICADOR_RUN, 0); 
....................          delay_ms(333); 
....................       } 
....................      } 
....................    #endif 
.................... } 
....................  
.................... /*======================= implementacion de tareas =======================*/ 
.................... #include "comunicacion.c" 
.................... //#include "Nucleo.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... #include <usb_cdc.h> 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... unsigned int indice = 0; 
.................... int COM_init(){ 
28B6:  SLEEP 
.................... 	usb_detach();  
*
1B94:  RCALL  14C8
.................... 	usb_cdc_init(); 
1B96:  CALL   039E
....................    usb_init_cs(); 
1B9A:  BRA    1B8E
....................    /*usb_task(); 
....................    if(usb_attached()){ 
....................       if(usb_enumerated()){ 
....................          return (USB_OK); 
....................       }else{ 
....................          return(USB_NO_ENUMERATED); 
....................       } 
....................    } 
....................    return (USB_NO_ATTACHED);*/ 
....................    return COM_sense(); 
1B9C:  RCALL  1528
1B9E:  MOVF   01,W
.................... } 
1BA0:  GOTO   1E30 (RETURN)
....................  
.................... int8 COM_sense(){ 
....................    usb_task(); 
*
1528:  BRA    14EE
....................    if(usb_attached()){ 
152A:  BSF    F95.3
152C:  BTFSS  F83.3
152E:  BRA    1544
....................       if(usb_enumerated()){ 
1530:  BRA    1520
1532:  MOVF   01,F
1534:  BZ    153E
....................          return (USB_OK); 
1536:  MOVLW  01
1538:  MOVWF  01
153A:  BRA    1548
....................       }else{ 
153C:  BRA    1544
....................          return(USB_NO_ENUMERATED); 
153E:  MOVLW  00
1540:  MOVWF  01
1542:  BRA    1548
....................       } 
....................    } 
....................    return(USB_NO_ATTACHED); 
1544:  MOVLW  FF
1546:  MOVWF  01
.................... } 
1548:  RETLW  00
....................  
.................... //de aqui en adelante hay que quitar estas funciones que no se utilizan 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1){ 
....................    indice = 0; 
....................    if(!COM_READY) return(-1); 
....................    while(indice < leng){ 
....................       if(wait == 1) 
....................          usb_cdc_putc(buffer[indice]); 
....................       else 
....................          usb_cdc_putc_fast(buffer[indice]); 
....................       indice++; 
....................    } 
....................    return (indice); 
.................... } 
....................  
.................... int8 COM_recive(char* buffer, unsigned int8 leng){ 
....................    indice = 0; 
....................    if(!COM_READY) return (-1); 
....................    while(indice < leng){ 
....................       if(usb_cdc_kbhit()){ 
....................          buffer[indice] = usb_cdc_getc(); 
....................          indice++; 
....................       } 
....................    } 
....................    return(indice); 
.................... } 
....................  
.................... void COM_printf(char* message){ 
.................... 	printf(usb_cdc_putc,"%s\n\r",message); 
.................... } 
....................  
.................... #include "analogo_digital.c" 
.................... //#include "Nucleo.h" 
.................... //#include "analogo_digital.h" 
.................... #ifdef ANALOGO_DIGITAL_H 
....................  
.................... #define ADC_TAD_MUL_4      0x10 
.................... #define ADC_INPUT_PORT		0x2F 
....................  
.................... int AD_init_adc(){ 
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); // default 
.................... #endif 
.................... */	 
.................... 	output_a(0x00); 
*
1BA4:  CLRF   F92
1BA6:  CLRF   F89
.................... 	set_tris_a(ADC_INPUT_PORT);		//RA0 a RA4 entradas 
1BA8:  MOVLW  2F
1BAA:  MOVWF  F92
.................... 	setup_adc_ports(AN0_TO_AN4); 
1BAC:  MOVF   FC1,W
1BAE:  ANDLW  C0
1BB0:  IORLW  0A
1BB2:  MOVWF  FC1
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_4|VSS_VDD);	 
1BB4:  BCF    FC0.0
1BB6:  BSF    FC0.1
1BB8:  BCF    FC0.2
1BBA:  BSF    FC0.7
1BBC:  BSF    FC2.0
.................... 	return (0); 
1BBE:  MOVLW  00
1BC0:  MOVWF  01
.................... } 
1BC2:  GOTO   1E36 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
13EE:  MOVLB  2
13F0:  RLCF   x2F,W
13F2:  MOVWF  00
13F4:  RLCF   00,F
13F6:  MOVLW  FC
13F8:  ANDWF  00,F
13FA:  MOVF   FC2,W
13FC:  ANDLW  C3
13FE:  IORWF  00,W
1400:  MOVWF  FC2
.................... 	delay_us(10); 
1402:  MOVLW  0D
1404:  MOVWF  00
1406:  DECFSZ 00,F
1408:  BRA    1406
.................... 	read_adc(ADC_START_ONLY); 
140A:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
140C:  BCF    x32.0
140E:  BTFSS  FC2.1
1410:  BSF    x32.0
.................... 	}while(!done); 
1412:  BTFSS  x32.0
1414:  BRA    140C
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
1416:  MOVFF  231,03
141A:  MOVFF  230,FE9
141E:  MOVFF  231,FEA
1422:  BTFSC  FC2.1
1424:  BRA    1422
1426:  MOVFF  FC3,FEF
142A:  MOVFF  FC4,FEC
.................... 	delay_us(20); 
142E:  MOVLW  1A
1430:  MOVWF  00
1432:  DECFSZ 00,F
1434:  BRA    1432
1436:  NOP   
.................... 	return (0); 
1438:  MOVLW  00
143A:  MOVWF  01
.................... } 
143C:  MOVLB  0
143E:  RETLW  00
....................  
.................... #endif	//ANALOGO_DIGITAL_H 
....................  
.................... #include "ds1307.c" 
.................... //#include "Nucleo.h" 
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_seg = 0x00; 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
1C24:  MOVLB  1
1C26:  CLRF   xBC
....................  
....................   byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
1C28:  BSF    F93.0
1C2A:  MOVLW  04
1C2C:  MOVWF  00
1C2E:  DECFSZ 00,F
1C30:  BRA    1C2E
1C32:  BSF    F93.1
1C34:  MOVLW  04
1C36:  MOVWF  00
1C38:  DECFSZ 00,F
1C3A:  BRA    1C38
1C3C:  BCF    F8A.0
1C3E:  BCF    F93.0
1C40:  MOVLW  04
1C42:  MOVWF  00
1C44:  DECFSZ 00,F
1C46:  BRA    1C44
1C48:  BCF    F8A.1
1C4A:  BCF    F93.1
....................   i2c_write(0xD0); 
1C4C:  MOVLW  D0
1C4E:  MOVWF  xD3
1C50:  MOVLB  0
1C52:  CALL   110C
....................   i2c_write(0x00); 
1C56:  MOVLB  1
1C58:  CLRF   xD3
1C5A:  MOVLB  0
1C5C:  CALL   110C
....................   i2c_start(); 
1C60:  BSF    F93.0
1C62:  MOVLW  04
1C64:  MOVWF  00
1C66:  DECFSZ 00,F
1C68:  BRA    1C66
1C6A:  BSF    F93.1
1C6C:  MOVLW  04
1C6E:  MOVWF  00
1C70:  DECFSZ 00,F
1C72:  BRA    1C70
1C74:  BTFSS  F81.1
1C76:  BRA    1C74
1C78:  BCF    F8A.0
1C7A:  BCF    F93.0
1C7C:  MOVLW  04
1C7E:  MOVWF  00
1C80:  DECFSZ 00,F
1C82:  BRA    1C80
1C84:  BCF    F8A.1
1C86:  BCF    F93.1
....................   i2c_write(0xD1); 
1C88:  MOVLW  D1
1C8A:  MOVLB  1
1C8C:  MOVWF  xD3
1C8E:  MOVLB  0
1C90:  CALL   110C
....................   seconds = ds1307_bcd2bin(i2c_read(0)); 
1C94:  CLRF   00
1C96:  CALL   1182
1C9A:  MOVFF  01,1BD
1C9E:  MOVFF  01,1D4
1CA2:  CALL   11EC
1CA6:  MOVFF  01,1BC
....................   i2c_stop(); 
1CAA:  BCF    F93.0
1CAC:  NOP   
1CAE:  BSF    F93.1
1CB0:  BTFSS  F81.1
1CB2:  BRA    1CB0
1CB4:  MOVLW  04
1CB6:  MOVWF  00
1CB8:  DECFSZ 00,F
1CBA:  BRA    1CB8
1CBC:  BRA    1CBE
1CBE:  NOP   
1CC0:  BSF    F93.0
1CC2:  MOVLW  04
1CC4:  MOVWF  00
1CC6:  DECFSZ 00,F
1CC8:  BRA    1CC6
....................   seconds &= 0x7F; 
1CCA:  MOVLB  1
1CCC:  BCF    xBC.7
....................  
....................   delay_us(3); 
1CCE:  MOVLW  03
1CD0:  MOVWF  00
1CD2:  DECFSZ 00,F
1CD4:  BRA    1CD2
1CD6:  BRA    1CD8
....................  
....................   i2c_start(); 
1CD8:  BSF    F93.0
1CDA:  MOVLW  04
1CDC:  MOVWF  00
1CDE:  DECFSZ 00,F
1CE0:  BRA    1CDE
1CE2:  BSF    F93.1
1CE4:  MOVLW  04
1CE6:  MOVWF  00
1CE8:  DECFSZ 00,F
1CEA:  BRA    1CE8
1CEC:  BCF    F8A.0
1CEE:  BCF    F93.0
1CF0:  MOVLW  04
1CF2:  MOVWF  00
1CF4:  DECFSZ 00,F
1CF6:  BRA    1CF4
1CF8:  BCF    F8A.1
1CFA:  BCF    F93.1
....................   i2c_write(0xD0); 
1CFC:  MOVLW  D0
1CFE:  MOVWF  xD3
1D00:  MOVLB  0
1D02:  CALL   110C
....................   i2c_write(0x00); 
1D06:  MOVLB  1
1D08:  CLRF   xD3
1D0A:  MOVLB  0
1D0C:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(seconds)); 
1D10:  MOVFF  1BC,1C2
1D14:  RCALL  1BFC
1D16:  MOVFF  01,1BD
1D1A:  MOVFF  01,1D3
1D1E:  CALL   110C
....................   i2c_start(); 
1D22:  BSF    F93.0
1D24:  MOVLW  04
1D26:  MOVWF  00
1D28:  DECFSZ 00,F
1D2A:  BRA    1D28
1D2C:  BSF    F93.1
1D2E:  MOVLW  04
1D30:  MOVWF  00
1D32:  DECFSZ 00,F
1D34:  BRA    1D32
1D36:  BTFSS  F81.1
1D38:  BRA    1D36
1D3A:  BCF    F8A.0
1D3C:  BCF    F93.0
1D3E:  MOVLW  04
1D40:  MOVWF  00
1D42:  DECFSZ 00,F
1D44:  BRA    1D42
1D46:  BCF    F8A.1
1D48:  BCF    F93.1
....................   i2c_write(0xD0); 
1D4A:  MOVLW  D0
1D4C:  MOVLB  1
1D4E:  MOVWF  xD3
1D50:  MOVLB  0
1D52:  CALL   110C
....................   i2c_write(0x07); 
1D56:  MOVLW  07
1D58:  MOVLB  1
1D5A:  MOVWF  xD3
1D5C:  MOVLB  0
1D5E:  CALL   110C
....................   i2c_write(val); 
1D62:  MOVFF  1BB,1D3
1D66:  CALL   110C
....................   i2c_stop(); 
1D6A:  BCF    F93.0
1D6C:  NOP   
1D6E:  BSF    F93.1
1D70:  BTFSS  F81.1
1D72:  BRA    1D70
1D74:  MOVLW  04
1D76:  MOVWF  00
1D78:  DECFSZ 00,F
1D7A:  BRA    1D78
1D7C:  BRA    1D7E
1D7E:  NOP   
1D80:  BSF    F93.0
1D82:  MOVLW  04
1D84:  MOVWF  00
1D86:  DECFSZ 00,F
1D88:  BRA    1D86
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
1D8A:  GOTO   1E4A (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
*
1F6A:  MOVLB  1
1F6C:  BCF    xC1.7
....................   hr &= 0x3F; 
1F6E:  MOVLW  3F
1F70:  ANDWF  xBF,F
....................  
....................   i2c_start(); 
1F72:  BSF    F93.0
1F74:  MOVLW  04
1F76:  MOVWF  00
1F78:  DECFSZ 00,F
1F7A:  BRA    1F78
1F7C:  BSF    F93.1
1F7E:  MOVLW  04
1F80:  MOVWF  00
1F82:  DECFSZ 00,F
1F84:  BRA    1F82
1F86:  BCF    F8A.0
1F88:  BCF    F93.0
1F8A:  MOVLW  04
1F8C:  MOVWF  00
1F8E:  DECFSZ 00,F
1F90:  BRA    1F8E
1F92:  BCF    F8A.1
1F94:  BCF    F93.1
....................   i2c_write(0xD0); 
1F96:  MOVLW  D0
1F98:  MOVWF  xD3
1F9A:  MOVLB  0
1F9C:  CALL   110C
....................   i2c_write(0x00); 
1FA0:  MOVLB  1
1FA2:  CLRF   xD3
1FA4:  MOVLB  0
1FA6:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(sec)); 
1FAA:  MOVFF  1C1,1C2
1FAE:  RCALL  1BFC
1FB0:  MOVFF  01,1C2
1FB4:  MOVFF  01,1D3
1FB8:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(min)); 
1FBC:  MOVFF  1C0,1C2
1FC0:  RCALL  1BFC
1FC2:  MOVFF  01,1C2
1FC6:  MOVFF  01,1D3
1FCA:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(hr)); 
1FCE:  MOVFF  1BF,1C2
1FD2:  RCALL  1BFC
1FD4:  MOVFF  01,1C2
1FD8:  MOVFF  01,1D3
1FDC:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(dow)); 
1FE0:  MOVFF  1BE,1C2
1FE4:  RCALL  1BFC
1FE6:  MOVFF  01,1C2
1FEA:  MOVFF  01,1D3
1FEE:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(day)); 
1FF2:  MOVFF  1BB,1C2
1FF6:  RCALL  1BFC
1FF8:  MOVFF  01,1C2
1FFC:  MOVFF  01,1D3
2000:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(mth)); 
2004:  MOVFF  1BC,1C2
2008:  RCALL  1BFC
200A:  MOVFF  01,1C2
200E:  MOVFF  01,1D3
2012:  CALL   110C
....................   i2c_write(ds1307_bin2bcd(year)); 
2016:  MOVFF  1BD,1C2
201A:  RCALL  1BFC
201C:  MOVFF  01,1C2
2020:  MOVFF  01,1D3
2024:  CALL   110C
....................   i2c_stop(); 
2028:  BCF    F93.0
202A:  NOP   
202C:  BSF    F93.1
202E:  BTFSS  F81.1
2030:  BRA    202E
2032:  MOVLW  04
2034:  MOVWF  00
2036:  DECFSZ 00,F
2038:  BRA    2036
203A:  BRA    203C
203C:  NOP   
203E:  BSF    F93.0
2040:  MOVLW  04
2042:  MOVWF  00
2044:  DECFSZ 00,F
2046:  BRA    2044
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
2048:  GOTO   215C (RETURN)
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
1216:  BSF    F93.0
1218:  MOVLW  04
121A:  MOVWF  00
121C:  DECFSZ 00,F
121E:  BRA    121C
1220:  BSF    F93.1
1222:  MOVLW  04
1224:  MOVWF  00
1226:  DECFSZ 00,F
1228:  BRA    1226
122A:  BCF    F8A.0
122C:  BCF    F93.0
122E:  MOVLW  04
1230:  MOVWF  00
1232:  DECFSZ 00,F
1234:  BRA    1232
1236:  BCF    F8A.1
1238:  BCF    F93.1
*
2172:  BSF    F93.0
2174:  MOVLW  04
2176:  MOVWF  00
2178:  DECFSZ 00,F
217A:  BRA    2178
217C:  BSF    F93.1
217E:  MOVLW  04
2180:  MOVWF  00
2182:  DECFSZ 00,F
2184:  BRA    2182
2186:  BCF    F8A.0
2188:  BCF    F93.0
218A:  MOVLW  04
218C:  MOVWF  00
218E:  DECFSZ 00,F
2190:  BRA    218E
2192:  BCF    F8A.1
2194:  BCF    F93.1
....................   i2c_write(0xD0); 
*
123A:  MOVLW  D0
123C:  MOVLB  1
123E:  MOVWF  xD3
1240:  MOVLB  0
1242:  RCALL  110C
*
2196:  MOVLW  D0
2198:  MOVLB  1
219A:  MOVWF  xD3
219C:  MOVLB  0
219E:  CALL   110C
....................   i2c_write(0x03); 
*
1244:  MOVLW  03
1246:  MOVLB  1
1248:  MOVWF  xD3
124A:  MOVLB  0
124C:  RCALL  110C
*
21A2:  MOVLW  03
21A4:  MOVLB  1
21A6:  MOVWF  xD3
21A8:  MOVLB  0
21AA:  CALL   110C
....................   i2c_start(); 
*
124E:  BSF    F93.0
1250:  MOVLW  04
1252:  MOVWF  00
1254:  DECFSZ 00,F
1256:  BRA    1254
1258:  BSF    F93.1
125A:  MOVLW  04
125C:  MOVWF  00
125E:  DECFSZ 00,F
1260:  BRA    125E
1262:  BTFSS  F81.1
1264:  BRA    1262
1266:  BCF    F8A.0
1268:  BCF    F93.0
126A:  MOVLW  04
126C:  MOVWF  00
126E:  DECFSZ 00,F
1270:  BRA    126E
1272:  BCF    F8A.1
1274:  BCF    F93.1
*
21AE:  BSF    F93.0
21B0:  MOVLW  04
21B2:  MOVWF  00
21B4:  DECFSZ 00,F
21B6:  BRA    21B4
21B8:  BSF    F93.1
21BA:  MOVLW  04
21BC:  MOVWF  00
21BE:  DECFSZ 00,F
21C0:  BRA    21BE
21C2:  BTFSS  F81.1
21C4:  BRA    21C2
21C6:  BCF    F8A.0
21C8:  BCF    F93.0
21CA:  MOVLW  04
21CC:  MOVWF  00
21CE:  DECFSZ 00,F
21D0:  BRA    21CE
21D2:  BCF    F8A.1
21D4:  BCF    F93.1
....................   i2c_write(0xD1); 
*
1276:  MOVLW  D1
1278:  MOVLB  1
127A:  MOVWF  xD3
127C:  MOVLB  0
127E:  RCALL  110C
*
21D6:  MOVLW  D1
21D8:  MOVLB  1
21DA:  MOVWF  xD3
21DC:  MOVLB  0
21DE:  CALL   110C
....................   dow = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1280:  MOVLW  01
1282:  MOVWF  00
1284:  RCALL  1182
1286:  MOVF   01,W
1288:  ANDLW  7F
128A:  MOVLB  1
128C:  MOVWF  xCF
128E:  MOVWF  xD4
1290:  MOVLB  0
1292:  RCALL  11EC
1294:  MOVFF  01,87
*
21E2:  MOVLW  01
21E4:  MOVWF  00
21E6:  CALL   1182
21EA:  MOVF   01,W
21EC:  ANDLW  7F
21EE:  MOVLB  1
21F0:  MOVWF  xCF
21F2:  MOVWF  xD4
21F4:  MOVLB  0
21F6:  CALL   11EC
21FA:  MOVFF  01,EC
....................   day = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
1298:  MOVLW  01
129A:  MOVWF  00
129C:  RCALL  1182
129E:  MOVF   01,W
12A0:  ANDLW  3F
12A2:  MOVLB  1
12A4:  MOVWF  xCF
12A6:  MOVWF  xD4
12A8:  MOVLB  0
12AA:  RCALL  11EC
12AC:  MOVFF  01,88
*
21FE:  MOVLW  01
2200:  MOVWF  00
2202:  CALL   1182
2206:  MOVF   01,W
2208:  ANDLW  3F
220A:  MOVLB  1
220C:  MOVWF  xCF
220E:  MOVWF  xD4
2210:  MOVLB  0
2212:  CALL   11EC
2216:  MOVFF  01,E5
....................   mth = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
12B0:  MOVLW  01
12B2:  MOVWF  00
12B4:  RCALL  1182
12B6:  MOVF   01,W
12B8:  ANDLW  1F
12BA:  MOVLB  1
12BC:  MOVWF  xCF
12BE:  MOVWF  xD4
12C0:  MOVLB  0
12C2:  RCALL  11EC
12C4:  MOVFF  01,89
*
221A:  MOVLW  01
221C:  MOVWF  00
221E:  CALL   1182
2222:  MOVF   01,W
2224:  ANDLW  1F
2226:  MOVLB  1
2228:  MOVWF  xCF
222A:  MOVWF  xD4
222C:  MOVLB  0
222E:  CALL   11EC
2232:  MOVFF  01,E6
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
12C8:  CLRF   00
12CA:  RCALL  1182
12CC:  MOVFF  01,1CF
12D0:  MOVFF  01,1D4
12D4:  RCALL  11EC
12D6:  MOVFF  01,8A
*
2236:  CLRF   00
2238:  CALL   1182
223C:  MOVFF  01,1CF
2240:  MOVFF  01,1D4
2244:  CALL   11EC
2248:  MOVFF  01,E7
....................   i2c_stop(); 
*
12DA:  BCF    F93.0
12DC:  NOP   
12DE:  BSF    F93.1
12E0:  BTFSS  F81.1
12E2:  BRA    12E0
12E4:  MOVLW  04
12E6:  MOVWF  00
12E8:  DECFSZ 00,F
12EA:  BRA    12E8
12EC:  BRA    12EE
12EE:  NOP   
12F0:  BSF    F93.0
12F2:  MOVLW  04
12F4:  MOVWF  00
12F6:  DECFSZ 00,F
12F8:  BRA    12F6
*
224C:  BCF    F93.0
224E:  NOP   
2250:  BSF    F93.1
2252:  BTFSS  F81.1
2254:  BRA    2252
2256:  MOVLW  04
2258:  MOVWF  00
225A:  DECFSZ 00,F
225C:  BRA    225A
225E:  BRA    2260
2260:  NOP   
2262:  BSF    F93.0
2264:  MOVLW  04
2266:  MOVWF  00
2268:  DECFSZ 00,F
226A:  BRA    2268
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
12FA:  BSF    F93.0
12FC:  MOVLW  04
12FE:  MOVWF  00
1300:  DECFSZ 00,F
1302:  BRA    1300
1304:  BSF    F93.1
1306:  MOVLW  04
1308:  MOVWF  00
130A:  DECFSZ 00,F
130C:  BRA    130A
130E:  BCF    F8A.0
1310:  BCF    F93.0
1312:  MOVLW  04
1314:  MOVWF  00
1316:  DECFSZ 00,F
1318:  BRA    1316
131A:  BCF    F8A.1
131C:  BCF    F93.1
*
226C:  BSF    F93.0
226E:  MOVLW  04
2270:  MOVWF  00
2272:  DECFSZ 00,F
2274:  BRA    2272
2276:  BSF    F93.1
2278:  MOVLW  04
227A:  MOVWF  00
227C:  DECFSZ 00,F
227E:  BRA    227C
2280:  BCF    F8A.0
2282:  BCF    F93.0
2284:  MOVLW  04
2286:  MOVWF  00
2288:  DECFSZ 00,F
228A:  BRA    2288
228C:  BCF    F8A.1
228E:  BCF    F93.1
....................   i2c_write(0xD0); 
*
131E:  MOVLW  D0
1320:  MOVLB  1
1322:  MOVWF  xD3
1324:  MOVLB  0
1326:  RCALL  110C
*
2290:  MOVLW  D0
2292:  MOVLB  1
2294:  MOVWF  xD3
2296:  MOVLB  0
2298:  CALL   110C
....................   i2c_write(0x00); 
*
1328:  MOVLB  1
132A:  CLRF   xD3
132C:  MOVLB  0
132E:  RCALL  110C
*
229C:  MOVLB  1
229E:  CLRF   xD3
22A0:  MOVLB  0
22A2:  CALL   110C
....................   i2c_start(); 
*
1330:  BSF    F93.0
1332:  MOVLW  04
1334:  MOVWF  00
1336:  DECFSZ 00,F
1338:  BRA    1336
133A:  BSF    F93.1
133C:  MOVLW  04
133E:  MOVWF  00
1340:  DECFSZ 00,F
1342:  BRA    1340
1344:  BTFSS  F81.1
1346:  BRA    1344
1348:  BCF    F8A.0
134A:  BCF    F93.0
134C:  MOVLW  04
134E:  MOVWF  00
1350:  DECFSZ 00,F
1352:  BRA    1350
1354:  BCF    F8A.1
1356:  BCF    F93.1
*
22A6:  BSF    F93.0
22A8:  MOVLW  04
22AA:  MOVWF  00
22AC:  DECFSZ 00,F
22AE:  BRA    22AC
22B0:  BSF    F93.1
22B2:  MOVLW  04
22B4:  MOVWF  00
22B6:  DECFSZ 00,F
22B8:  BRA    22B6
22BA:  BTFSS  F81.1
22BC:  BRA    22BA
22BE:  BCF    F8A.0
22C0:  BCF    F93.0
22C2:  MOVLW  04
22C4:  MOVWF  00
22C6:  DECFSZ 00,F
22C8:  BRA    22C6
22CA:  BCF    F8A.1
22CC:  BCF    F93.1
....................   i2c_write(0xD1); 
*
1358:  MOVLW  D1
135A:  MOVLB  1
135C:  MOVWF  xD3
135E:  MOVLB  0
1360:  RCALL  110C
*
22CE:  MOVLW  D1
22D0:  MOVLB  1
22D2:  MOVWF  xD3
22D4:  MOVLB  0
22D6:  CALL   110C
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1362:  MOVLW  01
1364:  MOVWF  00
1366:  RCALL  1182
1368:  MOVF   01,W
136A:  ANDLW  7F
136C:  MOVLB  1
136E:  MOVWF  xCF
1370:  MOVWF  xD4
1372:  MOVLB  0
1374:  RCALL  11EC
1376:  MOVFF  01,8D
*
22DA:  MOVLW  01
22DC:  MOVWF  00
22DE:  CALL   1182
22E2:  MOVF   01,W
22E4:  ANDLW  7F
22E6:  MOVLB  1
22E8:  MOVWF  xCF
22EA:  MOVWF  xD4
22EC:  MOVLB  0
22EE:  CALL   11EC
22F2:  MOVFF  01,EA
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
137A:  MOVLW  01
137C:  MOVWF  00
137E:  RCALL  1182
1380:  MOVF   01,W
1382:  ANDLW  7F
1384:  MOVLB  1
1386:  MOVWF  xCF
1388:  MOVWF  xD4
138A:  MOVLB  0
138C:  RCALL  11EC
138E:  MOVFF  01,8C
*
22F6:  MOVLW  01
22F8:  MOVWF  00
22FA:  CALL   1182
22FE:  MOVF   01,W
2300:  ANDLW  7F
2302:  MOVLB  1
2304:  MOVWF  xCF
2306:  MOVWF  xD4
2308:  MOVLB  0
230A:  CALL   11EC
230E:  MOVFF  01,E9
....................   hr = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
1392:  CLRF   00
1394:  RCALL  1182
1396:  MOVF   01,W
1398:  ANDLW  3F
139A:  MOVLB  1
139C:  MOVWF  xCF
139E:  MOVWF  xD4
13A0:  MOVLB  0
13A2:  RCALL  11EC
13A4:  MOVFF  01,8B
*
2312:  CLRF   00
2314:  CALL   1182
2318:  MOVF   01,W
231A:  ANDLW  3F
231C:  MOVLB  1
231E:  MOVWF  xCF
2320:  MOVWF  xD4
2322:  MOVLB  0
2324:  CALL   11EC
2328:  MOVFF  01,E8
....................   i2c_stop(); 
*
13A8:  BCF    F93.0
13AA:  NOP   
13AC:  BSF    F93.1
13AE:  BTFSS  F81.1
13B0:  BRA    13AE
13B2:  MOVLW  04
13B4:  MOVWF  00
13B6:  DECFSZ 00,F
13B8:  BRA    13B6
13BA:  BRA    13BC
13BC:  NOP   
13BE:  BSF    F93.0
13C0:  MOVLW  04
13C2:  MOVWF  00
13C4:  DECFSZ 00,F
13C6:  BRA    13C4
*
232C:  BCF    F93.0
232E:  NOP   
2330:  BSF    F93.1
2332:  BTFSS  F81.1
2334:  BRA    2332
2336:  MOVLW  04
2338:  MOVWF  00
233A:  DECFSZ 00,F
233C:  BRA    233A
233E:  BRA    2340
2340:  NOP   
2342:  BSF    F93.0
2344:  MOVLW  04
2346:  MOVWF  00
2348:  DECFSZ 00,F
234A:  BRA    2348
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................   char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
1D8E:  BSF    F93.0
1D90:  MOVLW  04
1D92:  MOVWF  00
1D94:  DECFSZ 00,F
1D96:  BRA    1D94
1D98:  BSF    F93.1
1D9A:  MOVLW  04
1D9C:  MOVWF  00
1D9E:  DECFSZ 00,F
1DA0:  BRA    1D9E
1DA2:  BCF    F8A.0
1DA4:  BCF    F93.0
1DA6:  MOVLW  04
1DA8:  MOVWF  00
1DAA:  DECFSZ 00,F
1DAC:  BRA    1DAA
1DAE:  BCF    F8A.1
1DB0:  BCF    F93.1
....................   i2c_write(0xD0); 
1DB2:  MOVLW  D0
1DB4:  MOVLB  1
1DB6:  MOVWF  xD3
1DB8:  MOVLB  0
1DBA:  CALL   110C
....................   i2c_write(addr); 
1DBE:  MOVFF  1BB,1D3
1DC2:  CALL   110C
....................  
....................   i2c_start(); 
1DC6:  BSF    F93.0
1DC8:  MOVLW  04
1DCA:  MOVWF  00
1DCC:  DECFSZ 00,F
1DCE:  BRA    1DCC
1DD0:  BSF    F93.1
1DD2:  MOVLW  04
1DD4:  MOVWF  00
1DD6:  DECFSZ 00,F
1DD8:  BRA    1DD6
1DDA:  BTFSS  F81.1
1DDC:  BRA    1DDA
1DDE:  BCF    F8A.0
1DE0:  BCF    F93.0
1DE2:  MOVLW  04
1DE4:  MOVWF  00
1DE6:  DECFSZ 00,F
1DE8:  BRA    1DE6
1DEA:  BCF    F8A.1
1DEC:  BCF    F93.1
....................   i2c_write(0xD1); 
1DEE:  MOVLW  D1
1DF0:  MOVLB  1
1DF2:  MOVWF  xD3
1DF4:  MOVLB  0
1DF6:  CALL   110C
....................   retval = i2c_read(0); 
1DFA:  CLRF   00
1DFC:  CALL   1182
1E00:  MOVFF  01,1BC
....................   i2c_stop(); 
1E04:  BCF    F93.0
1E06:  NOP   
1E08:  BSF    F93.1
1E0A:  BTFSS  F81.1
1E0C:  BRA    1E0A
1E0E:  MOVLW  04
1E10:  MOVWF  00
1E12:  DECFSZ 00,F
1E14:  BRA    1E12
1E16:  BRA    1E18
1E18:  NOP   
1E1A:  BSF    F93.0
1E1C:  MOVLW  04
1E1E:  MOVWF  00
1E20:  DECFSZ 00,F
1E22:  BRA    1E20
....................  
.................... return(retval); 
1E24:  MOVLB  1
1E26:  MOVFF  1BC,01
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
1E2A:  MOVLB  0
1E2C:  RETLW  00
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
204C:  BSF    F93.0
204E:  MOVLW  04
2050:  MOVWF  00
2052:  DECFSZ 00,F
2054:  BRA    2052
2056:  BSF    F93.1
2058:  MOVLW  04
205A:  MOVWF  00
205C:  DECFSZ 00,F
205E:  BRA    205C
2060:  BCF    F8A.0
2062:  BCF    F93.0
2064:  MOVLW  04
2066:  MOVWF  00
2068:  DECFSZ 00,F
206A:  BRA    2068
206C:  BCF    F8A.1
206E:  BCF    F93.1
....................   i2c_write(0xD0); 
2070:  MOVLW  D0
2072:  MOVLB  1
2074:  MOVWF  xD3
2076:  MOVLB  0
2078:  CALL   110C
....................   i2c_write(addr); 
207C:  MOVFF  1BB,1D3
2080:  CALL   110C
....................   i2c_write(value); 
2084:  MOVFF  1BC,1D3
2088:  CALL   110C
....................   i2c_stop(); 
208C:  BCF    F93.0
208E:  NOP   
2090:  BSF    F93.1
2092:  BTFSS  F81.1
2094:  BRA    2092
2096:  MOVLW  04
2098:  MOVWF  00
209A:  DECFSZ 00,F
209C:  BRA    209A
209E:  BRA    20A0
20A0:  NOP   
20A2:  BSF    F93.0
20A4:  MOVLW  04
20A6:  MOVWF  00
20A8:  DECFSZ 00,F
20AA:  BRA    20A8
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
20AC:  RETLW  00
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................   byte lday; 
....................   byte lmonth; 
....................   byte lyr; 
....................   byte ldow; 
....................   ds1307_get_date(lday,lmonth,lyr,ldow); 
....................   sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
1BFC:  MOVFF  1C2,1C3
....................   retval = 0; 
1C00:  MOVLB  1
1C02:  CLRF   xC4
....................   while(1){ 
....................     if(temp >= 10){ 
1C04:  MOVF   xC3,W
1C06:  SUBLW  09
1C08:  BC    1C14
....................       temp -= 10; 
1C0A:  MOVLW  0A
1C0C:  SUBWF  xC3,F
....................       retval += 0x10; 
1C0E:  MOVLW  10
1C10:  ADDWF  xC4,F
....................     }else{ 
1C12:  BRA    1C1A
....................       retval += temp; 
1C14:  MOVF   xC3,W
1C16:  ADDWF  xC4,F
....................       break; 
1C18:  BRA    1C1C
....................     } 
....................   } 
1C1A:  BRA    1C04
....................   return(retval); 
1C1C:  MOVFF  1C4,01
.................... } 
1C20:  MOVLB  0
1C22:  RETLW  00
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
11EC:  MOVFF  1D4,1D5
....................   temp >>= 1; 
11F0:  BCF    FD8.0
11F2:  MOVLB  1
11F4:  RRCF   xD5,F
....................   temp &= 0x78; 
11F6:  MOVLW  78
11F8:  ANDWF  xD5,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
11FA:  RRCF   xD5,W
11FC:  MOVWF  00
11FE:  RRCF   00,F
1200:  MOVLW  3F
1202:  ANDWF  00,F
1204:  MOVF   00,W
1206:  ADDWF  xD5,W
1208:  MOVWF  xD6
120A:  MOVF   xD4,W
120C:  ANDLW  0F
120E:  ADDWF  xD6,W
1210:  MOVWF  01
.................... } 
1212:  MOVLB  0
1214:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
.................... /* 
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x03); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
....................   year = ds1307_bcd2bin(i2c_read(0)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
....................   temp >>= 1; 
....................   temp &= 0x78; 
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... } 
.................... */ 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "captura_frecuencia.c" 
.................... #ifdef CAPTURA_FRECUENCIA_H 
.................... //#include "captura_frecuencia.h" 
.................... /* 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #endif 
.................... */ 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
1A2C:  INCF   x92,F
.................... } 
....................  
1A2E:  BCF    FA1.1
1A30:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
1A34:  MOVF   x91,W
1A36:  SUBLW  FF
1A38:  BNZ   1A4A
....................    	setup_ccp1(CCP_CAPTURE_FE); 
1A3A:  BSF    F94.2
1A3C:  CLRF   FBD
1A3E:  MOVLW  04
1A40:  MOVWF  FBD
1A42:  CLRF   FB7
1A44:  CLRF   FB6
....................    	Q_CCP = 0; 
1A46:  CLRF   x91
....................    }else if(Q_CCP == 0){ 
1A48:  BRA    1AD2
1A4A:  MOVF   x91,F
1A4C:  BNZ   1A86
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
1A4E:  CLRF   01
1A50:  MOVFF  92,25D
1A54:  MOVLB  2
1A56:  CLRF   x5B
1A58:  CLRF   x5C
1A5A:  MOVF   FBE,W
1A5C:  ADDWF  x5B,W
1A5E:  MOVLB  0
1A60:  MOVWF  x97
1A62:  MOVF   FBF,W
1A64:  MOVLB  2
1A66:  ADDWFC x5C,W
1A68:  MOVLB  0
1A6A:  MOVWF  x98
1A6C:  MOVLW  00
1A6E:  MOVLB  2
1A70:  ADDWFC x5D,W
1A72:  MOVLB  0
1A74:  MOVWF  x99
1A76:  MOVLW  00
1A78:  MOVLB  2
1A7A:  ADDWFC 01,W
1A7C:  MOVLB  0
1A7E:  MOVWF  x9A
....................    	Q_CCP = 1; 
1A80:  MOVLW  01
1A82:  MOVWF  x91
....................    }else if(Q_CCP == 1){ 
1A84:  BRA    1AD2
1A86:  DECFSZ x91,W
1A88:  BRA    1AD2
....................    	disable_interrupts(INT_CCP1); 
1A8A:  BCF    F9D.2
....................    	tiempo_inicial = tiempo_final; 
1A8C:  MOVFF  9A,96
1A90:  MOVFF  99,95
1A94:  MOVFF  98,94
1A98:  MOVFF  97,93
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
1A9C:  CLRF   01
1A9E:  MOVFF  92,25D
1AA2:  MOVLB  2
1AA4:  CLRF   x5B
1AA6:  CLRF   x5C
1AA8:  MOVF   FBE,W
1AAA:  ADDWF  x5B,W
1AAC:  MOVLB  0
1AAE:  MOVWF  x97
1AB0:  MOVF   FBF,W
1AB2:  MOVLB  2
1AB4:  ADDWFC x5C,W
1AB6:  MOVLB  0
1AB8:  MOVWF  x98
1ABA:  MOVLW  00
1ABC:  MOVLB  2
1ABE:  ADDWFC x5D,W
1AC0:  MOVLB  0
1AC2:  MOVWF  x99
1AC4:  MOVLW  00
1AC6:  MOVLB  2
1AC8:  ADDWFC 01,W
1ACA:  MOVLB  0
1ACC:  MOVWF  x9A
....................    	Q_CCP = 2; 
1ACE:  MOVLW  02
1AD0:  MOVWF  x91
....................    } 
.................... } 
....................  
1AD2:  BCF    F9E.2
1AD4:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
1AD8:  MOVF   x91,W
1ADA:  SUBLW  FF
1ADC:  BNZ   1AEE
....................    	setup_ccp1(CCP_CAPTURE_FE); 
1ADE:  BSF    F94.2
1AE0:  CLRF   FBD
1AE2:  MOVLW  04
1AE4:  MOVWF  FBD
1AE6:  CLRF   FB7
1AE8:  CLRF   FB6
....................    	Q_CCP = 0; 
1AEA:  CLRF   x91
....................    }else if(Q_CCP == 0){ 
1AEC:  BRA    1B76
1AEE:  MOVF   x91,F
1AF0:  BNZ   1B2A
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
1AF2:  CLRF   01
1AF4:  MOVFF  92,25D
1AF8:  MOVLB  2
1AFA:  CLRF   x5B
1AFC:  CLRF   x5C
1AFE:  MOVF   FBB,W
1B00:  ADDWF  x5B,W
1B02:  MOVLB  0
1B04:  MOVWF  x97
1B06:  MOVF   FBC,W
1B08:  MOVLB  2
1B0A:  ADDWFC x5C,W
1B0C:  MOVLB  0
1B0E:  MOVWF  x98
1B10:  MOVLW  00
1B12:  MOVLB  2
1B14:  ADDWFC x5D,W
1B16:  MOVLB  0
1B18:  MOVWF  x99
1B1A:  MOVLW  00
1B1C:  MOVLB  2
1B1E:  ADDWFC 01,W
1B20:  MOVLB  0
1B22:  MOVWF  x9A
....................    	Q_CCP = 1; 
1B24:  MOVLW  01
1B26:  MOVWF  x91
....................    }else if(Q_CCP == 1){ 
1B28:  BRA    1B76
1B2A:  DECFSZ x91,W
1B2C:  BRA    1B76
....................    	disable_interrupts(INT_CCP2); 
1B2E:  BCF    FA0.0
....................    	tiempo_inicial = tiempo_final; 
1B30:  MOVFF  9A,96
1B34:  MOVFF  99,95
1B38:  MOVFF  98,94
1B3C:  MOVFF  97,93
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
1B40:  CLRF   01
1B42:  MOVFF  92,25D
1B46:  MOVLB  2
1B48:  CLRF   x5B
1B4A:  CLRF   x5C
1B4C:  MOVF   FBB,W
1B4E:  ADDWF  x5B,W
1B50:  MOVLB  0
1B52:  MOVWF  x97
1B54:  MOVF   FBC,W
1B56:  MOVLB  2
1B58:  ADDWFC x5C,W
1B5A:  MOVLB  0
1B5C:  MOVWF  x98
1B5E:  MOVLW  00
1B60:  MOVLB  2
1B62:  ADDWFC x5D,W
1B64:  MOVLB  0
1B66:  MOVWF  x99
1B68:  MOVLW  00
1B6A:  MOVLB  2
1B6C:  ADDWFC 01,W
1B6E:  MOVLB  0
1B70:  MOVWF  x9A
....................    	Q_CCP = 2; 
1B72:  MOVLW  02
1B74:  MOVWF  x91
....................    } 
.................... } 
....................  
1B76:  BCF    FA1.0
1B78:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
*
1BC6:  MOVFF  8E,FB1
....................    T3CON.TMR3ON = 0; 
1BCA:  BCF    FB1.0
....................    set_timer3(0); 
1BCC:  CLRF   FB3
1BCE:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
1BD0:  MOVF   x8F,W
1BD2:  ANDLW  08
1BD4:  BTFSC  FD8.2
1BD6:  BCF    F82.2
1BD8:  CLRF   FBD
1BDA:  MOVFF  8F,FBD
1BDE:  CLRF   FB7
1BE0:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
1BE2:  MOVF   x90,W
1BE4:  ANDLW  08
1BE6:  BTFSC  FD8.2
1BE8:  BCF    F82.1
1BEA:  CLRF   FBA
1BEC:  MOVFF  90,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1;                        
1BF0:  BSF    F94.2
1BF2:  BSF    F94.1
....................    return 0; 
1BF4:  MOVLW  00
1BF6:  MOVWF  01
.................... } 
1BF8:  GOTO   1E3C (RETURN)
....................  
.................... void CP_activar_captura(int canal){ 
.................... 	//CODIGO DE MANEJO DE CCP 
.................... 	semaforo_ccp = 1; 
*
18DA:  MOVLW  01
18DC:  MOVWF  x9B
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
18DE:  MOVLW  C0
18E0:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
18E2:  BSF    FA0.1
....................    tiempo_inicial = tiempo_final = 0; 
18E4:  CLRF   x9A
18E6:  CLRF   x99
18E8:  CLRF   x98
18EA:  CLRF   x97
18EC:  MOVFF  9A,96
18F0:  MOVFF  99,95
18F4:  MOVFF  98,94
18F8:  MOVFF  97,93
....................    set_timer3(0);      						//se reset timer  a 0 
18FC:  CLRF   FB3
18FE:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
1900:  BSF    FB1.0
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
1902:  MOVLB  2
1904:  DECFSZ x45,W
1906:  BRA    190C
1908:  BSF    F9D.2
190A:  BRA    190E
190C:  BSF    FA0.0
.................... } 
190E:  MOVLB  0
1910:  GOTO   19F0 (RETURN)
....................  
.................... void CP_desativar_captura(){ 
.................... 	disable_interrupts(INT_CCP1); 
*
1942:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
1944:  BCF    FA0.0
....................    disable_interrupts(INT_TIMER3); 
1946:  BCF    FA0.1
....................    //disable_interrupts(GLOBAL); 
....................    setup_ccp2(MODO_CCP1); 
1948:  MOVF   x8F,W
194A:  ANDLW  08
194C:  BTFSC  FD8.2
194E:  BCF    F82.1
1950:  CLRF   FBA
1952:  MOVFF  8F,FBA
....................    setup_ccp2(MODO_CCP2); 
1956:  MOVF   x90,W
1958:  ANDLW  08
195A:  BTFSC  FD8.2
195C:  BCF    F82.1
195E:  CLRF   FBA
1960:  MOVFF  90,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
1964:  MOVLW  FF
1966:  MOVWF  x91
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
1968:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
196A:  CLRF   x92
....................    semaforo_ccp = 0; 
196C:  CLRF   x9B
.................... } 
196E:  GOTO   1A0C (RETURN)
....................  
.................... int CP_ocupado(){ return (semaforo_ccp != 0);} 
*
18B0:  MOVF   x9B,F
18B2:  BNZ   18B8
18B4:  MOVLW  00
18B6:  BRA    18BA
18B8:  MOVLW  01
18BA:  MOVWF  01
18BC:  GOTO   19AC (RETURN)
.................... int CP_done(){ return (Q_CCP == 2);} 
*
1914:  MOVF   x91,W
1916:  SUBLW  02
1918:  BZ    191E
191A:  MOVLW  00
191C:  BRA    1920
191E:  MOVLW  01
1920:  MOVWF  01
1922:  GOTO   19F2 (RETURN)
....................  
.................... int32 CP_obtener_resultado(){ 
.................... 	return (tiempo_final - tiempo_inicial); 
1926:  MOVF   x93,W
1928:  SUBWF  x97,W
192A:  MOVWF  00
192C:  MOVF   x94,W
192E:  SUBWFB x98,W
1930:  MOVWF  01
1932:  MOVF   x95,W
1934:  SUBWFB x99,W
1936:  MOVWF  02
1938:  MOVF   x96,W
193A:  SUBWFB x9A,W
193C:  MOVWF  03
.................... } 
193E:  GOTO   19FA (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    set_timer3(0);      					//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
....................    //while(Q_CCP != 2){;}              //espera a que se carguen los valores de los tiempos 
....................    disable_interrupts(INT_CCP1); 
....................    disable_interrupts(INT_CCP2); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
....................    return (0); 
.................... } 
.................... #endif 
....................  
.................... #include "memoria.c" 
.................... //#include "Nucleo.h" 
.................... #ifdef MEMORIA_H 
....................  
.................... //#include "memoria.h" 
.................... #include "comunicacion.h" 
....................  
.................... //borrar para quitar el debug de memoria 
.................... #define debug_memoria 1	 
....................  
.................... // #define MEM_RX PIN_D7 
.................... // #define MEM_TX PIN_D6	 
.................... #define MEMORIA_PIN_RESET PIN_D5 
.................... #use rs232(uart1, stream=MEMORIA, BAUD=9600, TIMEOUT=1000) 
.................... #define time_delay 1000 
....................  
.................... short MEMORIA_OK = FALSE; 
.................... short MEMORIA_HW = FALSE; 
.................... short timeout_error = FALSE; 
.................... short read_flag = 0; //utilizada por un bug en la lectura de archivos desde dispositivo de memoria 
.................... int8 MEM_proceso = INI_HW; 
.................... unsigned int i = 0; 
.................... unsigned int car = 0; 
.................... unsigned int32 tamano = 0; 
.................... char MEM_info[5] = {0x00,0x00,0x00,0x00,0x00}; 
.................... char MEM_file_name[MEMORIA_NAME_LENG_LIMIT]; 
.................... char MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
.................... char MEM_append = MEMORIA_APPEND; 
.................... //char MEM_performance = MEMORIA_HIGH_PERFORMANCE;	//cambiar a low performance 
.................... char MEM_performance = MEMORIA_LOW_PERFORMANCE; 
.................... char MEM_RESPONSE = MEMORIA_NOACK; 
....................  
.................... #ifdef debug_memoria 
.................... void update_proceso(int8 proceso){ 
.................... 	MEM_proceso = proceso; 
.................... 	printf(usb_cdc_putc_fast,"\n\rMp>%d", MEM_proceso); 
.................... 	return; 
.................... } 
.................... #endif 
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL INICIO DEL MODULO DE MEMORIA 
.................... 	====================================== 
.................... */ 
.................... /*==================== reset de memoria ======================*/ 
.................... int MEMORIA_reset(void){ 
.................... 	#ifdef debug_memoria 
.................... 	usb_cdc_putc_fast('r'); 
.................... 	#endif 
.................... 	output_float(PIN_D6); 
....................    output_low(MEMORIA_PIN_RESET); 
....................    delay_ms(1000); 
....................    read_flag = 0; 
....................    output_high(MEMORIA_PIN_RESET); 
....................    delay_ms(3000); 
....................    return(0); 
.................... } 
....................  
.................... /*==================== autobaudrate ======================*/ 
.................... int MEMORIA_init_hw(void){ 
.................... 	int8 envios = 10; 
.................... 	#ifdef debug_memoria 
.................... 	update_proceso(INI_HW); 
.................... 	#else 
.................... 	MEM_proceso = INI_HW; 
.................... 	#endif 
.................... 	 
.................... 	do{ 
.................... 		MEMORIA_putc(MEMORIA_CMD_AUTOBAUD); 
.................... 		MEM_RESPONSE = MEMORIA_getc(); 
.................... 		envios --; 
.................... 		delay_ms(200); 
.................... 	}while((envios > 0) && (MEM_RESPONSE != MEMORIA_ACK) );                                                        
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){                                 
.................... 		return (1); 
.................... 	} 
....................     
....................    MEMORIA_HW = TRUE; 
....................    MEMORIA_OK = FALSE; 
....................    read_flag = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(INI_SW); 
.................... 	#else 
.................... 	MEM_proceso = INI_SW; 
.................... 	#endif 
.................... 	 
....................    return (0); 
.................... } 
....................  
.................... /*==================== iniciar memoria ======================*/ 
.................... int MEMORIA_init(void){ 
....................  
....................    if(!MEMORIA_HW || (MEM_proceso != INI_SW)) return (1); 
.................... 	 
.................... 	MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_INITIALIZE); 
....................     
....................    MEM_RESPONSE = MEMORIA_getc(); 
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK) return(2); 
....................    else MEMORIA_OK = TRUE; 
....................     
....................    read_flag = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return (0); 
.................... } 
....................  
.................... /*====================get info======================*/ 
.................... void MEMORIA_getinfo(){ 
....................  
.................... 	MEMORIA_putc(MEMORIA_CMD_VER_INFO); 
....................    MEM_info[0] = MEMORIA_getc(); 
....................    MEM_info[1] = MEMORIA_getc(); 
....................    MEM_info[2] = MEMORIA_getc(); 
....................    MEM_info[3] = MEMORIA_getc(); 
....................    MEM_info[4] = MEMORIA_getc(); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\rMemInf: %x %x %x %x %x", MEM_info[0],MEM_info[1],MEM_info[2],MEM_info[3],MEM_info[4]); 
....................    #endif 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL MANEJO DE ARCHIVOS 
.................... 	====================================== 
.................... */ 
....................  
.................... /*====================abrir archivo======================*/ 
....................  
.................... int MEMORIA_open(char* filename, short modo){ 
....................  
....................    if(!MEMORIA_OK) return(1); 
....................  
....................    if(modo){ 
....................       #ifdef debug_memoria 
.................... 		update_proceso(WR); 
.................... 		#else 
.................... 		MEM_proceso = WR; 
.................... 		#endif 
....................    }else{ 
.................... 		#ifdef debug_memoria 
.................... 		update_proceso(RD); 
.................... 		#else 
.................... 		MEM_proceso = RD; 
.................... 		#endif 
....................    } 
....................     
....................    car = strlen(filename); 
....................    car = (car <= MEMORIA_NAME_LENG_LIMIT)? car : MEMORIA_NAME_LENG_LIMIT;  
....................    strncpy(MEM_file_name, filename, car); 
....................     
....................    i = 0; 
....................    timeout_error = FALSE; 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    MEM_RESPONSE = MEMORIA_NOACK; 
....................    return (0); 
.................... } 
....................  
.................... /*==================== cancelar proceso ======================*/ 
....................  
.................... int MEMORIA_cancel(void){ 
....................  
....................    if((MEM_proceso != GET) || (MEM_proceso != SET)){ 
....................       return(-1); 
....................    } 
....................     
....................    if(MEM_proceso == GET){ 
....................       fputc(MEMORIA_NOACK, MEMORIA); 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................  
....................    if(MEM_proceso == SET){ 
....................       while(tamano > 0 ){ 
....................          fputc(0x00,MEMORIA); 
....................          --tamano; 
....................       } 
....................    } 
....................  
....................    tamano = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    return (0); 
.................... } 
....................  
.................... /*==================== enviar comando de escritura ======================*/ 
.................... /* 
....................  *BUG: puede retornar 1 0 en la primera escritura del archivo 
....................  *TODO: corregir para primera escritura  
.................... */ 
.................... int MEMORIA_write(unsigned int size){ 
....................     
....................    if(!MEMORIA_OK)return(-1); 
....................    if(MEM_proceso != WR)return(-2); 
....................        
....................     
....................    //buffer maximo de 100 bytes 
....................    if((size > 0) && (size <= MAX_BUFFER)) 
....................       MEM_handshaking = MEMORIA_NO_HANDSHAKING; 
....................    else 
....................       return (-3); 
....................     
....................    tamano = (unsigned int32)size; 
....................    //tamano = (int32)size; 
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_WRITE_FILE); 
....................    MEMORIA_putc((MEM_handshaking | MEM_append | MEM_performance)); 
....................     
....................    for(i = 0; i < car; i++) 
....................       MEMORIA_putc(MEM_file_name[i]); 
....................  
....................    MEMORIA_putc(0x00); 
....................  
....................    MEMORIA_putc(make8(tamano,3)); 
....................    MEMORIA_putc(make8(tamano,2)); 
....................    MEMORIA_putc(make8(tamano,1)); 
....................    MEMORIA_putc(make8(tamano,0)); 
....................  
....................    MEM_RESPONSE = MEMORIA_getc(); 
....................    //reparacion de bug a primera escritura 
....................    if(MEM_RESPONSE == 0x00){ 
....................    	MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){ 
....................       return (-4); 
....................    } 
....................    #ifdef debug_memoria 
.................... 	update_proceso(SET); 
.................... 	#else 
.................... 	MEM_proceso = SET; 
.................... 	#endif 
....................    return (0); 
.................... } 
....................  
.................... /*==================== enviar datos de escritura ======================*/ 
.................... /* 
....................  * corrwgir deacuerdo a MEMORIA_write() 
....................  */ 
.................... int MEMORIA_set_data(char *data, unsigned int size){ 
....................  
....................    if(!MEMORIA_OK)return(-5); 
....................    if(MEM_proceso != SET) return(-6); 
....................    if(tamano <= 0)return(-7); 
....................  
....................    i = 0; 
....................    while((tamano > 0)&&(i < size)){ 
....................       MEMORIA_putc(data[i]); 
....................       i++; 
....................       tamano--; 
....................    } 
....................     
....................    //si no hay mas datos 
....................    if(tamano <= 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
....................          return (-8); 
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i); 
.................... } 
....................  
.................... /*==================== enviar comando de lectura ======================*/ 
....................  
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes){ 
....................    char Umsb = 0, Ulsb = 0, Lmsb = 0,Llsb = 0, dummy= 0; 
....................  
....................    if(!MEMORIA_OK)return(-1); 
....................    if(MEM_proceso != RD)return(-2); 
....................  
....................    if((num_bytes > 0) && (num_bytes <= MAX_BUFFER)) 
....................       MEM_handshaking = num_bytes; 
....................    else 
....................       return (-3); 
....................     
....................     
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_READ_FILE); 
....................    MEMORIA_putc(MEM_handshaking); 
....................     
....................    for(i = 0; i < car; i++) 
....................       MEMORIA_putc(MEM_file_name[i]); 
.................... 	 
.................... 	fputc(0x00, MEMORIA); 
.................... 	// hay un bug al leer por primera vez un archivo 
.................... 	// genera 2 ACK antes del tamao del archivo 
.................... 	if(read_flag == 0){ 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		read_flag = 1; 
.................... 	} 
.................... 	//bug de comunicacion 
.................... 	 
.................... 	Umsb = fgetc(MEMORIA); 
....................    Ulsb = fgetc(MEMORIA); 
....................    Lmsb = fgetc(MEMORIA); 
....................    Llsb = fgetc(MEMORIA); 
....................     
....................    tamano = make32(Umsb,Ulsb,Lmsb,Llsb); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r==%x %x %x %x", Umsb, Ulsb,Lmsb,Llsb); 
.................... 	update_proceso(GET); 
.................... 	#else 
.................... 	MEM_proceso = GET; 
.................... 	#endif 
....................    return (tamano); 
.................... } 
....................  
....................  
.................... /*==================== obtener datos de la lectura ======================*/ 
....................  
.................... int MEMORIA_get_data(char *buffer){    
....................    char c = 0x00; 
....................  
....................    if(!MEMORIA_OK) return(-1); 
....................    if(MEM_proceso != GET) return(-2); 
....................    if(tamano <= 0) return(-3); 
....................  
....................    i = 0; 
....................    MEMORIA_putc(MEMORIA_ACK);//envia un ACK para recivir nuevos datos 
....................    while((i < MEM_handshaking) && (tamano > 0 )){ 
....................       c = MEMORIA_getc(); 
....................       buffer[i] = c; 
....................       i++; 
....................       tamano--; 
....................    } 
....................  
....................    //si alcanzo el total de datos 
....................    if(tamano == 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
....................          return (-4); 
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i);    
.................... } 
....................  
.................... /*==================== cerrar el archivo abierto ======================*/ 
....................  
.................... int MEMORIA_close(void){ 
.................... 	/* 
.................... 	* hay un bug en esta funcion que no contempla limpiar 
.................... 	* la configuracion cuando no ha iniciado el hardware o 
.................... 	* despues de un reset 
.................... 	*/ 
.................... 	/* 
....................    if(!MEMORIA_OK)return (1); 
....................    if(MEM_proceso != CLOSE) return(2); 
....................    */ 
....................    strcpy (MEM_file_name,"");	//cambiar para inicializar a 0 
....................    i = 0; 
....................    car = 0; 
....................    timeout_error = FALSE; 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    MEM_RESPONSE = MEMORIA_NOACK; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return(0); 
.................... } 
....................  
.................... /*	====================================== 
.................... 	FUNCIONES FUNCIONES DE CONTROL Y BAJO NIVEL 
.................... 	====================================== 
.................... */ 
....................  
.................... /*==================== memoria ocupada =======================*/ 
.................... /*comprueba que no se este realizando un porceso anterior en la memoria*/ 
.................... int MEMORIA_is_busy(void){ 
....................    return ((MEM_proceso == OPEN )? 0 : 1); 
.................... }  
....................  
.................... /*==================== colocar un caracter en el bus======================*/ 
.................... void MEMORIA_putc(char c){ 
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, "\n\r>%X", c); 
.................... 	#endif 
....................    fputc(c, MEMORIA); 
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, " e%X", rs232_errors); 
.................... 	#endif 
....................    return; 
.................... } 
....................  
.................... /*==================== obtiene un caracter del bus======================*/ 
.................... char MEMORIA_getc(void){ 
.................... 	char c = 0x00, cont = 3; 
....................    timeout_error=FALSE; 
....................    while(!kbhit(MEMORIA) && cont > 0 && !c){ 
....................    	c = fgetc(MEMORIA); 
....................    	#ifdef debug_memoria 
....................    	usb_cdc_putc_fast('*'); 
....................    	#endif 
....................    	cont--; 
....................    } 
....................     
....................    if(!c) c = fgetc(MEMORIA); 
....................     
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r<%x e%x", c, rs232_errors); 
....................    #endif 
....................    return(c); 
.................... } 
.................... #endif	// MEMORIA_H 
....................  
.................... #include "utilidades.c" 
.................... //#include "Nucleo.h" 
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
.................... #define MYDIM 64; 
.................... char MyArray[MYDIM]; 
.................... */ 
....................  
.................... int16 crc_1021(int16 old_crc, int8 data) 
.................... {  
....................   int16 crc; 
....................   int16 x; 
....................   x = make8(old_crc,1) ^ data;  //x = ((old_crc>>8) ^ data) & 0xff;  
....................   x ^= x>>4; 
....................   crc = (old_crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
....................   crc &= 0xffff;  
....................   return crc;  
.................... } 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng){ 
.................... 	unsigned int8 i;  
....................    int16 MyCRC; 
....................     
....................    MyCRC = 0xFFFF;  
....................    for(i=0 ; i<leng ; i++) {  
....................       MyCRC = crc_1021(MyCRC,buffer[i]);  
....................    } 
....................    return (MyCRC); 
.................... } 
....................  
.................... #ifndef SIMULACION 
.................... int1 _debug_usb(void){ 
.................... 	if(COM_sense() == USB_OK){ 
*
154A:  RCALL  1528
154C:  DECFSZ 01,W
154E:  BRA    155C
....................       output_bit(INDICADOR_USB, 1); 
1550:  BSF    F8D.1
1552:  BCF    F96.1
....................       return (1); 
1554:  MOVLW  01
1556:  MOVWF  01
1558:  BRA    1566
.................... 	}else{ 
155A:  BRA    1566
.................... 		output_bit(INDICADOR_USB, 0); 
155C:  BCF    F8D.1
155E:  BCF    F96.1
.................... 		return (0); 
1560:  MOVLW  00
1562:  MOVWF  01
1564:  BRA    1566
.................... 	} 
.................... } 
1566:  RETLW  00
.................... #endif 
....................  
....................  
.................... #include "configuracion.c" 
.................... #ifdef CONFIGURACION_H 
....................  
.................... void iniciar_perifericos(){ 
....................      
....................     #ifdef COMUNICACION_H 
....................     myerror = COM_init(); 
*
1E2E:  BRA    1B94
1E30:  MOVFF  01,9E
....................     //printf("\n\rusb E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef MEMORIA_H 
....................     MEMORIA_reset(); 
....................    myerror = MEMORIA_init_hw(); 
....................    myerror = MEMORIA_init(); 
....................    //printf("\n\rmem E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef ANALOGO_DIGITAL_H 
....................     myerror = AD_init_adc(); 
1E34:  BRA    1BA4
1E36:  MOVFF  01,9E
....................     #endif 
....................      
....................     #ifdef CAPTURA_FRECUENCIA_H 
....................     myerror = CP_init_ccp(); 
1E3A:  BRA    1BC6
1E3C:  MOVFF  01,9E
....................     #endif 
....................      
....................     #ifdef DS1307_H 
....................     ds1307_init(DS1307_OUT_ON_DISABLED_HIHG | DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
1E40:  MOVLW  90
1E42:  MOVLB  1
1E44:  MOVWF  xBB
1E46:  MOVLB  0
1E48:  BRA    1C24
....................    //ds1307_set_date_time(0x0d, 0x01, 0x0d, 0x00, 0x0a, 0x2a, 0x00); 
....................    CONF_CANAL_ACTIVO = ds1307_read_nvram_byte(CONF_DIR_CANAl); 
1E4A:  MOVLW  08
1E4C:  MOVLB  1
1E4E:  MOVWF  xBB
1E50:  MOVLB  0
1E52:  RCALL  1D8E
1E54:  MOVFF  01,9C
....................    //CONF_CANAL_ACTIVO = 0b00000000; 
....................     #endif 
....................      
....................    data.dia = data.mes = data.anio = 0; 
1E58:  CLRF   xE7
1E5A:  MOVFF  E7,E6
1E5E:  MOVFF  E6,E5
....................    data.hor = data.min = data.seg = 0; 
1E62:  CLRF   xEA
1E64:  MOVFF  EA,E9
1E68:  MOVFF  E9,E8
....................    data.value = data.sensor = data.no_data = 0; 
1E6C:  CLRF   xEC
1E6E:  MOVFF  EC,EB
1E72:  CLRF   xF0
1E74:  CLRF   xEF
1E76:  CLRF   xEE
1E78:  MOVFF  EB,ED
....................    data.crc = 0; 
1E7C:  CLRF   xF2
1E7E:  CLRF   xF1
....................     
.................... } 
1E80:  GOTO   1E86 (RETURN)
....................  
....................  
.................... int sensor_activo(int sensor){ 
....................     switch(sensor){ 
*
17E4:  MOVLB  2
17E6:  MOVF   x45,W
17E8:  XORLW  06
17EA:  MOVLB  0
17EC:  BZ    17FC
17EE:  XORLW  03
17F0:  BZ    1806
17F2:  XORLW  06
17F4:  BZ    1810
17F6:  XORLW  07
17F8:  BZ    181A
17FA:  BRA    1824
....................         case CCP_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_REV_BIT)); 
17FC:  MOVLW  00
17FE:  BTFSC  x9C.1
1800:  MOVLW  01
1802:  MOVWF  01
1804:  BRA    182A
....................         case CCP_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_VEL_BIT)); 
1806:  MOVLW  00
1808:  BTFSC  x9C.0
180A:  MOVLW  01
180C:  MOVWF  01
180E:  BRA    182A
....................         case AD_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_VEL_BIT)); 
1810:  MOVLW  00
1812:  BTFSC  x9C.3
1814:  MOVLW  01
1816:  MOVWF  01
1818:  BRA    182A
....................         case AD_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_REV_BIT)); 
181A:  MOVLW  00
181C:  BTFSC  x9C.4
181E:  MOVLW  01
1820:  MOVWF  01
1822:  BRA    182A
....................         default: 
....................             return (0); 
1824:  MOVLW  00
1826:  MOVWF  01
1828:  BRA    182A
....................     } 
.................... } 
182A:  RETLW  00
....................  
....................  
.................... void modo_configuracion(){ 
....................     //printf( cout "\n\rmodo configuracion\n\r" ); 
....................    while(_debug_usb()){ 
*
20D2:  CALL   154A
20D6:  MOVF   01,F
20D8:  BTFSC  FD8.2
20DA:  BRA    244C
....................             while(!(data.sensor = cin()));    //cambiar con usb 
20DC:  RCALL  1EFC
20DE:  MOVFF  01,EB
20E2:  MOVF   xEB,F
20E4:  BZ    20DC
....................             switch(data.sensor){ 
20E6:  MOVF   xEB,W
20E8:  XORLW  31
20EA:  BZ    210A
20EC:  XORLW  03
20EE:  BZ    2168
20F0:  XORLW  07
20F2:  BTFSC  FD8.2
20F4:  BRA    2382
20F6:  XORLW  03
20F8:  BTFSC  FD8.2
20FA:  BRA    23AE
20FC:  XORLW  05
20FE:  BTFSC  FD8.2
2100:  BRA    23DA
2102:  XORLW  07
2104:  BTFSC  FD8.2
2106:  BRA    2404
2108:  BRA    242E
....................                 case CONF_SET_FECHA: 
....................                     putc(CONF_SET_FECHA); 
210A:  MOVLW  31
210C:  MOVLB  1
210E:  MOVWF  xBB
2110:  MOVLB  0
2112:  RCALL  1F2C
....................                     //printf( cout "\n\rFECHA: %c", data.sensor); 
....................                     data.dia = cin(); 
2114:  RCALL  1EFC
2116:  MOVFF  01,E5
....................                     data.mes = cin(); 
211A:  RCALL  1EFC
211C:  MOVFF  01,E6
....................                     data.anio = cin(); 
2120:  RCALL  1EFC
2122:  MOVFF  01,E7
....................                     data.no_data = cin(); 
2126:  RCALL  1EFC
2128:  MOVFF  01,EC
....................                     data.hor = cin(); 
212C:  RCALL  1EFC
212E:  MOVFF  01,E8
....................                     data.min = cin(); 
2132:  RCALL  1EFC
2134:  MOVFF  01,E9
....................                     data.seg = cin(); 
2138:  RCALL  1EFC
213A:  MOVFF  01,EA
....................                     ds1307_set_date_time(data.dia, data.mes, data.anio, data.no_data,data.hor, data.min, data.seg); 
213E:  MOVFF  E5,1BB
2142:  MOVFF  E6,1BC
2146:  MOVFF  E7,1BD
214A:  MOVFF  EC,1BE
214E:  MOVFF  E8,1BF
2152:  MOVFF  E9,1C0
2156:  MOVFF  EA,1C1
215A:  BRA    1F6A
....................                     /*printf( cout "\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
....................                                 data.dia, data.mes, data.anio, 
....................                                 data.hor, data.min, data.seg, 
....................                                 data.sensor, data.no_data, data.value);*/ 
....................                     putc(CONF_ACK); 
215C:  MOVLW  06
215E:  MOVLB  1
2160:  MOVWF  xBB
2162:  MOVLB  0
2164:  RCALL  1F2C
....................                     break; 
2166:  BRA    2438
....................                 case CONF_GET_FECHA: 
....................                     putc(CONF_GET_FECHA); 
2168:  MOVLW  32
216A:  MOVLB  1
216C:  MOVWF  xBB
216E:  MOVLB  0
2170:  RCALL  1F2C
....................                     ds1307_get_date(data.dia, data.mes, data.anio, data.no_data); 
....................                     ds1307_get_time(data.hor, data.min, data.seg); 
....................                     putc(data.dia); 
*
234C:  MOVFF  E5,1BB
2350:  RCALL  1F2C
....................                     putc(data.mes); 
2352:  MOVFF  E6,1BB
2356:  RCALL  1F2C
....................                     putc(data.anio); 
2358:  MOVFF  E7,1BB
235C:  RCALL  1F2C
....................                     putc(data.no_data); 
235E:  MOVFF  EC,1BB
2362:  RCALL  1F2C
....................                     putc(data.hor); 
2364:  MOVFF  E8,1BB
2368:  RCALL  1F2C
....................                     putc(data.min); 
236A:  MOVFF  E9,1BB
236E:  RCALL  1F2C
....................                     putc(data.seg); 
2370:  MOVFF  EA,1BB
2374:  RCALL  1F2C
....................                     putc(CONF_ACK); 
2376:  MOVLW  06
2378:  MOVLB  1
237A:  MOVWF  xBB
237C:  MOVLB  0
237E:  RCALL  1F2C
....................                     break; 
2380:  BRA    2438
....................                 case CONF_SET_DATO: 
....................                     putc(CONF_SET_DATO); 
2382:  MOVLW  35
2384:  MOVLB  1
2386:  MOVWF  xBB
2388:  MOVLB  0
238A:  RCALL  1F2C
....................                     data.sensor = cin(); //lee la direccion 
238C:  RCALL  1EFC
238E:  MOVFF  01,EB
....................                     data.no_data = cin(); // lee el valor 
2392:  RCALL  1EFC
2394:  MOVFF  01,EC
....................                     ds1307_write_nvram_byte(data.sensor, data.no_data); 
2398:  MOVFF  EB,1BB
239C:  MOVFF  EC,1BC
23A0:  RCALL  204C
....................                     putc(CONF_ACK); 
23A2:  MOVLW  06
23A4:  MOVLB  1
23A6:  MOVWF  xBB
23A8:  MOVLB  0
23AA:  RCALL  1F2C
....................                     break; 
23AC:  BRA    2438
....................                 case CONF_GET_DATO: 
....................                     putc(CONF_GET_DATO); 
23AE:  MOVLW  36
23B0:  MOVLB  1
23B2:  MOVWF  xBB
23B4:  MOVLB  0
23B6:  RCALL  1F2C
....................                     data.sensor = cin(); //lee la direccion 
23B8:  RCALL  1EFC
23BA:  MOVFF  01,EB
....................                     data.no_data = ds1307_read_nvram_byte(data.sensor); //lee el valor de la ram 
23BE:  MOVFF  EB,1BB
23C2:  RCALL  1D8E
23C4:  MOVFF  01,EC
....................                     putc(data.no_data); 
23C8:  MOVFF  EC,1BB
23CC:  RCALL  1F2C
....................                     putc(CONF_ACK); 
23CE:  MOVLW  06
23D0:  MOVLB  1
23D2:  MOVWF  xBB
23D4:  MOVLB  0
23D6:  RCALL  1F2C
....................                     break; 
23D8:  BRA    2438
....................                 case CONF_SET_CANAL: 
....................                     putc(CONF_SET_CANAL); 
23DA:  MOVLW  33
23DC:  MOVLB  1
23DE:  MOVWF  xBB
23E0:  MOVLB  0
23E2:  RCALL  1F2C
....................                     data.no_data = cin(); 
23E4:  RCALL  1EFC
23E6:  MOVFF  01,EC
....................                     ds1307_write_nvram_byte(CONF_DIR_CANAL, data.no_data); 
23EA:  MOVLW  08
23EC:  MOVLB  1
23EE:  MOVWF  xBB
23F0:  MOVFF  EC,1BC
23F4:  MOVLB  0
23F6:  RCALL  204C
....................                     //printf( cout "\n\rCANAL: %u", data.no_data); 
....................                     putc(CONF_ACK); 
23F8:  MOVLW  06
23FA:  MOVLB  1
23FC:  MOVWF  xBB
23FE:  MOVLB  0
2400:  RCALL  1F2C
....................                     break; 
2402:  BRA    2438
....................                 case CONF_GET_CANAL: 
....................                     putc(CONF_GET_CANAL); 
2404:  MOVLW  34
2406:  MOVLB  1
2408:  MOVWF  xBB
240A:  MOVLB  0
240C:  RCALL  1F2C
....................                     data.no_data = ds1307_read_nvram_byte(CONF_DIR_CANAL); 
240E:  MOVLW  08
2410:  MOVLB  1
2412:  MOVWF  xBB
2414:  MOVLB  0
2416:  RCALL  1D8E
2418:  MOVFF  01,EC
....................                     putc(data.no_data); 
241C:  MOVFF  EC,1BB
2420:  RCALL  1F2C
....................                     putc(CONF_ACK); 
2422:  MOVLW  06
2424:  MOVLB  1
2426:  MOVWF  xBB
2428:  MOVLB  0
242A:  RCALL  1F2C
....................                     break; 
242C:  BRA    2438
....................                 default: 
....................                     putc(CONF_NOACK); 
242E:  MOVLW  15
2430:  MOVLB  1
2432:  MOVWF  xBB
2434:  MOVLB  0
2436:  RCALL  1F2C
....................             } 
....................             if(data.sensor == CONF_SALIR) {printf( cout "\n\rDesconectar...");break;} 
2438:  MOVF   xEB,W
243A:  SUBLW  39
243C:  BNZ   244A
243E:  MOVLW  7C
2440:  MOVWF  FF6
2442:  MOVLW  1B
2444:  MOVWF  FF7
2446:  BRA    20AE
2448:  BRA    244C
....................     } 
244A:  BRA    20D2
....................     return; 
.................... } 
244C:  GOTO   263E (RETURN)
....................  
.................... #endif    //CONFIGURACION_H 
....................  
....................  

Configuration Fuses:
   Word  1: CE3C   IESO FCMEN HSPLL PLL5 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
