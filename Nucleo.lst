CCS PCH C Compiler, Version 4.105, 13255               21-Ago-12 15:08

               Filename: G:\Project\pic\CCS\MMA7455l\Nucleo.lst

               ROM used: 1210 bytes (2%)
                         Largest free fragment is 64322
               RAM used: 58 (1%) at main() level
                         87 (2%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
00000:  GOTO   03C6
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FA0.1
00056:  GOTO   0060
0005A:  BTFSC  FA1.1
0005C:  GOTO   00C6
00060:  BTFSS  F9D.2
00062:  GOTO   006C
00066:  BTFSC  F9E.2
00068:  GOTO   00CE
0006C:  BTFSS  FA0.0
0006E:  GOTO   0078
00072:  BTFSC  FA1.0
00074:  GOTO   0126
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVF   04,W
000BC:  MOVFF  06,FE0
000C0:  MOVFF  05,FD8
000C4:  RETFIE 0
....................  
.................... #include "Nucleo.h" 
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "accelerometro.h" 
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int x; 
....................     int y; 
....................     int z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, long *buffer); 
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
....................  
.................... extern CONFIG_MMA7455 CONFIG; 
.................... extern unsigned int32 tiempo_inicial, tiempo_final; 
.................... void setup_devices(){ 
*
001D6:  MOVLW  FF
001D8:  MOVWF  3A
....................    int error = -1; 
....................    /////////////configuracion del MMA7455//////////////// 
....................    //error = init_MMA(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = AD_init_adc(); 
....................    ////////////////////////////////////////////////////// 
....................    error = CP_init_ccp(); 
001DA:  BRA    01A0
001DC:  MOVFF  01,3A
....................    setup_psp(PSP_DISABLED); 
001E0:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
001E2:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
001E4:  MOVLW  80
001E6:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
001E8:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
001EA:  MOVLW  00
001EC:  MOVWF  FCA
001EE:  MOVLW  00
001F0:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_ccp1(CCP_OFF); 
....................    setup_comparator(NC_NC_NC_NC); 
001F2:  MOVLW  07
001F4:  MOVWF  FB4
001F6:  MOVF   F92,W
001F8:  MOVWF  F92
001FA:  MOVLW  08
001FC:  MOVWF  00
001FE:  DECFSZ 00,F
00200:  BRA    01FE
00202:  MOVF   FB4,W
00204:  BCF    FA1.6
....................    setup_vref(FALSE); 
00206:  CLRF   FB5
....................    return; 
.................... } 
00208:  GOTO   0444 (RETURN)
....................  
.................... void main() 
.................... { 
*
003C6:  CLRF   FF8
003C8:  BCF    FD0.7
003CA:  BSF    07.7
003CC:  CLRF   FEA
003CE:  CLRF   FE9
003D0:  BCF    FB8.3
003D2:  MOVLW  40
003D4:  MOVWF  FAF
003D6:  MOVLW  A6
003D8:  MOVWF  FAC
003DA:  MOVLW  90
003DC:  MOVWF  FAB
003DE:  BSF    F94.3
003E0:  BSF    F94.4
003E2:  MOVLW  18
003E4:  MOVWF  FC8
003E6:  MOVLW  28
003E8:  MOVWF  FC6
003EA:  BSF    FC7.7
003EC:  BCF    FC7.6
003EE:  MOVLW  05
003F0:  MOVWF  28
003F2:  MOVWF  29
003F4:  MOVLW  FF
003F6:  MOVWF  2A
003F8:  MOVLW  CD
003FA:  MOVWF  2B
003FC:  CLRF   2C
003FE:  CLRF   30
00400:  CLRF   2F
00402:  CLRF   2E
00404:  CLRF   2D
00406:  CLRF   34
00408:  CLRF   33
0040A:  CLRF   32
0040C:  CLRF   31
0040E:  MOVF   FC1,W
00410:  ANDLW  C0
00412:  IORLW  0F
00414:  MOVWF  FC1
00416:  MOVLW  07
00418:  MOVWF  FB4
0041A:  CLRF   19
0041C:  CLRF   1A
0041E:  MOVLW  01
00420:  MOVWF  1F
00422:  MOVLW  02
00424:  MOVWF  20
00426:  MOVLW  03
00428:  MOVWF  21
0042A:  MOVLW  80
0042C:  MOVWF  22
0042E:  MOVWF  23
00430:  MOVWF  24
00432:  MOVWF  25
00434:  MOVWF  26
00436:  MOVWF  27
00438:  CLRF   38
0043A:  CLRF   37
0043C:  CLRF   36
0043E:  CLRF   35
00440:  CLRF   39
....................    int32 value = 0; 
....................    int error = 0; 
....................    setup_devices(); 
00442:  BRA    01D6
....................    // TODO: USER CODE!!   
....................    while(error == 0){ 
00444:  MOVF   39,F
00446:  BNZ   04BC
....................       error = CP_leer_ccp(CANAL_2, &value); 
00448:  MOVLW  02
0044A:  MOVWF  3A
0044C:  CLRF   3C
0044E:  MOVLW  35
00450:  MOVWF  3B
00452:  BRA    020C
00454:  MOVFF  01,39
....................       printf("%Lu,%Lu,%Lu\n\r", tiempo_inicial,tiempo_final, value); 
00458:  MOVLW  41
0045A:  MOVWF  FE9
0045C:  MOVFF  30,3D
00460:  MOVFF  2F,3C
00464:  MOVFF  2E,3B
00468:  MOVFF  2D,3A
0046C:  RCALL  031A
0046E:  MOVLW  2C
00470:  BTFSS  F9E.4
00472:  BRA    0470
00474:  MOVWF  FAD
00476:  MOVLW  41
00478:  MOVWF  FE9
0047A:  MOVFF  34,3D
0047E:  MOVFF  33,3C
00482:  MOVFF  32,3B
00486:  MOVFF  31,3A
0048A:  RCALL  031A
0048C:  MOVLW  2C
0048E:  BTFSS  F9E.4
00490:  BRA    048E
00492:  MOVWF  FAD
00494:  MOVLW  41
00496:  MOVWF  FE9
00498:  MOVFF  38,3D
0049C:  MOVFF  37,3C
004A0:  MOVFF  36,3B
004A4:  MOVFF  35,3A
004A8:  RCALL  031A
004AA:  MOVLW  0A
004AC:  BTFSS  F9E.4
004AE:  BRA    04AC
004B0:  MOVWF  FAD
004B2:  MOVLW  0D
004B4:  BTFSS  F9E.4
004B6:  BRA    04B4
004B8:  MOVWF  FAD
....................       //delay_ms(250); 
....................    } 
004BA:  BRA    0444
.................... } 
....................  
....................  
.................... #include "Nucleo.h" 
.................... #include <18F4620.h> 
004BC:  SLEEP 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
....................  
.................... #include "accelerometro.h"  
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int x; 
....................     int y; 
....................     int z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
....................  
.................... CONFIG_MMA7455 CONFIG = {1,2,3,128,128,128,128,128,128}; 
.................... //configuracion inicial del MMA7455 
.................... int init_MMA(void){ 
....................   int error = 0; 
....................   xyz_union xyz; 
....................   unsigned int8 c1 = 0, c2 = 0; 
....................    
....................   //mode: measurement; sensitivity: 4g 
....................   c1 = MMA7455_GLVL1 | MMA7455_MODE0; 
....................   error = write_MMA(MMA7455_MCTL, &c1);       //escribe la configuracion deseada en el accelerometro 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //lee la configuracion del accelerometro para comprobar el envio 
....................   error = read_MMA(MMA7455_MCTL, &c2); 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //se comprueban la conincidencia entre lo enviado y lo recivido 
....................   if (c1 != c2) 
....................     return (-99);                 //retorna -99 si no cinciden 
....................   else 
....................     CONFIG.MODE_CONTROL =  c2;    //se respalda la configuracion en el micro 
....................  
....................   //se configura el offset de los ejes a 0 
....................   xyz.value.x = xyz.value.y = xyz.value.z = 0; 
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   delay_ms(100);                  //espera 100 mls para hasta se hayan escrito todos lso datos 
....................   return 0; 
.................... } 
....................  
.................... /** 
.................... para la calibracion de los ejes se supone que este 
.................... en una posicion nivelada horizontalmente evitando posible vibraciones 
.................... */ 
.................... int calibrate_MMA(void){ 
....................   int x, y, z, error = 0; 
....................   xyz_union xyz; 
....................   unsigned int8 c1 = 0, c2 = 0; 
....................  
....................   c1 = (CONFIG.MODE_CONTROL & (MMA7455_GLVL1|MMA7455_GLVL0));   //selecciona los bit de GLVL 
....................   if(c1 == (MMA7455_GLVL0 | MMA7455_GLVL1)){  // si es 8g 
....................     c2 = 16; 
....................   }else if(c1 == MMA7455_GLVL1){ //si es 4g 
....................     c2 = 32; 
....................   }else if(c1 == MMA7455_GLVL0){ //si es 2g 
....................     c2 = 64; 
....................   }else{ 
....................     c2 = 64;  //por defecto 2g 
....................   } 
....................  
....................   error = xyz_MMA(&x, &y, &z);    //se leen los valores de los ejes 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //calcula offset para el ajuste a 0 de los ejes 
....................   xyz.value.x = 2 * -x;         
....................   xyz.value.y = 2 * -y; 
....................   xyz.value.z = 2 * -(z-c2); 
....................  
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6);  //se envia el offset al accelerometro 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   delay_ms(200); 
....................    
....................   error = xyz_MMA(&x, &y, &z); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   //realiza nuevamente la operacion para el reajuste 
....................   xyz.value.x = 2 * -x;         
....................   xyz.value.y = 2 * -y; 
....................   xyz.value.z = 2 * -(z-c2); 
....................  
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   //leen los datos enviados al accelerometro para almacenarlos en el microcontrolador 
....................   error = read_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   CONFIG.XOFFL = xyz.reg.x_lsb; 
....................   CONFIG.XOFFH = xyz.reg.x_msb; 
....................   CONFIG.YOFFL = xyz.reg.x_lsb; 
....................   CONFIG.YOFFH = xyz.reg.x_msb; 
....................   CONFIG.ZOFFL = xyz.reg.x_lsb; 
....................   CONFIG.ZOFFH = xyz.reg.x_msb; 
....................  
....................   return 0; 
.................... } 
....................  
.................... void set_config(*CONFIG_MMA7455){ 
....................  return; 
.................... }// cambiar la configuracion incicial (del SPI y/o MMA) 
....................  
....................  
.................... int xyz_MMA( int *pX, int *pY, int *pZ){ 
....................   xyz_union xyz; 
....................   int error = 0; 
....................   unsigned int8 c; 
....................  
....................   do{ 
....................  
....................     error = read_MMA(MMA7455_STATUS,&c); 
....................   }while(!bit_test(c, 0) && error == 0); 
....................    
....................   if (error != 0) 
....................     return (error); 
....................  
....................   error = read_MMA(MMA7455_XOUTL, (unsigned int8 *)&xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   // The output is 10-bits and could be negative. 
....................   // To use the output as a 16-bit signed integer, 
....................   // the sign bit (bit 9) is extended for the 16 bits. 
....................   if (xyz.reg.x_msb & 0x02)    // Bit 9 is sign bit. 
....................     xyz.reg.x_msb |= 0xFC;     // Stretch bit 9 over other bits. 
....................   if (xyz.reg.y_msb & 0x02) 
....................     xyz.reg.y_msb |= 0xFC; 
....................   if (xyz.reg.z_msb & 0x02) 
....................     xyz.reg.z_msb |= 0xFC; 
....................  
....................   // The result is the g-force in units of 64 per 'g'. 
....................   *pX = xyz.value.x; 
....................   *pY = xyz.value.y; 
....................   *pZ = xyz.value.z; 
....................  
....................   return 0; 
.................... } 
.................... /*///////////////////////////////////////////// 
.................... read_MMA(): funcion para la lectura de datos desde el accelerometro MMA7455 
....................             hasta el dispositivo maestro 
.................... parametros: 
....................   start: direccion de inicial desde se realizara la lectura 
....................   buffer: buffer de almacenamiento de los datos leidos 
....................   size: cantidad de bytes a leer desde el esclavo 
....................  
.................... returna: 
....................   int: 0 no error,  
....................       1 error de inicio de transmision,  
....................       2 error de peticion de datos, 
....................       -11 error en la lectura desde el MMA  
.................... */ 
.................... int read_MMA(unsigned char address, int8 *value){ 
....................   int error = 0; 
....................    //condicion de inicio de lectura en el MMA7455  
....................   #ifdef testmma 
....................   while(!ext_eeprom_ready()); 
....................   #endif 
....................  
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(address);                     //envia el registro inicial de lectura del MMA 
....................   if(error!=0){return 1;}                         //si existe un error sale de la funcion 
....................    
....................   //peticion de datos desde el MMA7455 
....................   i2c_start();                                    //seal de restart del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_READ);    //se envia la direccion del MMA7455 con lectura   
....................   if(error!=0){return 2;} 
....................   #ifndef testmma  
....................   while(!i2c_poll()); 
....................   #endif 
....................   *value = i2c_read(0); 
....................   i2c_stop(); 
....................   return 0; 
.................... } 
....................  
.................... int read_MMA(unsigned char start_address, unsigned int8 *buffer,int size){ 
....................   int error = 0, i = 0; 
....................   int1 ack = 1; 
....................    
....................   #ifdef testmma 
....................   while(!ext_eeprom_ready()); 
....................   #endif 
....................  
....................   //condicion de inicio de lectura en el MMA7455  
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(start_address);               //envia el registro inicial de lectura del MMA 
....................   if(error!=0){return 1;}                         //si existe un error sale de la funcion 
....................    
....................   //peticion de datos desde el MMA7455 
....................   i2c_start();                                    //seal de restart del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_READ);    //se envia la direccion del MMA7455 con lectura   
....................   if(error!=0){return 2;}                         //si error en reques sale de la funcion 
....................  
....................   i = 0; 
....................   ack = 1; 
....................   while(i2c_poll() && i<size){                    //espera minetras llega un dato desde el MMA7455 
....................     if((i+1) >= size){ack = 0;}                   //si es el ultimo byte envia NACK 
....................     buffer[i++]=i2c_read(ack);                    //lee un byte del bus i2c y envia un ACK 
....................   } 
....................  
....................   i2c_stop();                                     //seal de stop en el bus i2c 
....................    
....................   if ( i != size){return (3);}                    //retorna 3 si no se completo la lectura 
....................    
....................   return (0);   //retorna 0 si succed 
.................... } //leer datos desde el mma 
....................  
....................  
.................... int write_MMA(unsigned char address, int8 *value){ 
....................   int error = 0; 
....................   //condicion de inicio de escritura en el MMA7455 
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(address);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 1;} 
....................   error = i2c_write(*value);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 2;} 
....................   i2c_stop(); 
....................   return 0; 
.................... } 
....................  
....................  
.................... int write_MMA(unsigned char start_address, int8 *pData, int size){ 
....................   int error = 0, i = 0; 
....................   int1 ack = 0; 
....................  
....................   //condicion de inicio de escritura en el MMA7455 
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(start_address);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 1;}                         //si error en reques sale de la funcion 
....................    
....................   do{ 
....................     ack = i2c_write(pData[i++]);                  //escribe un byte y espera un ACK 
....................   }while(ack == 0 && i < size); 
....................    
....................   i2c_stop(); 
....................   if(i != size){return 2;}                        //si no se completo la escritura retorna error 2 
....................   return 0;                                       //retorna 0 si succed 
.................... } //escribir datos desde el mma 
....................  
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready() { 
....................   int1 ack; 
....................   i2c_start();            // If the write command is acknowledged, 
....................   ack = i2c_write(0xa0);  // then the device is ready. 
....................   i2c_stop(); 
....................   return !ack; 
.................... } 
.................... #endif 
....................  
.................... #include "Nucleo.h" 
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, long *buffer); 
.................... #endif 
....................  
....................  
....................  
.................... int AD_init_adc(){ 
.................... 	setup_adc_ports(AN0_TO_AN2); 
....................  
.................... //corregir despues 
.................... #if getenv("CLOCK") == 4000000 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 8000000 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 10000000 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 20000000 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #endif 
.................... 	set_tris_a(0x07);		//RB0 y RB1 entradas 
.................... 	return 0; 
.................... } 
....................  
.................... int AD_leer_canal(int canal, long *buffer){ 
.................... 	set_adc_channel(canal); 
.................... 	read_adc(ADC_START_ONLY); 
.................... 	int1 done = adc_done(); 
.................... 	while(!done){ 
.................... 		done = adc_done(); 
.................... 	} 
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
.................... 	return 0; 
.................... } 
....................  
.................... #include "Nucleo.h" 
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_1|T3_CCP1_TO_2; 
....................  
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
000C6:  INCF   2C,F
.................... } 
....................  
000C8:  BCF    FA1.1
000CA:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == 0){ 
000CE:  MOVF   2A,F
000D0:  BNZ   00F6
....................       Q_CCP = 1; 
000D2:  MOVLW  01
000D4:  MOVWF  2A
....................       tiempo_inicial = (65536*overflow_t3_counter)+(unsigned)CCP_1; 
000D6:  CLRF   01
000D8:  CLRF   53
000DA:  CLRF   54
000DC:  MOVF   FBE,W
000DE:  ADDWF  53,W
000E0:  MOVWF  2D
000E2:  MOVLW  00
000E4:  ADDWFC 54,W
000E6:  MOVWF  2E
000E8:  MOVLW  00
000EA:  ADDWFC 2C,W
000EC:  MOVWF  2F
000EE:  MOVLW  00
000F0:  ADDWFC 01,W
000F2:  MOVWF  30
....................    }else if(Q_CCP == 1){ 
000F4:  BRA    0120
000F6:  DECFSZ 2A,W
000F8:  BRA    0120
....................    	disable_interrupts(INT_TIMER3); 
000FA:  BCF    FA0.1
....................       disable_interrupts(INT_CCP1);       
000FC:  BCF    F9D.2
....................       Q_CCP = 2; 
000FE:  MOVLW  02
00100:  MOVWF  2A
....................       tiempo_final = (65536*overflow_t3_counter)+(unsigned)CCP_1; 
00102:  CLRF   01
00104:  CLRF   53
00106:  CLRF   54
00108:  MOVF   FBE,W
0010A:  ADDWF  53,W
0010C:  MOVWF  31
0010E:  MOVLW  00
00110:  ADDWFC 54,W
00112:  MOVWF  32
00114:  MOVLW  00
00116:  ADDWFC 2C,W
00118:  MOVWF  33
0011A:  MOVLW  00
0011C:  ADDWFC 01,W
0011E:  MOVWF  34
....................    } 
.................... } 
....................  
00120:  BCF    F9E.2
00122:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    /*if(Q_CCP == 0){ 
....................       Q_CCP = 1; 
....................       //tiempo_inicial = CCP_2; 
....................       tiempo_inicial = (0x10000*overflow_t3_counter)+CCP_2; 
....................    }else if(Q_CCP == 1){ 
....................       disable_interrupts(INT_TIMER3); 
....................       disable_interrupts(INT_CCP2);       
....................       Q_CCP = 2; 
....................       //tiempo_final = CCP_2; 
....................       tiempo_final = (0x10000*overflow_t3_counter)+CCP_2; 
....................    }*/ 
....................    if(Q_CCP == -1){ 
00126:  MOVF   2A,W
00128:  SUBLW  FF
0012A:  BNZ   013C
....................    	setup_ccp1(CCP_CAPTURE_FE); 
0012C:  BSF    F94.2
0012E:  CLRF   FBD
00130:  MOVLW  04
00132:  MOVWF  FBD
00134:  CLRF   FB7
00136:  CLRF   FB6
....................    	Q_CCP = 0; 
00138:  CLRF   2A
....................    }else if(Q_CCP == 0){ 
0013A:  BRA    019A
0013C:  MOVF   2A,F
0013E:  BNZ   0164
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
00140:  CLRF   01
00142:  CLRF   53
00144:  CLRF   54
00146:  MOVF   FBB,W
00148:  ADDWF  53,W
0014A:  MOVWF  31
0014C:  MOVF   FBC,W
0014E:  ADDWFC 54,W
00150:  MOVWF  32
00152:  MOVLW  00
00154:  ADDWFC 2C,W
00156:  MOVWF  33
00158:  MOVLW  00
0015A:  ADDWFC 01,W
0015C:  MOVWF  34
....................    	Q_CCP = 1; 
0015E:  MOVLW  01
00160:  MOVWF  2A
....................    }else if(Q_CCP == 1){ 
00162:  BRA    019A
00164:  DECFSZ 2A,W
00166:  BRA    019A
....................    	tiempo_inicial = tiempo_final; 
00168:  MOVFF  34,30
0016C:  MOVFF  33,2F
00170:  MOVFF  32,2E
00174:  MOVFF  31,2D
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
00178:  CLRF   01
0017A:  CLRF   53
0017C:  CLRF   54
0017E:  MOVF   FBB,W
00180:  ADDWF  53,W
00182:  MOVWF  31
00184:  MOVF   FBC,W
00186:  ADDWFC 54,W
00188:  MOVWF  32
0018A:  MOVLW  00
0018C:  ADDWFC 2C,W
0018E:  MOVWF  33
00190:  MOVLW  00
00192:  ADDWFC 01,W
00194:  MOVWF  34
....................    	Q_CCP = 2; 
00196:  MOVLW  02
00198:  MOVWF  2A
....................    } 
....................     
.................... } 
....................  
0019A:  BCF    FA1.0
0019C:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
001A0:  MOVFF  2B,FB1
....................    T3CON.TMR3ON = 0; 
001A4:  BCF    FB1.0
....................    set_timer3(0); 
001A6:  CLRF   FB3
001A8:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
001AA:  MOVF   28,W
001AC:  ANDLW  08
001AE:  BTFSC  FD8.2
001B0:  BCF    F82.2
001B2:  CLRF   FBD
001B4:  MOVFF  28,FBD
001B8:  CLRF   FB7
001BA:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
001BC:  MOVF   29,W
001BE:  ANDLW  08
001C0:  BTFSC  FD8.2
001C2:  BCF    F82.1
001C4:  CLRF   FBA
001C6:  MOVFF  29,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1  ;                        
001CA:  BSF    F94.2
001CC:  BSF    F94.1
....................    return 0; 
001CE:  MOVLW  00
001D0:  MOVWF  01
.................... } 
001D2:  GOTO   01DC (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
*
0020C:  CLRF   40
0020E:  CLRF   3F
00210:  CLRF   3E
00212:  CLRF   3D
....................    //CODIGO DE MANEJO DE CCP 
....................    int32 resultado = 0; 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
00214:  MOVLW  C0
00216:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
00218:  BSF    FA0.1
....................    set_timer3(0);      					//se reset timer  a 0 
0021A:  CLRF   FB3
0021C:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
0021E:  BSF    FB1.0
....................    if(canal == CANAL_1){ 
00220:  DECFSZ 3A,W
00222:  BRA    0228
....................       enable_interrupts(INT_CCP1);   //si es el canal 1 se habilita la interrupcion del modulo CCP1 
00224:  BSF    F9D.2
....................    }else if(canal == CANAL_2){ 
00226:  BRA    0238
00228:  MOVF   3A,W
0022A:  SUBLW  02
0022C:  BNZ   0232
....................       enable_interrupts(INT_CCP2);   //si es el canal 2 se habilita la interrupcion del modulo CCP2 
0022E:  BSF    FA0.0
....................    }else{return (1);} 
00230:  BRA    0238
00232:  MOVLW  01
00234:  MOVWF  01
00236:  BRA    029C
....................    while(Q_CCP != 2){;}             //espera a que se carguen los valores de los tiempos 
00238:  MOVF   2A,W
0023A:  SUBLW  02
0023C:  BZ    0240
0023E:  BRA    0238
....................    disable_interrupts(INT_CCP1); 
00240:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
00242:  BCF    FA0.0
....................    setup_ccp2(MODO_CCP1); 
00244:  MOVF   28,W
00246:  ANDLW  08
00248:  BTFSC  FD8.2
0024A:  BCF    F82.1
0024C:  CLRF   FBA
0024E:  MOVFF  28,FBA
....................    setup_ccp2(MODO_CCP2); 
00252:  MOVF   29,W
00254:  ANDLW  08
00256:  BTFSC  FD8.2
00258:  BCF    F82.1
0025A:  CLRF   FBA
0025C:  MOVFF  29,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
00260:  MOVLW  FF
00262:  MOVWF  2A
....................    resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
00264:  MOVF   2D,W
00266:  SUBWF  31,W
00268:  MOVWF  3D
0026A:  MOVF   2E,W
0026C:  SUBWFB 32,W
0026E:  MOVWF  3E
00270:  MOVF   2F,W
00272:  SUBWFB 33,W
00274:  MOVWF  3F
00276:  MOVF   30,W
00278:  SUBWFB 34,W
0027A:  MOVWF  40
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
0027C:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
0027E:  CLRF   2C
....................    *buffer = resultado; 
00280:  MOVFF  3B,FE9
00284:  MOVFF  3C,FEA
00288:  MOVFF  3D,FEF
0028C:  MOVFF  3E,FEC
00290:  MOVFF  3F,FEC
00294:  MOVFF  40,FEC
....................    return (0); 
00298:  MOVLW  00
0029A:  MOVWF  01
.................... } 
0029C:  GOTO   0454 (RETURN)

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
