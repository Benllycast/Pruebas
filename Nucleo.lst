CCS PCH C Compiler, Version 4.105, 13255               17-Oct-12 11:26

               Filename: G:\Project\pic\CCS\MMA7455l\Nucleo.lst

               ROM used: 6340 bytes (19%)
                         Largest free fragment is 26424
               RAM used: 181 (9%) at main() level
                         209 (10%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  GOTO   1730
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   0180
0060:  BTFSS  F9D.2
0062:  GOTO   006C
0066:  BTFSC  F9E.2
0068:  GOTO   0188
006C:  BTFSS  FA0.0
006E:  GOTO   0078
0072:  BTFSC  FA1.0
0074:  GOTO   0202
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
*
1706:  CLRF   FEA
1708:  MOVLW  B5
170A:  MOVWF  FE9
170C:  MOVF   FEF,W
170E:  BZ    172C
1710:  MOVLW  07
1712:  MOVWF  01
1714:  CLRF   00
1716:  DECFSZ 00,F
1718:  BRA    1716
171A:  DECFSZ 01,F
171C:  BRA    1714
171E:  MOVLW  C7
1720:  MOVWF  00
1722:  DECFSZ 00,F
1724:  BRA    1722
1726:  NOP   
1728:  DECFSZ FEF,F
172A:  BRA    1710
172C:  GOTO   18C0 (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
*
02D0:  MOVLW  08
02D2:  MOVWF  01
02D4:  MOVLW  07
02D6:  MOVWF  00
02D8:  DECFSZ 00,F
02DA:  BRA    02D8
02DC:  BCF    F8A.1
02DE:  BCF    F93.1
02E0:  MOVLW  07
02E2:  MOVWF  00
02E4:  DECFSZ 00,F
02E6:  BRA    02E4
02E8:  RLCF   xB8,F
02EA:  BCF    F8A.0
02EC:  BTFSC  FD8.0
02EE:  BSF    F93.0
02F0:  BTFSS  FD8.0
02F2:  BCF    F93.0
02F4:  BSF    F93.1
02F6:  BTFSS  F81.1
02F8:  BRA    02F6
02FA:  DECFSZ 01,F
02FC:  BRA    02D4
02FE:  MOVLW  07
0300:  MOVWF  00
0302:  DECFSZ 00,F
0304:  BRA    0302
0306:  BCF    F8A.1
0308:  BCF    F93.1
030A:  NOP   
030C:  BSF    F93.0
030E:  MOVLW  07
0310:  MOVWF  00
0312:  DECFSZ 00,F
0314:  BRA    0312
0316:  MOVLW  07
0318:  MOVWF  00
031A:  DECFSZ 00,F
031C:  BRA    031A
031E:  BSF    F93.1
0320:  BTFSS  F81.1
0322:  BRA    0320
0324:  CLRF   01
0326:  MOVLW  07
0328:  MOVWF  00
032A:  DECFSZ 00,F
032C:  BRA    032A
032E:  BTFSC  F81.0
0330:  BSF    01.0
0332:  BCF    F8A.1
0334:  BCF    F93.1
0336:  BCF    F8A.0
0338:  BCF    F93.0
033A:  RETLW  00
033C:  MOVLW  08
033E:  MOVWF  xB9
0340:  MOVFF  00,BA
0344:  BSF    F93.0
0346:  MOVLW  07
0348:  MOVWF  00
034A:  DECFSZ 00,F
034C:  BRA    034A
034E:  BSF    F93.1
0350:  BTFSS  F81.1
0352:  BRA    0350
0354:  BTFSC  F81.0
0356:  BSF    FD8.0
0358:  BTFSS  F81.0
035A:  BCF    FD8.0
035C:  RLCF   01,F
035E:  MOVLW  07
0360:  MOVWF  00
0362:  DECFSZ 00,F
0364:  BRA    0362
0366:  BCF    F93.1
0368:  BCF    F8A.1
036A:  DECFSZ xB9,F
036C:  BRA    0344
036E:  BSF    F93.0
0370:  MOVLW  07
0372:  MOVWF  00
0374:  DECFSZ 00,F
0376:  BRA    0374
0378:  BCF    F8A.0
037A:  MOVF   xBA,W
037C:  BTFSS  FD8.2
037E:  BCF    F93.0
0380:  NOP   
0382:  BSF    F93.1
0384:  BTFSS  F81.1
0386:  BRA    0384
0388:  MOVLW  07
038A:  MOVWF  00
038C:  DECFSZ 00,F
038E:  BRA    038C
0390:  BCF    F8A.1
0392:  BCF    F93.1
0394:  MOVLW  07
0396:  MOVWF  00
0398:  DECFSZ 00,F
039A:  BRA    0398
039C:  BCF    F8A.0
039E:  BCF    F93.0
03A0:  RETLW  00
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_OK	0 
.................... #define USB_NO_ENUMERATED 1 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... #endif 
....................  
.................... #include "accelerometro.h" 
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int16 x; 
....................     int16 y; 
....................     int16 z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, int16 *buffer); 
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD	0x55 
.................... #define MEMORIA_CMD_VER_INFO	0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD			0x40 
.................... #define MEMORIA_CMD_READ_FILE	0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK 		0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON 			0x01 
.................... #define MEMORIA_OFF 		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT	12 
.................... #define MEMORIA_NAME_TERMINATOR 0x00 
.................... #define MEMORIA_DELIMITADOR 	0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE 	0x00 
.................... #define MEMORIA_LOW_PERFORMANCE 	0x40 
.................... //#define MEMORIA_OUT_TIME	65535	//modificar para colocar tiempos mas largos 
.................... //#define MEMORIA_COMPROBAR_ARCHIVO 
....................  
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char *filename, char modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char *data, unsigned int size); 
.................... char MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char *buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define MAX 40; 
.................... //extern CONFIG_MMA7455 CONFIG; 
.................... //extern unsigned int32 tiempo_inicial, tiempo_final; 
.................... byte hr = 0, min = 0, sec = 0, dia = 0, mes = 0, anio = 0, dow = 0; 
.................... int16 valor_16b; 
.................... int32 valor_32b; 
....................  
.................... char mensaje[40]; 
.................... enum modulos {ACC,VEL,REV,ACCM,SENP,CCP1,CCP2}; 
.................... char * mod_to_str(unsigned int8); 
.................... void leer_aceleracion(void); 
.................... void leer_velocidad(void); 
.................... void leer_revoluciones(void); 
.................... void leer_accelerometro(void); 
.................... void leer_sensor_puertas(void); 
.................... void leer_ccp1(void); 
.................... void leer_ccp2(void); 
....................  
.................... void setup_devices(){ 
*
064E:  MOVLW  FF
0650:  MOVWF  xB4
....................    int error = -1; 
....................    /////////////configuracion del MMA7455//////////////// 
....................    //error = init_MMA(); 
....................    ////////////////////////////////////////////////////// 
....................    error = AD_init_adc(); 
0652:  BRA    027C
0654:  MOVFF  01,B4
....................    ////////////////////////////////////////////////////// 
....................    error = CP_init_ccp(); 
0658:  BRA    029A
065A:  MOVFF  01,B4
....................    ////////////////////////////////////////////////////// 
....................    //error = MEMORIA_init(); 
....................    ////////////////////////////////////////////////////// 
....................    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
065E:  MOVLW  10
0660:  MOVWF  xB5
0662:  BRA    03EE
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    //error = COM_init(); 
....................    ////////////////////////////////////////////////////// 
....................    setup_psp(PSP_DISABLED); 
0664:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
0666:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
0668:  MOVLW  80
066A:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
066C:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
066E:  MOVLW  00
0670:  MOVWF  FCA
0672:  MOVLW  00
0674:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_ccp1(CCP_OFF); 
....................    setup_comparator(NC_NC_NC_NC); 
0676:  MOVLW  07
0678:  MOVWF  FB4
067A:  MOVF   F92,W
067C:  MOVWF  F92
067E:  MOVLW  13
0680:  MOVWF  00
0682:  DECFSZ 00,F
0684:  BRA    0682
0686:  BRA    0688
0688:  MOVF   FB4,W
068A:  BCF    FA1.6
....................    setup_vref(FALSE); 
068C:  CLRF   FB5
....................    printf("usb error =%d\n\r", error); 
068E:  MOVLW  C6
0690:  MOVWF  FF6
0692:  MOVLW  00
0694:  MOVWF  FF7
0696:  MOVLW  0B
0698:  MOVWF  xB5
069A:  BRA    0532
069C:  MOVFF  B4,B5
06A0:  MOVLW  1F
06A2:  MOVWF  xB6
06A4:  BRA    057C
06A6:  MOVLW  0A
06A8:  BTFSS  F9E.4
06AA:  BRA    06A8
06AC:  MOVWF  FAD
06AE:  MOVLW  0D
06B0:  BTFSS  F9E.4
06B2:  BRA    06B0
06B4:  MOVWF  FAD
....................    return; 
.................... } 
06B6:  GOTO   18A6 (RETURN)
....................  
.................... void main() 
.................... { 
*
1730:  CLRF   FF8
1732:  BCF    FD0.7
1734:  BSF    07.7
1736:  CLRF   FEA
1738:  CLRF   FE9
173A:  BSF    FB8.3
173C:  MOVLW  70
173E:  MOVWF  FAF
1740:  MOVLW  02
1742:  MOVWF  FB0
1744:  MOVLW  A6
1746:  MOVWF  FAC
1748:  MOVLW  90
174A:  MOVWF  FAB
174C:  CLRF   1B
174E:  CLRF   1C
1750:  CLRF   1D
1752:  CLRF   1E
1754:  CLRF   1F
1756:  CLRF   20
1758:  CLRF   21
175A:  BSF    FB8.3
175C:  MOVLW  70
175E:  MOVWF  FAF
1760:  MOVLW  02
1762:  MOVWF  FB0
1764:  MOVLW  A6
1766:  MOVWF  FAC
1768:  MOVLW  90
176A:  MOVWF  FAB
176C:  MOVLW  CD
176E:  MOVWF  xA7
1770:  MOVLW  05
1772:  MOVWF  xA8
1774:  MOVWF  xA9
1776:  MOVLW  FF
1778:  MOVWF  xAA
177A:  CLRF   xAB
177C:  CLRF   xAF
177E:  CLRF   xAE
1780:  CLRF   xAD
1782:  CLRF   xAC
1784:  CLRF   xB3
1786:  CLRF   xB2
1788:  CLRF   xB1
178A:  CLRF   xB0
178C:  MOVF   FC1,W
178E:  ANDLW  C0
1790:  IORLW  0F
1792:  MOVWF  FC1
1794:  MOVLW  07
1796:  MOVWF  FB4
1798:  CLRF   19
179A:  CLRF   1A
179C:  CLRF   50
179E:  CLRF   51
17A0:  CLRF   52
17A2:  CLRF   53
17A4:  MOVLW  4C
17A6:  MOVWF  54
17A8:  MOVLW  75
17AA:  MOVWF  55
17AC:  MOVLW  6E
17AE:  MOVWF  56
17B0:  MOVLW  65
17B2:  MOVWF  57
17B4:  MOVLW  73
17B6:  MOVWF  58
17B8:  CLRF   59
17BA:  CLRF   5A
17BC:  CLRF   5B
17BE:  CLRF   5C
17C0:  CLRF   5D
17C2:  CLRF   5E
17C4:  MOVLW  4D
17C6:  MOVWF  5F
17C8:  MOVLW  61
17CA:  MOVWF  x60
17CC:  MOVLW  72
17CE:  MOVWF  x61
17D0:  MOVLW  74
17D2:  MOVWF  x62
17D4:  MOVLW  65
17D6:  MOVWF  x63
17D8:  MOVLW  73
17DA:  MOVWF  x64
17DC:  CLRF   x65
17DE:  CLRF   x66
17E0:  CLRF   x67
17E2:  CLRF   x68
17E4:  CLRF   x69
17E6:  MOVLW  4D
17E8:  MOVWF  x6A
17EA:  MOVLW  69
17EC:  MOVWF  x6B
17EE:  MOVLW  E9
17F0:  MOVWF  x6C
17F2:  MOVLW  72
17F4:  MOVWF  x6D
17F6:  MOVLW  63
17F8:  MOVWF  x6E
17FA:  MOVLW  6F
17FC:  MOVWF  x6F
17FE:  MOVLW  6C
1800:  MOVWF  x70
1802:  MOVLW  65
1804:  MOVWF  x71
1806:  MOVLW  73
1808:  MOVWF  x72
180A:  CLRF   x73
180C:  CLRF   x74
180E:  MOVLW  4A
1810:  MOVWF  x75
1812:  MOVLW  75
1814:  MOVWF  x76
1816:  MOVLW  65
1818:  MOVWF  x77
181A:  MOVLW  76
181C:  MOVWF  x78
181E:  MOVLW  65
1820:  MOVWF  x79
1822:  MOVLW  73
1824:  MOVWF  x7A
1826:  CLRF   x7B
1828:  CLRF   x7C
182A:  CLRF   x7D
182C:  CLRF   x7E
182E:  CLRF   x7F
1830:  MOVLW  56
1832:  MOVWF  x80
1834:  MOVLW  69
1836:  MOVWF  x81
1838:  MOVLW  65
183A:  MOVWF  x82
183C:  MOVLW  72
183E:  MOVWF  x83
1840:  MOVLW  6E
1842:  MOVWF  x84
1844:  MOVLW  65
1846:  MOVWF  x85
1848:  MOVLW  73
184A:  MOVWF  x86
184C:  CLRF   x87
184E:  CLRF   x88
1850:  CLRF   x89
1852:  CLRF   x8A
1854:  MOVLW  53
1856:  MOVWF  x8B
1858:  MOVLW  E1
185A:  MOVWF  x8C
185C:  MOVLW  62
185E:  MOVWF  x8D
1860:  MOVLW  61
1862:  MOVWF  x8E
1864:  MOVLW  64
1866:  MOVWF  x8F
1868:  MOVLW  6F
186A:  MOVWF  x90
186C:  CLRF   x91
186E:  CLRF   x92
1870:  CLRF   x93
1872:  CLRF   x94
1874:  CLRF   x95
1876:  MOVLW  44
1878:  MOVWF  x96
187A:  MOVLW  6F
187C:  MOVWF  x97
187E:  MOVLW  6D
1880:  MOVWF  x98
1882:  MOVLW  69
1884:  MOVWF  x99
1886:  MOVLW  6E
1888:  MOVWF  x9A
188A:  MOVLW  67
188C:  MOVWF  x9B
188E:  MOVLW  6F
1890:  MOVWF  x9C
1892:  CLRF   x9D
1894:  CLRF   x9E
1896:  CLRF   xA1
1898:  CLRF   xA2
189A:  CLRF   xA3
189C:  CLRF   xA4
189E:  CLRF   xA5
18A0:  CLRF   xA6
....................    //char* mensaje = "hola mundo\n\r"; 
....................    //int16 value = 0; 
....................     
....................    setup_devices(); 
18A2:  GOTO   064E
....................    //ds1307_set_date_time(0x0c, 0x0a, 0x0c, 0x01, 0x0a, 0x28, 0x00); 
....................    while(1){ 
....................       /* 
....................       if(COM_sense() != USB_NO_ATTACHED){ 
....................          COM_send(mensaje, strlen(mensaje)); 
....................          printf("%s", mensaje); 
....................       }else 
....................          printf("esperando a conectar....\n\r"); 
....................       */ 
....................       leer_aceleracion(); 
18A6:  GOTO   08B6
....................       leer_velocidad(); 
18AA:  GOTO   0B0A
....................       leer_revoluciones(); 
18AE:  GOTO   0D82
....................       leer_ccp1(); 
18B2:  BRA    11BE
....................       leer_ccp2(); 
18B4:  BRA    1462
....................       delay_ms(500); 
18B6:  MOVLW  02
18B8:  MOVWF  xB4
18BA:  MOVLW  FA
18BC:  MOVWF  xB5
18BE:  BRA    1706
18C0:  DECFSZ xB4,F
18C2:  BRA    18BA
....................    } 
18C4:  BRA    18A6
.................... } 
.................... char * mod_to_str(unsigned int8 mod){ 
....................    char *str_mod; 
18C6:  SLEEP 
....................    switch(mod){ 
....................       case ACC: 
....................          str_mod = "ACC"; 
....................          break; 
....................       case VEL: 
....................          str_mod = "VEL"; 
....................          break; 
....................       case REV: 
....................          str_mod = "REV"; 
....................          break; 
....................       case ACCM: 
....................          str_mod = "ACCM"; 
....................          break; 
....................       case SENP: 
....................          str_mod = "SENP"; 
....................          break; 
....................       case CCP1: 
....................          str_mod = "CCP1"; 
....................          break; 
....................       case CCP2: 
....................          str_mod = "CCP2"; 
....................          break; 
....................       default: 
....................          str_mod = "UDF"; 
....................    } 
....................  
....................    return &str_mod; 
.................... } 
....................  
.................... void leer_aceleracion(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_ACCELERACION , &valor_16b); 
*
0A50:  MOVLW  01
0A52:  MOVWF  xB4
0A54:  CLRF   xB6
0A56:  MOVLW  22
0A58:  MOVWF  xB5
0A5A:  RCALL  06BA
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%u val:%Ld",dia, mes, anio, hr, min, sec, ACC, valor_16b); 
0A5C:  CLRF   51
0A5E:  MOVLW  28
0A60:  MOVWF  50
0A62:  MOVFF  1E,B4
0A66:  MOVLW  1B
0A68:  MOVWF  xB5
0A6A:  RCALL  0722
0A6C:  MOVLW  2F
0A6E:  MOVWF  xC0
0A70:  RCALL  0706
0A72:  MOVFF  1F,B4
0A76:  MOVLW  1B
0A78:  MOVWF  xB5
0A7A:  RCALL  0722
0A7C:  MOVLW  2F
0A7E:  MOVWF  xC0
0A80:  RCALL  0706
0A82:  MOVFF  20,B4
0A86:  MOVLW  1B
0A88:  MOVWF  xB5
0A8A:  RCALL  0722
0A8C:  MOVLW  20
0A8E:  MOVWF  xC0
0A90:  RCALL  0706
0A92:  MOVFF  1B,B4
0A96:  MOVLW  1B
0A98:  MOVWF  xB5
0A9A:  RCALL  0722
0A9C:  MOVLW  3A
0A9E:  MOVWF  xC0
0AA0:  RCALL  0706
0AA2:  MOVFF  1C,B4
0AA6:  MOVLW  1B
0AA8:  MOVWF  xB5
0AAA:  RCALL  0722
0AAC:  MOVLW  3A
0AAE:  MOVWF  xC0
0AB0:  RCALL  0706
0AB2:  MOVFF  1D,B4
0AB6:  MOVLW  1B
0AB8:  MOVWF  xB5
0ABA:  RCALL  0722
0ABC:  MOVLW  E7
0ABE:  MOVWF  FF6
0AC0:  MOVLW  00
0AC2:  MOVWF  FF7
0AC4:  MOVLW  05
0AC6:  MOVWF  xB4
0AC8:  RCALL  0788
0ACA:  CLRF   xB4
0ACC:  MOVLW  1B
0ACE:  MOVWF  xB5
0AD0:  RCALL  0722
0AD2:  MOVLW  EE
0AD4:  MOVWF  FF6
0AD6:  MOVLW  00
0AD8:  MOVWF  FF7
0ADA:  MOVLW  05
0ADC:  MOVWF  xB4
0ADE:  RCALL  0788
0AE0:  MOVLW  10
0AE2:  MOVWF  FE9
0AE4:  MOVFF  23,B5
0AE8:  MOVFF  22,B4
0AEC:  RCALL  07A6
....................    printf("%s\n\r", mensaje); 
0AEE:  CLRF   FEA
0AF0:  MOVLW  28
0AF2:  MOVWF  FE9
0AF4:  RCALL  0890
0AF6:  MOVLW  0A
0AF8:  BTFSS  F9E.4
0AFA:  BRA    0AF8
0AFC:  MOVWF  FAD
0AFE:  MOVLW  0D
0B00:  BTFSS  F9E.4
0B02:  BRA    0B00
0B04:  MOVWF  FAD
....................    return; 
.................... } 
0B06:  GOTO   18AA (RETURN)
....................  
.................... void leer_velocidad(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_VELOCIDAD , &valor_16b); 
*
0CC8:  CLRF   xB4
0CCA:  CLRF   xB6
0CCC:  MOVLW  22
0CCE:  MOVWF  xB5
0CD0:  RCALL  06BA
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%u val:%Ld",dia, mes, anio, hr, min, sec, VEL, valor_16b); 
0CD2:  CLRF   51
0CD4:  MOVLW  28
0CD6:  MOVWF  50
0CD8:  MOVFF  1E,B4
0CDC:  MOVLW  1B
0CDE:  MOVWF  xB5
0CE0:  RCALL  0722
0CE2:  MOVLW  2F
0CE4:  MOVWF  xC0
0CE6:  RCALL  0706
0CE8:  MOVFF  1F,B4
0CEC:  MOVLW  1B
0CEE:  MOVWF  xB5
0CF0:  RCALL  0722
0CF2:  MOVLW  2F
0CF4:  MOVWF  xC0
0CF6:  RCALL  0706
0CF8:  MOVFF  20,B4
0CFC:  MOVLW  1B
0CFE:  MOVWF  xB5
0D00:  RCALL  0722
0D02:  MOVLW  20
0D04:  MOVWF  xC0
0D06:  RCALL  0706
0D08:  MOVFF  1B,B4
0D0C:  MOVLW  1B
0D0E:  MOVWF  xB5
0D10:  RCALL  0722
0D12:  MOVLW  3A
0D14:  MOVWF  xC0
0D16:  RCALL  0706
0D18:  MOVFF  1C,B4
0D1C:  MOVLW  1B
0D1E:  MOVWF  xB5
0D20:  RCALL  0722
0D22:  MOVLW  3A
0D24:  MOVWF  xC0
0D26:  RCALL  0706
0D28:  MOVFF  1D,B4
0D2C:  MOVLW  1B
0D2E:  MOVWF  xB5
0D30:  RCALL  0722
0D32:  MOVLW  09
0D34:  MOVWF  FF6
0D36:  MOVLW  01
0D38:  MOVWF  FF7
0D3A:  MOVLW  05
0D3C:  MOVWF  xB4
0D3E:  RCALL  0788
0D40:  MOVLW  01
0D42:  MOVWF  xB4
0D44:  MOVLW  1B
0D46:  MOVWF  xB5
0D48:  RCALL  0722
0D4A:  MOVLW  10
0D4C:  MOVWF  FF6
0D4E:  MOVLW  01
0D50:  MOVWF  FF7
0D52:  MOVLW  05
0D54:  MOVWF  xB4
0D56:  RCALL  0788
0D58:  MOVLW  10
0D5A:  MOVWF  FE9
0D5C:  MOVFF  23,B5
0D60:  MOVFF  22,B4
0D64:  RCALL  07A6
....................    printf("%s\n\r", mensaje); 
0D66:  CLRF   FEA
0D68:  MOVLW  28
0D6A:  MOVWF  FE9
0D6C:  RCALL  0890
0D6E:  MOVLW  0A
0D70:  BTFSS  F9E.4
0D72:  BRA    0D70
0D74:  MOVWF  FAD
0D76:  MOVLW  0D
0D78:  BTFSS  F9E.4
0D7A:  BRA    0D78
0D7C:  MOVWF  FAD
....................    return; 
.................... } 
0D7E:  GOTO   18AE (RETURN)
....................  
.................... void leer_revoluciones(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_REVOLUCIONES , &valor_16b); 
*
0F44:  MOVLW  02
0F46:  MOVWF  xB4
0F48:  CLRF   xB6
0F4A:  MOVLW  22
0F4C:  MOVWF  xB5
0F4E:  CALL   06BA
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%u val:%Ld",dia, mes, anio, hr, min, sec, REV, valor_16b); 
0F52:  CLRF   51
0F54:  MOVLW  28
0F56:  MOVWF  50
0F58:  MOVFF  1E,B4
0F5C:  MOVLW  1B
0F5E:  MOVWF  xB5
0F60:  CALL   0722
0F64:  MOVLW  2F
0F66:  MOVWF  xC0
0F68:  CALL   0706
0F6C:  MOVFF  1F,B4
0F70:  MOVLW  1B
0F72:  MOVWF  xB5
0F74:  CALL   0722
0F78:  MOVLW  2F
0F7A:  MOVWF  xC0
0F7C:  CALL   0706
0F80:  MOVFF  20,B4
0F84:  MOVLW  1B
0F86:  MOVWF  xB5
0F88:  CALL   0722
0F8C:  MOVLW  20
0F8E:  MOVWF  xC0
0F90:  CALL   0706
0F94:  MOVFF  1B,B4
0F98:  MOVLW  1B
0F9A:  MOVWF  xB5
0F9C:  CALL   0722
0FA0:  MOVLW  3A
0FA2:  MOVWF  xC0
0FA4:  CALL   0706
0FA8:  MOVFF  1C,B4
0FAC:  MOVLW  1B
0FAE:  MOVWF  xB5
0FB0:  CALL   0722
0FB4:  MOVLW  3A
0FB6:  MOVWF  xC0
0FB8:  CALL   0706
0FBC:  MOVFF  1D,B4
0FC0:  MOVLW  1B
0FC2:  MOVWF  xB5
0FC4:  CALL   0722
0FC8:  MOVLW  2B
0FCA:  MOVWF  FF6
0FCC:  MOVLW  01
0FCE:  MOVWF  FF7
0FD0:  MOVLW  05
0FD2:  MOVWF  xB4
0FD4:  CALL   0788
0FD8:  MOVLW  02
0FDA:  MOVWF  xB4
0FDC:  MOVLW  1B
0FDE:  MOVWF  xB5
0FE0:  CALL   0722
0FE4:  MOVLW  32
0FE6:  MOVWF  FF6
0FE8:  MOVLW  01
0FEA:  MOVWF  FF7
0FEC:  MOVLW  05
0FEE:  MOVWF  xB4
0FF0:  CALL   0788
0FF4:  MOVLW  10
0FF6:  MOVWF  FE9
0FF8:  MOVFF  23,B5
0FFC:  MOVFF  22,B4
1000:  CALL   07A6
....................    printf("%s\n\r", mensaje); 
1004:  CLRF   FEA
1006:  MOVLW  28
1008:  MOVWF  FE9
100A:  RCALL  0890
100C:  MOVLW  0A
100E:  BTFSS  F9E.4
1010:  BRA    100E
1012:  MOVWF  FAD
1014:  MOVLW  0D
1016:  BTFSS  F9E.4
1018:  BRA    1016
101A:  MOVWF  FAD
....................    return; 
.................... } 
101C:  GOTO   18B2 (RETURN)
....................  
.................... void leer_accelerometro(void){} 
.................... void leer_sensor_puertas(void){} 
....................  
.................... void leer_ccp1(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    CP_leer_ccp(CANAL_1 , &valor_32b); 
*
1380:  MOVLW  01
1382:  MOVWF  xB4
1384:  CLRF   xB6
1386:  MOVLW  24
1388:  MOVWF  xB5
138A:  RCALL  1020
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%u val:%Lu",dia, mes, anio, hr, min, sec, CCP1, valor_32b); 
138C:  CLRF   51
138E:  MOVLW  28
1390:  MOVWF  50
1392:  MOVFF  1E,B4
1396:  MOVLW  1B
1398:  MOVWF  xB5
139A:  CALL   0722
139E:  MOVLW  2F
13A0:  MOVWF  xC0
13A2:  CALL   0706
13A6:  MOVFF  1F,B4
13AA:  MOVLW  1B
13AC:  MOVWF  xB5
13AE:  CALL   0722
13B2:  MOVLW  2F
13B4:  MOVWF  xC0
13B6:  CALL   0706
13BA:  MOVFF  20,B4
13BE:  MOVLW  1B
13C0:  MOVWF  xB5
13C2:  CALL   0722
13C6:  MOVLW  20
13C8:  MOVWF  xC0
13CA:  CALL   0706
13CE:  MOVFF  1B,B4
13D2:  MOVLW  1B
13D4:  MOVWF  xB5
13D6:  CALL   0722
13DA:  MOVLW  3A
13DC:  MOVWF  xC0
13DE:  CALL   0706
13E2:  MOVFF  1C,B4
13E6:  MOVLW  1B
13E8:  MOVWF  xB5
13EA:  CALL   0722
13EE:  MOVLW  3A
13F0:  MOVWF  xC0
13F2:  CALL   0706
13F6:  MOVFF  1D,B4
13FA:  MOVLW  1B
13FC:  MOVWF  xB5
13FE:  CALL   0722
1402:  MOVLW  4D
1404:  MOVWF  FF6
1406:  MOVLW  01
1408:  MOVWF  FF7
140A:  MOVLW  05
140C:  MOVWF  xB4
140E:  CALL   0788
1412:  MOVLW  05
1414:  MOVWF  xB4
1416:  MOVLW  1B
1418:  MOVWF  xB5
141A:  CALL   0722
141E:  MOVLW  54
1420:  MOVWF  FF6
1422:  MOVLW  01
1424:  MOVWF  FF7
1426:  MOVLW  05
1428:  MOVWF  xB4
142A:  CALL   0788
142E:  MOVLW  41
1430:  MOVWF  FE9
1432:  MOVFF  27,B7
1436:  MOVFF  26,B6
143A:  MOVFF  25,B5
143E:  MOVFF  24,B4
1442:  RCALL  1112
....................    printf("%s\n\r", mensaje); 
1444:  CLRF   FEA
1446:  MOVLW  28
1448:  MOVWF  FE9
144A:  CALL   0890
144E:  MOVLW  0A
1450:  BTFSS  F9E.4
1452:  BRA    1450
1454:  MOVWF  FAD
1456:  MOVLW  0D
1458:  BTFSS  F9E.4
145A:  BRA    1458
145C:  MOVWF  FAD
.................... } 
145E:  GOTO   18B4 (RETURN)
....................  
.................... void leer_ccp2(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    CP_leer_ccp(CANAL_1 , &valor_32b); 
*
1624:  MOVLW  01
1626:  MOVWF  xB4
1628:  CLRF   xB6
162A:  MOVLW  24
162C:  MOVWF  xB5
162E:  RCALL  1020
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%u val:%Lu",dia, mes, anio, hr, min, sec, CCP2, valor_32b); 
1630:  CLRF   51
1632:  MOVLW  28
1634:  MOVWF  50
1636:  MOVFF  1E,B4
163A:  MOVLW  1B
163C:  MOVWF  xB5
163E:  CALL   0722
1642:  MOVLW  2F
1644:  MOVWF  xC0
1646:  CALL   0706
164A:  MOVFF  1F,B4
164E:  MOVLW  1B
1650:  MOVWF  xB5
1652:  CALL   0722
1656:  MOVLW  2F
1658:  MOVWF  xC0
165A:  CALL   0706
165E:  MOVFF  20,B4
1662:  MOVLW  1B
1664:  MOVWF  xB5
1666:  CALL   0722
166A:  MOVLW  20
166C:  MOVWF  xC0
166E:  CALL   0706
1672:  MOVFF  1B,B4
1676:  MOVLW  1B
1678:  MOVWF  xB5
167A:  CALL   0722
167E:  MOVLW  3A
1680:  MOVWF  xC0
1682:  CALL   0706
1686:  MOVFF  1C,B4
168A:  MOVLW  1B
168C:  MOVWF  xB5
168E:  CALL   0722
1692:  MOVLW  3A
1694:  MOVWF  xC0
1696:  CALL   0706
169A:  MOVFF  1D,B4
169E:  MOVLW  1B
16A0:  MOVWF  xB5
16A2:  CALL   0722
16A6:  MOVLW  6F
16A8:  MOVWF  FF6
16AA:  MOVLW  01
16AC:  MOVWF  FF7
16AE:  MOVLW  05
16B0:  MOVWF  xB4
16B2:  CALL   0788
16B6:  MOVLW  06
16B8:  MOVWF  xB4
16BA:  MOVLW  1B
16BC:  MOVWF  xB5
16BE:  CALL   0722
16C2:  MOVLW  76
16C4:  MOVWF  FF6
16C6:  MOVLW  01
16C8:  MOVWF  FF7
16CA:  MOVLW  05
16CC:  MOVWF  xB4
16CE:  CALL   0788
16D2:  MOVLW  41
16D4:  MOVWF  FE9
16D6:  MOVFF  27,B7
16DA:  MOVFF  26,B6
16DE:  MOVFF  25,B5
16E2:  MOVFF  24,B4
16E6:  RCALL  1112
....................    printf("%s\n\r", mensaje); 
16E8:  CLRF   FEA
16EA:  MOVLW  28
16EC:  MOVWF  FE9
16EE:  CALL   0890
16F2:  MOVLW  0A
16F4:  BTFSS  F9E.4
16F6:  BRA    16F4
16F8:  MOVWF  FAD
16FA:  MOVLW  0D
16FC:  BTFSS  F9E.4
16FE:  BRA    16FC
1700:  MOVWF  FAD
.................... } 
1702:  GOTO   18B6 (RETURN)
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
03EE:  CLRF   xB6
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
03F0:  BCF    FF2.6
03F2:  BCF    FF2.7
03F4:  BTFSC  FF2.7
03F6:  BRA    03F2
.................... #endif 
....................  
....................    i2c_start(); 
03F8:  BSF    F93.0
03FA:  MOVLW  07
03FC:  MOVWF  00
03FE:  DECFSZ 00,F
0400:  BRA    03FE
0402:  BSF    F93.1
0404:  MOVLW  07
0406:  MOVWF  00
0408:  DECFSZ 00,F
040A:  BRA    0408
040C:  BCF    F8A.0
040E:  BCF    F93.0
0410:  MOVLW  07
0412:  MOVWF  00
0414:  DECFSZ 00,F
0416:  BRA    0414
0418:  BCF    F8A.1
041A:  BCF    F93.1
....................    i2c_write(0xD0); 
041C:  MOVLW  D0
041E:  MOVWF  xB8
0420:  RCALL  02D0
....................    i2c_write(0x00); 
0422:  CLRF   xB8
0424:  RCALL  02D0
....................    i2c_start(); 
0426:  BSF    F93.0
0428:  MOVLW  07
042A:  MOVWF  00
042C:  DECFSZ 00,F
042E:  BRA    042C
0430:  BSF    F93.1
0432:  MOVLW  07
0434:  MOVWF  00
0436:  DECFSZ 00,F
0438:  BRA    0436
043A:  BTFSS  F81.1
043C:  BRA    043A
043E:  BCF    F8A.0
0440:  BCF    F93.0
0442:  MOVLW  07
0444:  MOVWF  00
0446:  DECFSZ 00,F
0448:  BRA    0446
044A:  BCF    F8A.1
044C:  BCF    F93.1
....................    i2c_write(0xD1); 
044E:  MOVLW  D1
0450:  MOVWF  xB8
0452:  RCALL  02D0
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
0454:  CLRF   00
0456:  RCALL  033C
0458:  MOVFF  01,B7
045C:  MOVFF  01,B9
0460:  RCALL  03A2
0462:  MOVFF  01,B6
....................    i2c_stop(); 
0466:  BCF    F93.0
0468:  NOP   
046A:  BSF    F93.1
046C:  BTFSS  F81.1
046E:  BRA    046C
0470:  MOVLW  07
0472:  MOVWF  00
0474:  DECFSZ 00,F
0476:  BRA    0474
0478:  BRA    047A
047A:  NOP   
047C:  BSF    F93.0
047E:  MOVLW  07
0480:  MOVWF  00
0482:  DECFSZ 00,F
0484:  BRA    0482
....................    seconds &= 0x7F; 
0486:  BCF    xB6.7
....................  
....................    delay_us(3); 
0488:  MOVLW  05
048A:  MOVWF  00
048C:  DECFSZ 00,F
048E:  BRA    048C
0490:  BRA    0492
....................  
....................    i2c_start(); 
0492:  BSF    F93.0
0494:  MOVLW  07
0496:  MOVWF  00
0498:  DECFSZ 00,F
049A:  BRA    0498
049C:  BSF    F93.1
049E:  MOVLW  07
04A0:  MOVWF  00
04A2:  DECFSZ 00,F
04A4:  BRA    04A2
04A6:  BCF    F8A.0
04A8:  BCF    F93.0
04AA:  MOVLW  07
04AC:  MOVWF  00
04AE:  DECFSZ 00,F
04B0:  BRA    04AE
04B2:  BCF    F8A.1
04B4:  BCF    F93.1
....................    i2c_write(0xD0); 
04B6:  MOVLW  D0
04B8:  MOVWF  xB8
04BA:  RCALL  02D0
....................    i2c_write(0x00); 
04BC:  CLRF   xB8
04BE:  RCALL  02D0
....................    i2c_write(ds1307_bin2bcd(seconds)); 
04C0:  MOVFF  B6,B7
04C4:  BRA    03C8
04C6:  MOVFF  01,B7
04CA:  MOVFF  01,B8
04CE:  RCALL  02D0
....................    i2c_start(); 
04D0:  BSF    F93.0
04D2:  MOVLW  07
04D4:  MOVWF  00
04D6:  DECFSZ 00,F
04D8:  BRA    04D6
04DA:  BSF    F93.1
04DC:  MOVLW  07
04DE:  MOVWF  00
04E0:  DECFSZ 00,F
04E2:  BRA    04E0
04E4:  BTFSS  F81.1
04E6:  BRA    04E4
04E8:  BCF    F8A.0
04EA:  BCF    F93.0
04EC:  MOVLW  07
04EE:  MOVWF  00
04F0:  DECFSZ 00,F
04F2:  BRA    04F0
04F4:  BCF    F8A.1
04F6:  BCF    F93.1
....................    i2c_write(0xD0); 
04F8:  MOVLW  D0
04FA:  MOVWF  xB8
04FC:  RCALL  02D0
....................    i2c_write(0x07); 
04FE:  MOVLW  07
0500:  MOVWF  xB8
0502:  RCALL  02D0
....................    i2c_write(val); 
0504:  MOVFF  B5,B8
0508:  RCALL  02D0
....................    i2c_stop(); 
050A:  BCF    F93.0
050C:  NOP   
050E:  BSF    F93.1
0510:  BTFSS  F81.1
0512:  BRA    0510
0514:  MOVLW  07
0516:  MOVWF  00
0518:  DECFSZ 00,F
051A:  BRA    0518
051C:  BRA    051E
051E:  NOP   
0520:  BSF    F93.0
0522:  MOVLW  07
0524:  MOVWF  00
0526:  DECFSZ 00,F
0528:  BRA    0526
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
052A:  MOVLW  C0
052C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
052E:  GOTO   0664 (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0978:  BCF    FF2.6
097A:  BCF    FF2.7
097C:  BTFSC  FF2.7
097E:  BRA    097A
*
0BDA:  BCF    FF2.6
0BDC:  BCF    FF2.7
0BDE:  BTFSC  FF2.7
0BE0:  BRA    0BDC
*
0E56:  BCF    FF2.6
0E58:  BCF    FF2.7
0E5A:  BTFSC  FF2.7
0E5C:  BRA    0E58
*
1292:  BCF    FF2.6
1294:  BCF    FF2.7
1296:  BTFSC  FF2.7
1298:  BRA    1294
*
1536:  BCF    FF2.6
1538:  BCF    FF2.7
153A:  BTFSC  FF2.7
153C:  BRA    1538
.................... #endif 
....................  
....................   i2c_start(); 
*
0980:  BSF    F93.0
0982:  MOVLW  07
0984:  MOVWF  00
0986:  DECFSZ 00,F
0988:  BRA    0986
098A:  BSF    F93.1
098C:  MOVLW  07
098E:  MOVWF  00
0990:  DECFSZ 00,F
0992:  BRA    0990
0994:  BCF    F8A.0
0996:  BCF    F93.0
0998:  MOVLW  07
099A:  MOVWF  00
099C:  DECFSZ 00,F
099E:  BRA    099C
09A0:  BCF    F8A.1
09A2:  BCF    F93.1
*
0BE2:  BSF    F93.0
0BE4:  MOVLW  07
0BE6:  MOVWF  00
0BE8:  DECFSZ 00,F
0BEA:  BRA    0BE8
0BEC:  BSF    F93.1
0BEE:  MOVLW  07
0BF0:  MOVWF  00
0BF2:  DECFSZ 00,F
0BF4:  BRA    0BF2
0BF6:  BCF    F8A.0
0BF8:  BCF    F93.0
0BFA:  MOVLW  07
0BFC:  MOVWF  00
0BFE:  DECFSZ 00,F
0C00:  BRA    0BFE
0C02:  BCF    F8A.1
0C04:  BCF    F93.1
*
0E5E:  BSF    F93.0
0E60:  MOVLW  07
0E62:  MOVWF  00
0E64:  DECFSZ 00,F
0E66:  BRA    0E64
0E68:  BSF    F93.1
0E6A:  MOVLW  07
0E6C:  MOVWF  00
0E6E:  DECFSZ 00,F
0E70:  BRA    0E6E
0E72:  BCF    F8A.0
0E74:  BCF    F93.0
0E76:  MOVLW  07
0E78:  MOVWF  00
0E7A:  DECFSZ 00,F
0E7C:  BRA    0E7A
0E7E:  BCF    F8A.1
0E80:  BCF    F93.1
*
129A:  BSF    F93.0
129C:  MOVLW  07
129E:  MOVWF  00
12A0:  DECFSZ 00,F
12A2:  BRA    12A0
12A4:  BSF    F93.1
12A6:  MOVLW  07
12A8:  MOVWF  00
12AA:  DECFSZ 00,F
12AC:  BRA    12AA
12AE:  BCF    F8A.0
12B0:  BCF    F93.0
12B2:  MOVLW  07
12B4:  MOVWF  00
12B6:  DECFSZ 00,F
12B8:  BRA    12B6
12BA:  BCF    F8A.1
12BC:  BCF    F93.1
*
153E:  BSF    F93.0
1540:  MOVLW  07
1542:  MOVWF  00
1544:  DECFSZ 00,F
1546:  BRA    1544
1548:  BSF    F93.1
154A:  MOVLW  07
154C:  MOVWF  00
154E:  DECFSZ 00,F
1550:  BRA    154E
1552:  BCF    F8A.0
1554:  BCF    F93.0
1556:  MOVLW  07
1558:  MOVWF  00
155A:  DECFSZ 00,F
155C:  BRA    155A
155E:  BCF    F8A.1
1560:  BCF    F93.1
....................   i2c_write(0xD0); 
*
09A4:  MOVLW  D0
09A6:  MOVWF  xB8
09A8:  RCALL  02D0
*
0C06:  MOVLW  D0
0C08:  MOVWF  xB8
0C0A:  CALL   02D0
*
0E82:  MOVLW  D0
0E84:  MOVWF  xB8
0E86:  CALL   02D0
*
12BE:  MOVLW  D0
12C0:  MOVWF  xB8
12C2:  CALL   02D0
*
1562:  MOVLW  D0
1564:  MOVWF  xB8
1566:  CALL   02D0
....................   i2c_write(0x03); 
*
09AA:  MOVLW  03
09AC:  MOVWF  xB8
09AE:  RCALL  02D0
*
0C0E:  MOVLW  03
0C10:  MOVWF  xB8
0C12:  CALL   02D0
*
0E8A:  MOVLW  03
0E8C:  MOVWF  xB8
0E8E:  CALL   02D0
*
12C6:  MOVLW  03
12C8:  MOVWF  xB8
12CA:  CALL   02D0
*
156A:  MOVLW  03
156C:  MOVWF  xB8
156E:  CALL   02D0
....................   i2c_start(); 
*
09B0:  BSF    F93.0
09B2:  MOVLW  07
09B4:  MOVWF  00
09B6:  DECFSZ 00,F
09B8:  BRA    09B6
09BA:  BSF    F93.1
09BC:  MOVLW  07
09BE:  MOVWF  00
09C0:  DECFSZ 00,F
09C2:  BRA    09C0
09C4:  BTFSS  F81.1
09C6:  BRA    09C4
09C8:  BCF    F8A.0
09CA:  BCF    F93.0
09CC:  MOVLW  07
09CE:  MOVWF  00
09D0:  DECFSZ 00,F
09D2:  BRA    09D0
09D4:  BCF    F8A.1
09D6:  BCF    F93.1
*
0C16:  BSF    F93.0
0C18:  MOVLW  07
0C1A:  MOVWF  00
0C1C:  DECFSZ 00,F
0C1E:  BRA    0C1C
0C20:  BSF    F93.1
0C22:  MOVLW  07
0C24:  MOVWF  00
0C26:  DECFSZ 00,F
0C28:  BRA    0C26
0C2A:  BTFSS  F81.1
0C2C:  BRA    0C2A
0C2E:  BCF    F8A.0
0C30:  BCF    F93.0
0C32:  MOVLW  07
0C34:  MOVWF  00
0C36:  DECFSZ 00,F
0C38:  BRA    0C36
0C3A:  BCF    F8A.1
0C3C:  BCF    F93.1
*
0E92:  BSF    F93.0
0E94:  MOVLW  07
0E96:  MOVWF  00
0E98:  DECFSZ 00,F
0E9A:  BRA    0E98
0E9C:  BSF    F93.1
0E9E:  MOVLW  07
0EA0:  MOVWF  00
0EA2:  DECFSZ 00,F
0EA4:  BRA    0EA2
0EA6:  BTFSS  F81.1
0EA8:  BRA    0EA6
0EAA:  BCF    F8A.0
0EAC:  BCF    F93.0
0EAE:  MOVLW  07
0EB0:  MOVWF  00
0EB2:  DECFSZ 00,F
0EB4:  BRA    0EB2
0EB6:  BCF    F8A.1
0EB8:  BCF    F93.1
*
12CE:  BSF    F93.0
12D0:  MOVLW  07
12D2:  MOVWF  00
12D4:  DECFSZ 00,F
12D6:  BRA    12D4
12D8:  BSF    F93.1
12DA:  MOVLW  07
12DC:  MOVWF  00
12DE:  DECFSZ 00,F
12E0:  BRA    12DE
12E2:  BTFSS  F81.1
12E4:  BRA    12E2
12E6:  BCF    F8A.0
12E8:  BCF    F93.0
12EA:  MOVLW  07
12EC:  MOVWF  00
12EE:  DECFSZ 00,F
12F0:  BRA    12EE
12F2:  BCF    F8A.1
12F4:  BCF    F93.1
*
1572:  BSF    F93.0
1574:  MOVLW  07
1576:  MOVWF  00
1578:  DECFSZ 00,F
157A:  BRA    1578
157C:  BSF    F93.1
157E:  MOVLW  07
1580:  MOVWF  00
1582:  DECFSZ 00,F
1584:  BRA    1582
1586:  BTFSS  F81.1
1588:  BRA    1586
158A:  BCF    F8A.0
158C:  BCF    F93.0
158E:  MOVLW  07
1590:  MOVWF  00
1592:  DECFSZ 00,F
1594:  BRA    1592
1596:  BCF    F8A.1
1598:  BCF    F93.1
....................   i2c_write(0xD1); 
*
09D8:  MOVLW  D1
09DA:  MOVWF  xB8
09DC:  RCALL  02D0
*
0C3E:  MOVLW  D1
0C40:  MOVWF  xB8
0C42:  CALL   02D0
*
0EBA:  MOVLW  D1
0EBC:  MOVWF  xB8
0EBE:  CALL   02D0
*
12F6:  MOVLW  D1
12F8:  MOVWF  xB8
12FA:  CALL   02D0
*
159A:  MOVLW  D1
159C:  MOVWF  xB8
159E:  CALL   02D0
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
09DE:  MOVLW  01
09E0:  MOVWF  00
09E2:  RCALL  033C
09E4:  MOVF   01,W
09E6:  ANDLW  7F
09E8:  MOVWF  xB4
09EA:  MOVWF  xB9
09EC:  RCALL  03A2
09EE:  MOVFF  01,21
*
0C46:  MOVLW  01
0C48:  MOVWF  00
0C4A:  CALL   033C
0C4E:  MOVF   01,W
0C50:  ANDLW  7F
0C52:  MOVWF  xB4
0C54:  MOVWF  xB9
0C56:  CALL   03A2
0C5A:  MOVFF  01,21
*
0EC2:  MOVLW  01
0EC4:  MOVWF  00
0EC6:  CALL   033C
0ECA:  MOVF   01,W
0ECC:  ANDLW  7F
0ECE:  MOVWF  xB4
0ED0:  MOVWF  xB9
0ED2:  CALL   03A2
0ED6:  MOVFF  01,21
*
12FE:  MOVLW  01
1300:  MOVWF  00
1302:  CALL   033C
1306:  MOVF   01,W
1308:  ANDLW  7F
130A:  MOVWF  xB4
130C:  MOVWF  xB9
130E:  CALL   03A2
1312:  MOVFF  01,21
*
15A2:  MOVLW  01
15A4:  MOVWF  00
15A6:  CALL   033C
15AA:  MOVF   01,W
15AC:  ANDLW  7F
15AE:  MOVWF  xB4
15B0:  MOVWF  xB9
15B2:  CALL   03A2
15B6:  MOVFF  01,21
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
09F2:  MOVLW  01
09F4:  MOVWF  00
09F6:  RCALL  033C
09F8:  MOVF   01,W
09FA:  ANDLW  3F
09FC:  MOVWF  xB4
09FE:  MOVWF  xB9
0A00:  RCALL  03A2
0A02:  MOVFF  01,1E
*
0C5E:  MOVLW  01
0C60:  MOVWF  00
0C62:  CALL   033C
0C66:  MOVF   01,W
0C68:  ANDLW  3F
0C6A:  MOVWF  xB4
0C6C:  MOVWF  xB9
0C6E:  CALL   03A2
0C72:  MOVFF  01,1E
*
0EDA:  MOVLW  01
0EDC:  MOVWF  00
0EDE:  CALL   033C
0EE2:  MOVF   01,W
0EE4:  ANDLW  3F
0EE6:  MOVWF  xB4
0EE8:  MOVWF  xB9
0EEA:  CALL   03A2
0EEE:  MOVFF  01,1E
*
1316:  MOVLW  01
1318:  MOVWF  00
131A:  CALL   033C
131E:  MOVF   01,W
1320:  ANDLW  3F
1322:  MOVWF  xB4
1324:  MOVWF  xB9
1326:  CALL   03A2
132A:  MOVFF  01,1E
*
15BA:  MOVLW  01
15BC:  MOVWF  00
15BE:  CALL   033C
15C2:  MOVF   01,W
15C4:  ANDLW  3F
15C6:  MOVWF  xB4
15C8:  MOVWF  xB9
15CA:  CALL   03A2
15CE:  MOVFF  01,1E
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
0A06:  MOVLW  01
0A08:  MOVWF  00
0A0A:  RCALL  033C
0A0C:  MOVF   01,W
0A0E:  ANDLW  1F
0A10:  MOVWF  xB4
0A12:  MOVWF  xB9
0A14:  RCALL  03A2
0A16:  MOVFF  01,1F
*
0C76:  MOVLW  01
0C78:  MOVWF  00
0C7A:  CALL   033C
0C7E:  MOVF   01,W
0C80:  ANDLW  1F
0C82:  MOVWF  xB4
0C84:  MOVWF  xB9
0C86:  CALL   03A2
0C8A:  MOVFF  01,1F
*
0EF2:  MOVLW  01
0EF4:  MOVWF  00
0EF6:  CALL   033C
0EFA:  MOVF   01,W
0EFC:  ANDLW  1F
0EFE:  MOVWF  xB4
0F00:  MOVWF  xB9
0F02:  CALL   03A2
0F06:  MOVFF  01,1F
*
132E:  MOVLW  01
1330:  MOVWF  00
1332:  CALL   033C
1336:  MOVF   01,W
1338:  ANDLW  1F
133A:  MOVWF  xB4
133C:  MOVWF  xB9
133E:  CALL   03A2
1342:  MOVFF  01,1F
*
15D2:  MOVLW  01
15D4:  MOVWF  00
15D6:  CALL   033C
15DA:  MOVF   01,W
15DC:  ANDLW  1F
15DE:  MOVWF  xB4
15E0:  MOVWF  xB9
15E2:  CALL   03A2
15E6:  MOVFF  01,1F
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
0A1A:  CLRF   00
0A1C:  RCALL  033C
0A1E:  MOVFF  01,B4
0A22:  MOVFF  01,B9
0A26:  RCALL  03A2
0A28:  MOVFF  01,20
*
0C8E:  CLRF   00
0C90:  CALL   033C
0C94:  MOVFF  01,B4
0C98:  MOVFF  01,B9
0C9C:  CALL   03A2
0CA0:  MOVFF  01,20
*
0F0A:  CLRF   00
0F0C:  CALL   033C
0F10:  MOVFF  01,B4
0F14:  MOVFF  01,B9
0F18:  CALL   03A2
0F1C:  MOVFF  01,20
*
1346:  CLRF   00
1348:  CALL   033C
134C:  MOVFF  01,B4
1350:  MOVFF  01,B9
1354:  CALL   03A2
1358:  MOVFF  01,20
*
15EA:  CLRF   00
15EC:  CALL   033C
15F0:  MOVFF  01,B4
15F4:  MOVFF  01,B9
15F8:  CALL   03A2
15FC:  MOVFF  01,20
....................   i2c_stop(); 
*
0A2C:  BCF    F93.0
0A2E:  NOP   
0A30:  BSF    F93.1
0A32:  BTFSS  F81.1
0A34:  BRA    0A32
0A36:  MOVLW  07
0A38:  MOVWF  00
0A3A:  DECFSZ 00,F
0A3C:  BRA    0A3A
0A3E:  BRA    0A40
0A40:  NOP   
0A42:  BSF    F93.0
0A44:  MOVLW  07
0A46:  MOVWF  00
0A48:  DECFSZ 00,F
0A4A:  BRA    0A48
*
0CA4:  BCF    F93.0
0CA6:  NOP   
0CA8:  BSF    F93.1
0CAA:  BTFSS  F81.1
0CAC:  BRA    0CAA
0CAE:  MOVLW  07
0CB0:  MOVWF  00
0CB2:  DECFSZ 00,F
0CB4:  BRA    0CB2
0CB6:  BRA    0CB8
0CB8:  NOP   
0CBA:  BSF    F93.0
0CBC:  MOVLW  07
0CBE:  MOVWF  00
0CC0:  DECFSZ 00,F
0CC2:  BRA    0CC0
*
0F20:  BCF    F93.0
0F22:  NOP   
0F24:  BSF    F93.1
0F26:  BTFSS  F81.1
0F28:  BRA    0F26
0F2A:  MOVLW  07
0F2C:  MOVWF  00
0F2E:  DECFSZ 00,F
0F30:  BRA    0F2E
0F32:  BRA    0F34
0F34:  NOP   
0F36:  BSF    F93.0
0F38:  MOVLW  07
0F3A:  MOVWF  00
0F3C:  DECFSZ 00,F
0F3E:  BRA    0F3C
*
135C:  BCF    F93.0
135E:  NOP   
1360:  BSF    F93.1
1362:  BTFSS  F81.1
1364:  BRA    1362
1366:  MOVLW  07
1368:  MOVWF  00
136A:  DECFSZ 00,F
136C:  BRA    136A
136E:  BRA    1370
1370:  NOP   
1372:  BSF    F93.0
1374:  MOVLW  07
1376:  MOVWF  00
1378:  DECFSZ 00,F
137A:  BRA    1378
*
1600:  BCF    F93.0
1602:  NOP   
1604:  BSF    F93.1
1606:  BTFSS  F81.1
1608:  BRA    1606
160A:  MOVLW  07
160C:  MOVWF  00
160E:  DECFSZ 00,F
1610:  BRA    160E
1612:  BRA    1614
1614:  NOP   
1616:  BSF    F93.0
1618:  MOVLW  07
161A:  MOVWF  00
161C:  DECFSZ 00,F
161E:  BRA    161C
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
0A4C:  MOVLW  C0
0A4E:  IORWF  FF2,F
*
0CC4:  MOVLW  C0
0CC6:  IORWF  FF2,F
*
0F40:  MOVLW  C0
0F42:  IORWF  FF2,F
*
137C:  MOVLW  C0
137E:  IORWF  FF2,F
*
1620:  MOVLW  C0
1622:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
08B6:  BCF    FF2.6
08B8:  BCF    FF2.7
08BA:  BTFSC  FF2.7
08BC:  BRA    08B8
*
0B0A:  BCF    FF2.6
0B0C:  BCF    FF2.7
0B0E:  BTFSC  FF2.7
0B10:  BRA    0B0C
*
0D82:  BCF    FF2.6
0D84:  BCF    FF2.7
0D86:  BTFSC  FF2.7
0D88:  BRA    0D84
*
11BE:  BCF    FF2.6
11C0:  BCF    FF2.7
11C2:  BTFSC  FF2.7
11C4:  BRA    11C0
*
1462:  BCF    FF2.6
1464:  BCF    FF2.7
1466:  BTFSC  FF2.7
1468:  BRA    1464
.................... #endif 
....................  
....................   i2c_start(); 
*
08BE:  BSF    F93.0
08C0:  MOVLW  07
08C2:  MOVWF  00
08C4:  DECFSZ 00,F
08C6:  BRA    08C4
08C8:  BSF    F93.1
08CA:  MOVLW  07
08CC:  MOVWF  00
08CE:  DECFSZ 00,F
08D0:  BRA    08CE
08D2:  BCF    F8A.0
08D4:  BCF    F93.0
08D6:  MOVLW  07
08D8:  MOVWF  00
08DA:  DECFSZ 00,F
08DC:  BRA    08DA
08DE:  BCF    F8A.1
08E0:  BCF    F93.1
*
0B12:  BSF    F93.0
0B14:  MOVLW  07
0B16:  MOVWF  00
0B18:  DECFSZ 00,F
0B1A:  BRA    0B18
0B1C:  BSF    F93.1
0B1E:  MOVLW  07
0B20:  MOVWF  00
0B22:  DECFSZ 00,F
0B24:  BRA    0B22
0B26:  BCF    F8A.0
0B28:  BCF    F93.0
0B2A:  MOVLW  07
0B2C:  MOVWF  00
0B2E:  DECFSZ 00,F
0B30:  BRA    0B2E
0B32:  BCF    F8A.1
0B34:  BCF    F93.1
*
0D8A:  BSF    F93.0
0D8C:  MOVLW  07
0D8E:  MOVWF  00
0D90:  DECFSZ 00,F
0D92:  BRA    0D90
0D94:  BSF    F93.1
0D96:  MOVLW  07
0D98:  MOVWF  00
0D9A:  DECFSZ 00,F
0D9C:  BRA    0D9A
0D9E:  BCF    F8A.0
0DA0:  BCF    F93.0
0DA2:  MOVLW  07
0DA4:  MOVWF  00
0DA6:  DECFSZ 00,F
0DA8:  BRA    0DA6
0DAA:  BCF    F8A.1
0DAC:  BCF    F93.1
*
11C6:  BSF    F93.0
11C8:  MOVLW  07
11CA:  MOVWF  00
11CC:  DECFSZ 00,F
11CE:  BRA    11CC
11D0:  BSF    F93.1
11D2:  MOVLW  07
11D4:  MOVWF  00
11D6:  DECFSZ 00,F
11D8:  BRA    11D6
11DA:  BCF    F8A.0
11DC:  BCF    F93.0
11DE:  MOVLW  07
11E0:  MOVWF  00
11E2:  DECFSZ 00,F
11E4:  BRA    11E2
11E6:  BCF    F8A.1
11E8:  BCF    F93.1
*
146A:  BSF    F93.0
146C:  MOVLW  07
146E:  MOVWF  00
1470:  DECFSZ 00,F
1472:  BRA    1470
1474:  BSF    F93.1
1476:  MOVLW  07
1478:  MOVWF  00
147A:  DECFSZ 00,F
147C:  BRA    147A
147E:  BCF    F8A.0
1480:  BCF    F93.0
1482:  MOVLW  07
1484:  MOVWF  00
1486:  DECFSZ 00,F
1488:  BRA    1486
148A:  BCF    F8A.1
148C:  BCF    F93.1
....................   i2c_write(0xD0); 
*
08E2:  MOVLW  D0
08E4:  MOVWF  xB8
08E6:  RCALL  02D0
*
0B36:  MOVLW  D0
0B38:  MOVWF  xB8
0B3A:  CALL   02D0
*
0DAE:  MOVLW  D0
0DB0:  MOVWF  xB8
0DB2:  CALL   02D0
*
11EA:  MOVLW  D0
11EC:  MOVWF  xB8
11EE:  CALL   02D0
*
148E:  MOVLW  D0
1490:  MOVWF  xB8
1492:  CALL   02D0
....................   i2c_write(0x00); 
*
08E8:  CLRF   xB8
08EA:  RCALL  02D0
*
0B3E:  CLRF   xB8
0B40:  CALL   02D0
*
0DB6:  CLRF   xB8
0DB8:  CALL   02D0
*
11F2:  CLRF   xB8
11F4:  CALL   02D0
*
1496:  CLRF   xB8
1498:  CALL   02D0
....................   i2c_start(); 
*
08EC:  BSF    F93.0
08EE:  MOVLW  07
08F0:  MOVWF  00
08F2:  DECFSZ 00,F
08F4:  BRA    08F2
08F6:  BSF    F93.1
08F8:  MOVLW  07
08FA:  MOVWF  00
08FC:  DECFSZ 00,F
08FE:  BRA    08FC
0900:  BTFSS  F81.1
0902:  BRA    0900
0904:  BCF    F8A.0
0906:  BCF    F93.0
0908:  MOVLW  07
090A:  MOVWF  00
090C:  DECFSZ 00,F
090E:  BRA    090C
0910:  BCF    F8A.1
0912:  BCF    F93.1
*
0B44:  BSF    F93.0
0B46:  MOVLW  07
0B48:  MOVWF  00
0B4A:  DECFSZ 00,F
0B4C:  BRA    0B4A
0B4E:  BSF    F93.1
0B50:  MOVLW  07
0B52:  MOVWF  00
0B54:  DECFSZ 00,F
0B56:  BRA    0B54
0B58:  BTFSS  F81.1
0B5A:  BRA    0B58
0B5C:  BCF    F8A.0
0B5E:  BCF    F93.0
0B60:  MOVLW  07
0B62:  MOVWF  00
0B64:  DECFSZ 00,F
0B66:  BRA    0B64
0B68:  BCF    F8A.1
0B6A:  BCF    F93.1
*
0DBC:  BSF    F93.0
0DBE:  MOVLW  07
0DC0:  MOVWF  00
0DC2:  DECFSZ 00,F
0DC4:  BRA    0DC2
0DC6:  BSF    F93.1
0DC8:  MOVLW  07
0DCA:  MOVWF  00
0DCC:  DECFSZ 00,F
0DCE:  BRA    0DCC
0DD0:  BTFSS  F81.1
0DD2:  BRA    0DD0
0DD4:  BCF    F8A.0
0DD6:  BCF    F93.0
0DD8:  MOVLW  07
0DDA:  MOVWF  00
0DDC:  DECFSZ 00,F
0DDE:  BRA    0DDC
0DE0:  BCF    F8A.1
0DE2:  BCF    F93.1
*
11F8:  BSF    F93.0
11FA:  MOVLW  07
11FC:  MOVWF  00
11FE:  DECFSZ 00,F
1200:  BRA    11FE
1202:  BSF    F93.1
1204:  MOVLW  07
1206:  MOVWF  00
1208:  DECFSZ 00,F
120A:  BRA    1208
120C:  BTFSS  F81.1
120E:  BRA    120C
1210:  BCF    F8A.0
1212:  BCF    F93.0
1214:  MOVLW  07
1216:  MOVWF  00
1218:  DECFSZ 00,F
121A:  BRA    1218
121C:  BCF    F8A.1
121E:  BCF    F93.1
*
149C:  BSF    F93.0
149E:  MOVLW  07
14A0:  MOVWF  00
14A2:  DECFSZ 00,F
14A4:  BRA    14A2
14A6:  BSF    F93.1
14A8:  MOVLW  07
14AA:  MOVWF  00
14AC:  DECFSZ 00,F
14AE:  BRA    14AC
14B0:  BTFSS  F81.1
14B2:  BRA    14B0
14B4:  BCF    F8A.0
14B6:  BCF    F93.0
14B8:  MOVLW  07
14BA:  MOVWF  00
14BC:  DECFSZ 00,F
14BE:  BRA    14BC
14C0:  BCF    F8A.1
14C2:  BCF    F93.1
....................   i2c_write(0xD1); 
*
0914:  MOVLW  D1
0916:  MOVWF  xB8
0918:  RCALL  02D0
*
0B6C:  MOVLW  D1
0B6E:  MOVWF  xB8
0B70:  CALL   02D0
*
0DE4:  MOVLW  D1
0DE6:  MOVWF  xB8
0DE8:  CALL   02D0
*
1220:  MOVLW  D1
1222:  MOVWF  xB8
1224:  CALL   02D0
*
14C4:  MOVLW  D1
14C6:  MOVWF  xB8
14C8:  CALL   02D0
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
091A:  MOVLW  01
091C:  MOVWF  00
091E:  RCALL  033C
0920:  MOVF   01,W
0922:  ANDLW  7F
0924:  MOVWF  xB4
0926:  MOVWF  xB9
0928:  RCALL  03A2
092A:  MOVFF  01,1D
*
0B74:  MOVLW  01
0B76:  MOVWF  00
0B78:  CALL   033C
0B7C:  MOVF   01,W
0B7E:  ANDLW  7F
0B80:  MOVWF  xB4
0B82:  MOVWF  xB9
0B84:  RCALL  03A2
0B86:  MOVFF  01,1D
*
0DEC:  MOVLW  01
0DEE:  MOVWF  00
0DF0:  CALL   033C
0DF4:  MOVF   01,W
0DF6:  ANDLW  7F
0DF8:  MOVWF  xB4
0DFA:  MOVWF  xB9
0DFC:  CALL   03A2
0E00:  MOVFF  01,1D
*
1228:  MOVLW  01
122A:  MOVWF  00
122C:  CALL   033C
1230:  MOVF   01,W
1232:  ANDLW  7F
1234:  MOVWF  xB4
1236:  MOVWF  xB9
1238:  CALL   03A2
123C:  MOVFF  01,1D
*
14CC:  MOVLW  01
14CE:  MOVWF  00
14D0:  CALL   033C
14D4:  MOVF   01,W
14D6:  ANDLW  7F
14D8:  MOVWF  xB4
14DA:  MOVWF  xB9
14DC:  CALL   03A2
14E0:  MOVFF  01,1D
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
092E:  MOVLW  01
0930:  MOVWF  00
0932:  RCALL  033C
0934:  MOVF   01,W
0936:  ANDLW  7F
0938:  MOVWF  xB4
093A:  MOVWF  xB9
093C:  RCALL  03A2
093E:  MOVFF  01,1C
*
0B8A:  MOVLW  01
0B8C:  MOVWF  00
0B8E:  CALL   033C
0B92:  MOVF   01,W
0B94:  ANDLW  7F
0B96:  MOVWF  xB4
0B98:  MOVWF  xB9
0B9A:  RCALL  03A2
0B9C:  MOVFF  01,1C
*
0E04:  MOVLW  01
0E06:  MOVWF  00
0E08:  CALL   033C
0E0C:  MOVF   01,W
0E0E:  ANDLW  7F
0E10:  MOVWF  xB4
0E12:  MOVWF  xB9
0E14:  CALL   03A2
0E18:  MOVFF  01,1C
*
1240:  MOVLW  01
1242:  MOVWF  00
1244:  CALL   033C
1248:  MOVF   01,W
124A:  ANDLW  7F
124C:  MOVWF  xB4
124E:  MOVWF  xB9
1250:  CALL   03A2
1254:  MOVFF  01,1C
*
14E4:  MOVLW  01
14E6:  MOVWF  00
14E8:  CALL   033C
14EC:  MOVF   01,W
14EE:  ANDLW  7F
14F0:  MOVWF  xB4
14F2:  MOVWF  xB9
14F4:  CALL   03A2
14F8:  MOVFF  01,1C
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
0942:  CLRF   00
0944:  RCALL  033C
0946:  MOVF   01,W
0948:  ANDLW  3F
094A:  MOVWF  xB4
094C:  MOVWF  xB9
094E:  RCALL  03A2
0950:  MOVFF  01,1B
*
0BA0:  CLRF   00
0BA2:  CALL   033C
0BA6:  MOVF   01,W
0BA8:  ANDLW  3F
0BAA:  MOVWF  xB4
0BAC:  MOVWF  xB9
0BAE:  CALL   03A2
0BB2:  MOVFF  01,1B
*
0E1C:  CLRF   00
0E1E:  CALL   033C
0E22:  MOVF   01,W
0E24:  ANDLW  3F
0E26:  MOVWF  xB4
0E28:  MOVWF  xB9
0E2A:  CALL   03A2
0E2E:  MOVFF  01,1B
*
1258:  CLRF   00
125A:  CALL   033C
125E:  MOVF   01,W
1260:  ANDLW  3F
1262:  MOVWF  xB4
1264:  MOVWF  xB9
1266:  CALL   03A2
126A:  MOVFF  01,1B
*
14FC:  CLRF   00
14FE:  CALL   033C
1502:  MOVF   01,W
1504:  ANDLW  3F
1506:  MOVWF  xB4
1508:  MOVWF  xB9
150A:  CALL   03A2
150E:  MOVFF  01,1B
....................   i2c_stop(); 
*
0954:  BCF    F93.0
0956:  NOP   
0958:  BSF    F93.1
095A:  BTFSS  F81.1
095C:  BRA    095A
095E:  MOVLW  07
0960:  MOVWF  00
0962:  DECFSZ 00,F
0964:  BRA    0962
0966:  BRA    0968
0968:  NOP   
096A:  BSF    F93.0
096C:  MOVLW  07
096E:  MOVWF  00
0970:  DECFSZ 00,F
0972:  BRA    0970
*
0BB6:  BCF    F93.0
0BB8:  NOP   
0BBA:  BSF    F93.1
0BBC:  BTFSS  F81.1
0BBE:  BRA    0BBC
0BC0:  MOVLW  07
0BC2:  MOVWF  00
0BC4:  DECFSZ 00,F
0BC6:  BRA    0BC4
0BC8:  BRA    0BCA
0BCA:  NOP   
0BCC:  BSF    F93.0
0BCE:  MOVLW  07
0BD0:  MOVWF  00
0BD2:  DECFSZ 00,F
0BD4:  BRA    0BD2
*
0E32:  BCF    F93.0
0E34:  NOP   
0E36:  BSF    F93.1
0E38:  BTFSS  F81.1
0E3A:  BRA    0E38
0E3C:  MOVLW  07
0E3E:  MOVWF  00
0E40:  DECFSZ 00,F
0E42:  BRA    0E40
0E44:  BRA    0E46
0E46:  NOP   
0E48:  BSF    F93.0
0E4A:  MOVLW  07
0E4C:  MOVWF  00
0E4E:  DECFSZ 00,F
0E50:  BRA    0E4E
*
126E:  BCF    F93.0
1270:  NOP   
1272:  BSF    F93.1
1274:  BTFSS  F81.1
1276:  BRA    1274
1278:  MOVLW  07
127A:  MOVWF  00
127C:  DECFSZ 00,F
127E:  BRA    127C
1280:  BRA    1282
1282:  NOP   
1284:  BSF    F93.0
1286:  MOVLW  07
1288:  MOVWF  00
128A:  DECFSZ 00,F
128C:  BRA    128A
*
1512:  BCF    F93.0
1514:  NOP   
1516:  BSF    F93.1
1518:  BTFSS  F81.1
151A:  BRA    1518
151C:  MOVLW  07
151E:  MOVWF  00
1520:  DECFSZ 00,F
1522:  BRA    1520
1524:  BRA    1526
1526:  NOP   
1528:  BSF    F93.0
152A:  MOVLW  07
152C:  MOVWF  00
152E:  DECFSZ 00,F
1530:  BRA    152E
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
0974:  MOVLW  C0
0976:  IORWF  FF2,F
*
0BD6:  MOVLW  C0
0BD8:  IORWF  FF2,F
*
0E52:  MOVLW  C0
0E54:  IORWF  FF2,F
*
128E:  MOVLW  C0
1290:  IORWF  FF2,F
*
1532:  MOVLW  C0
1534:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
03C8:  MOVFF  B7,B8
....................   retval = 0; 
03CC:  CLRF   xB9
....................   while(1){ 
....................     if(temp >= 10){ 
03CE:  MOVF   xB8,W
03D0:  SUBLW  09
03D2:  BC    03DE
....................       temp -= 10; 
03D4:  MOVLW  0A
03D6:  SUBWF  xB8,F
....................       retval += 0x10; 
03D8:  MOVLW  10
03DA:  ADDWF  xB9,F
....................     }else{ 
03DC:  BRA    03E4
....................       retval += temp; 
03DE:  MOVF   xB8,W
03E0:  ADDWF  xB9,F
....................       break; 
03E2:  BRA    03E6
....................     } 
....................   } 
03E4:  BRA    03CE
....................   return(retval); 
03E6:  MOVFF  B9,01
.................... } 
03EA:  GOTO   04C6 (RETURN)
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
03A2:  MOVFF  B9,BA
....................   temp >>= 1; 
03A6:  BCF    FD8.0
03A8:  RRCF   xBA,F
....................   temp &= 0x78; 
03AA:  MOVLW  78
03AC:  ANDWF  xBA,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
03AE:  RRCF   xBA,W
03B0:  MOVWF  00
03B2:  RRCF   00,F
03B4:  MOVLW  3F
03B6:  ANDWF  00,F
03B8:  MOVF   00,W
03BA:  ADDWF  xBA,W
03BC:  MOVWF  xBB
03BE:  MOVF   xB9,W
03C0:  ANDLW  0F
03C2:  ADDWF  xBB,W
03C4:  MOVWF  01
.................... } 
03C6:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, int16 *buffer); 
.................... #endif 
....................  
....................  
.................... #define ADC_TAD_MUL_2      0x08 
.................... #define ADC_INPUT_PORT	0x07 
.................... int AD_init_adc(){ 
.................... 	setup_adc_ports(AN0_TO_AN2); 
*
027C:  MOVF   FC1,W
027E:  ANDLW  C0
0280:  IORLW  0C
0282:  MOVWF  FC1
....................  
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #endif 
.................... */	 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
0284:  BCF    FC0.0
0286:  BSF    FC0.1
0288:  BCF    FC0.2
028A:  BSF    FC0.7
028C:  BSF    FC2.0
.................... 	set_tris_a(ADC_INPUT_PORT);		//RB0 a RB1 entradas 
028E:  MOVLW  07
0290:  MOVWF  F92
.................... 	return 0; 
0292:  MOVLW  00
0294:  MOVWF  01
.................... } 
0296:  GOTO   0654 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
06BA:  RLCF   xB4,W
06BC:  MOVWF  00
06BE:  RLCF   00,F
06C0:  MOVLW  FC
06C2:  ANDWF  00,F
06C4:  MOVF   FC2,W
06C6:  ANDLW  C3
06C8:  IORWF  00,W
06CA:  MOVWF  FC2
.................... 	delay_us(10); 
06CC:  MOVLW  13
06CE:  MOVWF  00
06D0:  DECFSZ 00,F
06D2:  BRA    06D0
06D4:  BRA    06D6
.................... 	read_adc(ADC_START_ONLY); 
06D6:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
06D8:  BCF    xB7.0
06DA:  BTFSS  FC2.1
06DC:  BSF    xB7.0
.................... 	}while(!done); 
06DE:  BTFSS  xB7.0
06E0:  BRA    06D8
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
06E2:  MOVFF  B6,03
06E6:  MOVFF  B5,FE9
06EA:  MOVFF  B6,FEA
06EE:  BTFSC  FC2.1
06F0:  BRA    06EE
06F2:  MOVFF  FC3,FEF
06F6:  MOVFF  FC4,FEC
.................... 	delay_us(1); 
06FA:  BRA    06FC
06FC:  BRA    06FE
06FE:  BRA    0700
.................... 	return 0; 
0700:  MOVLW  00
0702:  MOVWF  01
.................... } 
0704:  RETLW  00
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #endif 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_1|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
0180:  INCF   xAB,F
.................... } 
....................  
0182:  BCF    FA1.1
0184:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
0188:  MOVF   xAA,W
018A:  SUBLW  FF
018C:  BNZ   019E
....................    	setup_ccp1(CCP_CAPTURE_FE); 
018E:  BSF    F94.2
0190:  CLRF   FBD
0192:  MOVLW  04
0194:  MOVWF  FBD
0196:  CLRF   FB7
0198:  CLRF   FB6
....................    	Q_CCP = 0; 
019A:  CLRF   xAA
....................    }else if(Q_CCP == 0){ 
019C:  BRA    01FC
019E:  MOVF   xAA,F
01A0:  BNZ   01C6
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
01A2:  CLRF   01
01A4:  CLRF   xCD
01A6:  CLRF   xCE
01A8:  MOVF   FBE,W
01AA:  ADDWF  xCD,W
01AC:  MOVWF  xB0
01AE:  MOVF   FBF,W
01B0:  ADDWFC xCE,W
01B2:  MOVWF  xB1
01B4:  MOVLW  00
01B6:  ADDWFC xAB,W
01B8:  MOVWF  xB2
01BA:  MOVLW  00
01BC:  ADDWFC 01,W
01BE:  MOVWF  xB3
....................    	Q_CCP = 1; 
01C0:  MOVLW  01
01C2:  MOVWF  xAA
....................    }else if(Q_CCP == 1){ 
01C4:  BRA    01FC
01C6:  DECFSZ xAA,W
01C8:  BRA    01FC
....................    	tiempo_inicial = tiempo_final; 
01CA:  MOVFF  B3,AF
01CE:  MOVFF  B2,AE
01D2:  MOVFF  B1,AD
01D6:  MOVFF  B0,AC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
01DA:  CLRF   01
01DC:  CLRF   xCD
01DE:  CLRF   xCE
01E0:  MOVF   FBE,W
01E2:  ADDWF  xCD,W
01E4:  MOVWF  xB0
01E6:  MOVF   FBF,W
01E8:  ADDWFC xCE,W
01EA:  MOVWF  xB1
01EC:  MOVLW  00
01EE:  ADDWFC xAB,W
01F0:  MOVWF  xB2
01F2:  MOVLW  00
01F4:  ADDWFC 01,W
01F6:  MOVWF  xB3
....................    	Q_CCP = 2; 
01F8:  MOVLW  02
01FA:  MOVWF  xAA
....................    } 
.................... } 
....................  
01FC:  BCF    F9E.2
01FE:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
0202:  MOVF   xAA,W
0204:  SUBLW  FF
0206:  BNZ   0218
....................    	setup_ccp1(CCP_CAPTURE_FE); 
0208:  BSF    F94.2
020A:  CLRF   FBD
020C:  MOVLW  04
020E:  MOVWF  FBD
0210:  CLRF   FB7
0212:  CLRF   FB6
....................    	Q_CCP = 0; 
0214:  CLRF   xAA
....................    }else if(Q_CCP == 0){ 
0216:  BRA    0276
0218:  MOVF   xAA,F
021A:  BNZ   0240
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
021C:  CLRF   01
021E:  CLRF   xCD
0220:  CLRF   xCE
0222:  MOVF   FBB,W
0224:  ADDWF  xCD,W
0226:  MOVWF  xB0
0228:  MOVF   FBC,W
022A:  ADDWFC xCE,W
022C:  MOVWF  xB1
022E:  MOVLW  00
0230:  ADDWFC xAB,W
0232:  MOVWF  xB2
0234:  MOVLW  00
0236:  ADDWFC 01,W
0238:  MOVWF  xB3
....................    	Q_CCP = 1; 
023A:  MOVLW  01
023C:  MOVWF  xAA
....................    }else if(Q_CCP == 1){ 
023E:  BRA    0276
0240:  DECFSZ xAA,W
0242:  BRA    0276
....................    	tiempo_inicial = tiempo_final; 
0244:  MOVFF  B3,AF
0248:  MOVFF  B2,AE
024C:  MOVFF  B1,AD
0250:  MOVFF  B0,AC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
0254:  CLRF   01
0256:  CLRF   xCD
0258:  CLRF   xCE
025A:  MOVF   FBB,W
025C:  ADDWF  xCD,W
025E:  MOVWF  xB0
0260:  MOVF   FBC,W
0262:  ADDWFC xCE,W
0264:  MOVWF  xB1
0266:  MOVLW  00
0268:  ADDWFC xAB,W
026A:  MOVWF  xB2
026C:  MOVLW  00
026E:  ADDWFC 01,W
0270:  MOVWF  xB3
....................    	Q_CCP = 2; 
0272:  MOVLW  02
0274:  MOVWF  xAA
....................    } 
.................... } 
....................  
0276:  BCF    FA1.0
0278:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
*
029A:  MOVFF  A7,FB1
....................    T3CON.TMR3ON = 0; 
029E:  BCF    FB1.0
....................    set_timer3(0); 
02A0:  CLRF   FB3
02A2:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
02A4:  MOVF   xA8,W
02A6:  ANDLW  08
02A8:  BTFSC  FD8.2
02AA:  BCF    F82.2
02AC:  CLRF   FBD
02AE:  MOVFF  A8,FBD
02B2:  CLRF   FB7
02B4:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
02B6:  MOVF   xA9,W
02B8:  ANDLW  08
02BA:  BTFSC  FD8.2
02BC:  BCF    F82.1
02BE:  CLRF   FBA
02C0:  MOVFF  A9,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1  ;                        
02C4:  BSF    F94.2
02C6:  BSF    F94.1
....................    return 0; 
02C8:  MOVLW  00
02CA:  MOVWF  01
.................... } 
02CC:  GOTO   065A (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    //int32 resultado = 0; 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
*
1020:  MOVLW  C0
1022:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
1024:  BSF    FA0.1
....................    set_timer3(0);      					//se reset timer  a 0 
1026:  CLRF   FB3
1028:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
102A:  BSF    FB1.0
....................    /*if(canal == CANAL_1){ 
....................       enable_interrupts(INT_CCP1);   //si es el canal 1 se habilita la interrupcion del modulo CCP1 
....................    }else if(canal == CANAL_2){ 
....................       enable_interrupts(INT_CCP2);   //si es el canal 2 se habilita la interrupcion del modulo CCP2 
....................    }else{return (1);}*/ 
....................    (canal == CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
102C:  DECFSZ xB4,W
102E:  BRA    1034
1030:  BSF    F9D.2
1032:  BRA    1036
1034:  BSF    FA0.0
....................    while(Q_CCP != 2){;}             //espera a que se carguen los valores de los tiempos 
1036:  MOVF   xAA,W
1038:  SUBLW  02
103A:  BZ    103E
103C:  BRA    1036
....................    disable_interrupts(INT_CCP1); 
103E:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
1040:  BCF    FA0.0
....................    setup_ccp2(MODO_CCP1); 
1042:  MOVF   xA8,W
1044:  ANDLW  08
1046:  BTFSC  FD8.2
1048:  BCF    F82.1
104A:  CLRF   FBA
104C:  MOVFF  A8,FBA
....................    setup_ccp2(MODO_CCP2); 
1050:  MOVF   xA9,W
1052:  ANDLW  08
1054:  BTFSC  FD8.2
1056:  BCF    F82.1
1058:  CLRF   FBA
105A:  MOVFF  A9,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
105E:  MOVLW  FF
1060:  MOVWF  xAA
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
1062:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
1064:  CLRF   xAB
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
1066:  MOVFF  B5,FE9
106A:  MOVFF  B6,FEA
106E:  MOVF   xAC,W
1070:  SUBWF  xB0,W
1072:  MOVWF  00
1074:  MOVF   xAD,W
1076:  SUBWFB xB1,W
1078:  MOVWF  01
107A:  MOVF   xAE,W
107C:  SUBWFB xB2,W
107E:  MOVWF  02
1080:  MOVF   xAF,W
1082:  SUBWFB xB3,W
1084:  MOVFF  00,FEF
1088:  MOVFF  01,FEC
108C:  MOVFF  02,FEC
1090:  MOVWF  FEC
....................    return (0); 
1092:  MOVLW  00
1094:  MOVWF  01
.................... } 
1096:  RETLW  00

Configuration Fuses:
   Word  1: CE3F   IESO FCMEN HSPLL PLL12 CPUDIV4 USBDIV
   Word  2: 0E39   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
