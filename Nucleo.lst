CCS PCH C Compiler, Version 4.105, 13255               09-Sep-14 11:24

               Filename: G:\Project\pic\CCS\Pruebas\Nucleo.lst

               ROM used: 12634 bytes (39%)
                         Largest free fragment is 20134
               RAM used: 652 (32%) at main() level
                         878 (43%) worst case
               Stack:    20 worst case (10 in main + 10 for interrupts)

*
0000:  GOTO   2CA6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   20FE
0060:  BTFSS  F9D.2
0062:  GOTO   006C
0066:  BTFSC  F9E.2
0068:  GOTO   2106
006C:  BTFSS  FA0.0
006E:  GOTO   0078
0072:  BTFSC  FA1.0
0074:  GOTO   21AA
0078:  BTFSS  FA0.5
007A:  GOTO   0084
007E:  BTFSC  FA1.5
0080:  GOTO   0FD0
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "Nucleo.h" 
.................... /*=========================Configuracion del Hardware========================== 
....................  
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentandolo a 96Mhz-> div:2 a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU 
....................  
.................... ==============================================================================*/ 
....................  
.................... /*=================== FILE HEADER ===================================*/ 
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... //#include "PIC18F4550.h" 
.................... #device adc=10 
.................... //#define SIMULACION 1   // comentar esto si se prueba en forma real 
....................  
.................... /*====================fuses de configuracion del dispositivo==================*/ 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN,NOPBADEN,CCP2C1 
.................... /* 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.1V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage programing, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5                     //(PLL prescaler) PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3                  //postscaler PLL div by 4 (whit pll enable)                      
.................... #FUSES USBDIV                  //enable USBDIV, USB clock source come from PLL divide by 2 
.................... #FUSES VREGEN                  //internal regulator USB enable 
.................... #FUSES ICPRT                   
.................... #FUSES CCP2C1                  //CPP input/output multiplexed whit RC1 
....................  
....................  
.................... /*============================ DEFINICIONES DE PINES =========================*/ 
.................... #define PIN_SDA   PIN_B0 
.................... #define PIN_SCL   PIN_B1 
....................  
.................... //#define PIN_XMIT   PIN_C6 
.................... //#define PIN_RCV   PIN_C7 
....................  
.................... #define PIN_XMIT   PIN_D0 
.................... #define PIN_RCV   PIN_D1 
....................  
....................     
.................... #define PIN_LOG   PIN_D2 
....................  
.................... #define SPI_SS      PIN_D7 
.................... #define SPI_MISO   PIN_D6 
.................... #define SPI_MOSI   PIN_D5 
.................... #define SPI_SCL   PIN_D4 
....................  
.................... #define CONFIG_PORT_C   0x83      //v1 
.................... #define CONFIG_PORT_D   0x4E      //v2 
....................  
....................  
.................... /*=================== CONFIGURACION DEL RELOJ DE TRABAJO =====================*/ 
.................... #use delay(clock=16000000)   //cambiar el valor del clock si se cambia la frecuencia de la CPU 
*
17D0:  MOVLW  04
17D2:  MOVLB  2
17D4:  SUBWF  x97,F
17D6:  BNC   17EC
17D8:  MOVLW  02
17DA:  MOVWF  FEA
17DC:  MOVLW  97
17DE:  MOVWF  FE9
17E0:  MOVF   FEF,W
17E2:  BZ    17EC
17E4:  BRA    17E8
17E6:  NOP   
17E8:  DECFSZ FEF,F
17EA:  BRA    17E6
17EC:  MOVLB  0
17EE:  GOTO   1808 (RETURN)
*
22A8:  MOVLW  01
22AA:  MOVWF  FEA
22AC:  MOVLW  DC
22AE:  MOVWF  FE9
22B0:  MOVF   FEF,W
22B2:  BZ    22D0
22B4:  MOVLW  05
22B6:  MOVWF  01
22B8:  CLRF   00
22BA:  DECFSZ 00,F
22BC:  BRA    22BA
22BE:  DECFSZ 01,F
22C0:  BRA    22B8
22C2:  MOVLW  2E
22C4:  MOVWF  00
22C6:  DECFSZ 00,F
22C8:  BRA    22C6
22CA:  BRA    22CC
22CC:  DECFSZ FEF,F
22CE:  BRA    22B4
22D0:  RETLW  00
....................  
.................... /*=================== CONFIGURACION LIBRERIAS DE COMUNICACION ================*/ 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
.................... //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#use i2c(master, sda=PIN_B0, scl=PIN_B1) 
.................... //#use fixed_io(b_outputs=PIN_B0, PIN_B1) 
.................... //#use i2c(master, FORCE_HW) 
.................... /*=================== LIBRERIAS ESTANDAR PARA EL MANEJO DE DATOS =============*/ 
....................  
.................... #endif   //ifndef NUCLEO_H 
....................  
.................... #define use_rtos 
.................... #ifdef use_rtos 
....................    #use RTOS(timer=0, minor_cycle=50ms, statistics) 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
1630:  MOVFF  293,298
1634:  MOVFF  292,297
1638:  MOVLB  2
163A:  MOVF   x96,F
163C:  BZ    1686
163E:  MOVFF  295,03
1642:  MOVFF  294,FE9
1646:  MOVFF  295,FEA
164A:  MOVF   FEF,F
164C:  BZ    1686
....................      *s++ = *s2++; 
164E:  MOVFF  298,03
1652:  MOVF   x97,W
1654:  INCF   x97,F
1656:  BTFSC  FD8.2
1658:  INCF   x98,F
165A:  MOVWF  x99
165C:  MOVFF  03,29A
1660:  MOVFF  295,03
1664:  MOVF   x94,W
1666:  INCF   x94,F
1668:  BTFSC  FD8.2
166A:  INCF   x95,F
166C:  MOVWF  FE9
166E:  MOVFF  03,FEA
1672:  MOVFF  FEF,29B
1676:  MOVFF  29A,FEA
167A:  MOVFF  299,FE9
167E:  MOVFF  29B,FEF
1682:  DECF   x96,F
1684:  BRA    163A
....................   for (; n > 0; n--) 
1686:  MOVF   x96,F
1688:  BZ    16A2
....................      *s++ = '\0'; 
168A:  MOVFF  298,03
168E:  MOVF   x97,W
1690:  INCF   x97,F
1692:  BTFSC  FD8.2
1694:  INCF   x98,F
1696:  MOVWF  FE9
1698:  MOVFF  03,FEA
169C:  CLRF   FEF
169E:  DECF   x96,F
16A0:  BRA    1686
....................  
....................   return(s1); 
16A2:  MOVFF  292,01
16A6:  MOVFF  293,02
.................... } 
16AA:  MOVLB  0
16AC:  GOTO   170C (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1434:  MOVFF  293,295
1438:  MOVFF  292,294
143C:  MOVFF  295,03
1440:  MOVLB  2
1442:  MOVFF  294,FE9
1446:  MOVFF  295,FEA
144A:  MOVF   FEF,F
144C:  BZ    145A
144E:  INCF   x94,F
1450:  BTFSC  FD8.2
1452:  INCF   x95,F
1454:  MOVLB  0
1456:  BRA    143C
1458:  MOVLB  2
....................    return(sc - s); 
145A:  MOVF   x92,W
145C:  SUBWF  x94,W
145E:  MOVWF  00
1460:  MOVF   x93,W
1462:  SUBWFB x95,W
1464:  MOVWF  03
1466:  MOVFF  00,01
.................... } 
146A:  MOVLB  0
146C:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// Two examples are provided:                                        //// 
.................... ////      ex_usb_serial.c                                              //// 
.................... ////      ex_usb_serial2.c                                             //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /*============================================================================ 
.................... CDC USB descriptor propio para el manejo de datos por usb 
....................  
....................  
....................  
....................  
....................  
.................... ============================================================================*/ 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x000B 
.................... #define  USB_CONFIG_VID       0x04D8 
.................... #define  USB_CONFIG_BUS_POWER 0x64   		//100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #define USB_HID_DEVICE  FALSE 
.................... #define USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................     
....................    /*	 
....................    ////////////////////////////////////////// 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................    /////////////////////////////////////////// 
....................    */ 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
....................          0x0B,0x00, //product id   ==10,11 
....................          0x00,0x01, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //#if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          40, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          '_',0, 
....................          'C',0, 
....................          'o',0, 
....................          'n',0, 
....................          't',0, 
....................          'r',0, 
....................          'o',0, 
....................          'l',0, 
....................          '_',0, 
....................          'D',0, 
....................          'e',0, 
....................          'v',0, 
....................          'i',0, 
....................          'c',0, 
....................          'e',0, 
....................          's',0 
....................  
.................... }; 
.................... //#endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0B32:  CLRF   03
0B34:  MOVLB  2
0B36:  MOVF   xBB,W
0B38:  ADDLW  70
0B3A:  MOVWF  FE9
0B3C:  MOVLW  0F
0B3E:  ADDWFC 03,W
0B40:  MOVWF  FEA
0B42:  MOVF   FEF,F
0B44:  BZ    0B6A
0B46:  MOVF   xBB,W
0B48:  MULLW  08
0B4A:  MOVF   FF3,W
0B4C:  CLRF   xBD
0B4E:  MOVWF  xBC
0B50:  MOVLW  04
0B52:  ADDWF  xBC,F
0B54:  MOVLW  00
0B56:  ADDWFC xBD,F
0B58:  MOVFF  2BC,FE9
0B5C:  MOVLW  04
0B5E:  ADDWF  xBD,W
0B60:  MOVWF  FEA
0B62:  MOVFF  FEF,2BC
0B66:  BTFSS  xBC.7
0B68:  BRA    0B6E
0B6A:  MOVLW  00
0B6C:  BRA    0B70
0B6E:  MOVLW  01
0B70:  MOVWF  01
.................... } 
0B72:  MOVLB  0
0B74:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
1AFC:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1AFE:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1B00:  MOVLW  08
1B02:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
1B04:  MOVF   F94,W
1B06:  IORLW  30
1B08:  MOVLB  2
1B0A:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1B0C:  CLRF   2B
1B0E:  CLRF   19
1B10:  BTFSC  FF2.7
1B12:  BSF    19.7
1B14:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
1B16:  MOVLB  0
1B18:  CALL   03BA
1B1C:  BTFSC  19.7
1B1E:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
1B20:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
1ADA:  CLRF   19
1ADC:  BTFSC  FF2.7
1ADE:  BSF    19.7
1AE0:  BCF    FF2.7
....................    usb_token_reset(); 
1AE2:  CALL   03BA
1AE6:  BTFSC  19.7
1AE8:  BSF    FF2.7
....................    UCON = 0; 
1AEA:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1AEC:  MOVLW  14
1AEE:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
1AF0:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1AF2:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1AF4:  MOVLW  01
1AF6:  MOVWF  2B
.................... } 
1AF8:  GOTO   1B2E (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
2292:  RCALL  1AFC
.................... } 
2294:  GOTO   22A0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
*
1B22:  BSF    F95.3
1B24:  BTFSS  F83.3
1B26:  BRA    1B30
....................    { 
....................       if (UCON_USBEN==0)  
1B28:  BTFSC  F6D.3
1B2A:  BRA    1B2E
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1B2C:  BRA    1ADA
....................       } 
....................    } 
....................    else  
1B2E:  BRA    1B36
....................    { 
....................       if (UCON_USBEN==1)   
1B30:  BTFSS  F6D.3
1B32:  BRA    1B36
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
1B34:  RCALL  1AFC
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1B36:  DECFSZ 2B,W
1B38:  BRA    1B50
1B3A:  BTFSC  F6D.5
1B3C:  BRA    1B50
....................    { 
....................       UIR=0; 
1B3E:  CLRF   F68
....................       UIE=0; 
1B40:  CLRF   F69
....................       enable_interrupts(INT_USB); 
1B42:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1B44:  MOVLW  C0
1B46:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1B48:  MOVLW  11
1B4A:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1B4C:  MOVLW  02
1B4E:  MOVWF  2B
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1B50:  GOTO   1B5E (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0B76:  MOVFF  2B6,2BB
0B7A:  RCALL  0B32
0B7C:  MOVF   01,F
0B7E:  BZ    0C48
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0B80:  MOVLB  2
0B82:  MOVF   xB6,W
0B84:  MULLW  08
0B86:  MOVF   FF3,W
0B88:  CLRF   xBC
0B8A:  MOVWF  xBB
0B8C:  MOVLW  04
0B8E:  ADDWF  xBB,F
0B90:  MOVLW  00
0B92:  ADDWFC xBC,F
0B94:  MOVLW  01
0B96:  ADDWF  xBB,W
0B98:  MOVWF  01
0B9A:  MOVLW  00
0B9C:  ADDWFC xBC,W
0B9E:  MOVWF  03
0BA0:  MOVFF  01,FE9
0BA4:  MOVLW  04
0BA6:  ADDWF  03,W
0BA8:  MOVWF  FEA
0BAA:  MOVFF  2B7,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0BAE:  MOVF   xB9,W
0BB0:  SUBLW  02
0BB2:  BNZ   0BE2
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0BB4:  MOVF   xB6,W
0BB6:  MULLW  08
0BB8:  MOVF   FF3,W
0BBA:  CLRF   xBC
0BBC:  MOVWF  xBB
0BBE:  MOVLW  04
0BC0:  ADDWF  xBB,F
0BC2:  MOVLW  00
0BC4:  ADDWFC xBC,F
0BC6:  MOVFF  2BB,FE9
0BCA:  MOVLW  04
0BCC:  ADDWF  xBC,W
0BCE:  MOVWF  FEA
0BD0:  MOVFF  FEF,2BA
....................          if (bit_test(i,6)) 
0BD4:  BTFSS  xBA.6
0BD6:  BRA    0BDC
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0BD8:  CLRF   xB9
....................          else 
0BDA:  BRA    0BE0
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0BDC:  MOVLW  01
0BDE:  MOVWF  xB9
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0BE0:  BRA    0C08
0BE2:  MOVF   xB9,W
0BE4:  SUBLW  04
0BE6:  BNZ   0C08
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0BE8:  MOVF   xB6,W
0BEA:  MULLW  08
0BEC:  MOVF   FF3,W
0BEE:  CLRF   xBC
0BF0:  MOVWF  FE9
0BF2:  MOVLW  04
0BF4:  ADDWF  xBC,W
0BF6:  MOVWF  FEA
0BF8:  MOVFF  FEF,2BA
....................          if (bit_test(i,6)) 
0BFC:  BTFSS  xBA.6
0BFE:  BRA    0C06
....................             tgl = USB_DTS_DATA1; 
0C00:  MOVLW  01
0C02:  MOVWF  xB9
....................          else 
0C04:  BRA    0C08
....................             tgl = USB_DTS_DATA0; 
0C06:  CLRF   xB9
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0C08:  DECFSZ xB9,W
0C0A:  BRA    0C12
....................          i=0xC8;  //DATA1, UOWN 
0C0C:  MOVLW  C8
0C0E:  MOVWF  xBA
....................       else //if (tgl == USB_DTS_DATA0)  
0C10:  BRA    0C16
....................          i=0x88; //DATA0, UOWN 
0C12:  MOVLW  88
0C14:  MOVWF  xBA
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0C16:  BTFSC  xB8.0
0C18:  BSF    xBA.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0C1A:  BTFSC  xB8.1
0C1C:  BSF    xBA.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0C1E:  MOVF   xB6,W
0C20:  MULLW  08
0C22:  MOVF   FF3,W
0C24:  CLRF   xBC
0C26:  MOVWF  xBB
0C28:  MOVLW  04
0C2A:  ADDWF  xBB,F
0C2C:  MOVLW  00
0C2E:  ADDWFC xBC,F
0C30:  MOVFF  2BB,FE9
0C34:  MOVLW  04
0C36:  ADDWF  xBC,W
0C38:  MOVWF  FEA
0C3A:  MOVFF  2BA,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0C3E:  MOVLW  01
0C40:  MOVWF  01
0C42:  BRA    0C4E
....................    } 
....................    else  
0C44:  BRA    0C46
0C46:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0C48:  MOVLW  00
0C4A:  MOVWF  01
0C4C:  MOVLB  2
.................... } 
0C4E:  MOVLB  0
0C50:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
0D66:  MOVFF  2AE,2BB
0D6A:  RCALL  0B32
0D6C:  MOVF   01,F
0D6E:  BZ    0DF2
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0D70:  MOVLB  2
0D72:  MOVF   xAE,W
0D74:  MULLW  08
0D76:  MOVF   FF3,W
0D78:  CLRF   xB7
0D7A:  MOVWF  xB6
0D7C:  MOVLW  04
0D7E:  ADDWF  xB6,F
0D80:  MOVLW  00
0D82:  ADDWFC xB7,F
0D84:  MOVLW  02
0D86:  ADDWF  xB6,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC xB7,W
0D8E:  MOVWF  03
0D90:  MOVFF  01,FE9
0D94:  MOVLW  04
0D96:  ADDWF  03,W
0D98:  MOVWF  FEA
0D9A:  MOVFF  FEC,03
0D9E:  MOVF   FED,F
0DA0:  MOVFF  FEF,2B4
0DA4:  MOVFF  03,2B5
....................       memcpy(buff_add, ptr, len);      
0DA8:  MOVFF  2B5,FEA
0DAC:  MOVFF  2B4,FE9
0DB0:  MOVFF  2B0,FE2
0DB4:  MOVFF  2AF,FE1
0DB8:  MOVFF  2B2,02
0DBC:  MOVFF  2B1,01
0DC0:  MOVF   01,F
0DC2:  BZ    0DC8
0DC4:  INCF   02,F
0DC6:  BRA    0DCC
0DC8:  MOVF   02,F
0DCA:  BZ    0DD8
0DCC:  MOVFF  FE6,FEE
0DD0:  DECFSZ 01,F
0DD2:  BRA    0DCC
0DD4:  DECFSZ 02,F
0DD6:  BRA    0DCC
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
0DD8:  MOVFF  2AE,2B6
0DDC:  MOVFF  2B2,2B8
0DE0:  MOVFF  2B1,2B7
0DE4:  MOVFF  2B3,2B9
0DE8:  MOVLB  0
0DEA:  RCALL  0B76
0DEC:  MOVF   01,W
0DEE:  BRA    0DF6
....................    } 
....................    else  
0DF0:  BRA    0DF2
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0DF2:  MOVLW  00
0DF4:  MOVWF  01
.................... } 
0DF6:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0A72:  MOVLB  2
0A74:  MOVF   xAE,W
0A76:  MULLW  08
0A78:  MOVF   FF3,W
0A7A:  CLRF   xB4
0A7C:  MOVWF  FE9
0A7E:  MOVLW  04
0A80:  ADDWF  xB4,W
0A82:  MOVWF  FEA
0A84:  MOVFF  FEF,2B0
....................    if (tgl == USB_DTS_TOGGLE)  
0A88:  MOVF   xAF,W
0A8A:  SUBLW  02
0A8C:  BNZ   0A9A
....................    { 
....................       if (bit_test(i,6)) 
0A8E:  BTFSS  xB0.6
0A90:  BRA    0A96
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0A92:  CLRF   xAF
....................       else 
0A94:  BRA    0A9A
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0A96:  MOVLW  01
0A98:  MOVWF  xAF
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0A9A:  MOVF   xAF,W
0A9C:  SUBLW  03
0A9E:  BNZ   0AC6
....................    { 
....................       i = 0x84; 
0AA0:  MOVLW  84
0AA2:  MOVWF  xB0
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0AA4:  MOVF   xAE,W
0AA6:  MULLW  08
0AA8:  MOVF   FF3,W
0AAA:  CLRF   xB4
0AAC:  MOVWF  xB3
0AAE:  MOVLW  04
0AB0:  ADDWF  xB3,F
0AB2:  MOVLW  00
0AB4:  ADDWFC xB4,F
0AB6:  MOVFF  2B3,FE9
0ABA:  MOVLW  04
0ABC:  ADDWF  xB4,W
0ABE:  MOVWF  FEA
0AC0:  MOVLW  84
0AC2:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0AC4:  BRA    0AD4
0AC6:  DECFSZ xAF,W
0AC8:  BRA    0AD0
....................       i = 0xC8;  //DATA1, UOWN 
0ACA:  MOVLW  C8
0ACC:  MOVWF  xB0
....................    else //if (tgl == USB_DTS_DATA0)  
0ACE:  BRA    0AD4
....................       i = 0x88; //DATA0, UOWN 
0AD0:  MOVLW  88
0AD2:  MOVWF  xB0
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0AD4:  BCF    FD8.0
0AD6:  RLCF   xAE,W
0AD8:  CLRF   03
0ADA:  MOVLB  0
0ADC:  CALL   0142
0AE0:  TBLRD*+
0AE2:  MOVFF  FF5,03
0AE6:  MOVLB  2
0AE8:  MOVWF  xB1
0AEA:  MOVFF  03,2B2
....................    EP_BDxCNT_O(endpoint) = len; 
0AEE:  MOVF   xAE,W
0AF0:  MULLW  08
0AF2:  MOVF   FF3,W
0AF4:  CLRF   xB4
0AF6:  MOVWF  xB3
0AF8:  MOVLW  01
0AFA:  ADDWF  xB3,W
0AFC:  MOVWF  01
0AFE:  MOVLW  00
0B00:  ADDWFC xB4,W
0B02:  MOVWF  03
0B04:  MOVFF  01,FE9
0B08:  MOVLW  04
0B0A:  ADDWF  03,W
0B0C:  MOVWF  FEA
0B0E:  MOVFF  2B1,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0B12:  BTFSC  xB2.0
0B14:  BSF    xB0.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0B16:  BTFSC  xB2.1
0B18:  BSF    xB0.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0B1A:  MOVF   xAE,W
0B1C:  MULLW  08
0B1E:  MOVF   FF3,W
0B20:  CLRF   xB4
0B22:  MOVWF  FE9
0B24:  MOVLW  04
0B26:  ADDWF  xB4,W
0B28:  MOVWF  FEA
0B2A:  MOVFF  2B0,FEF
.................... } 
0B2E:  MOVLB  0
0B30:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
0CC2:  MOVLB  2
0CC4:  MOVF   xAE,W
0CC6:  MULLW  08
0CC8:  MOVF   FF3,W
0CCA:  CLRF   xB0
0CCC:  MOVWF  xAF
0CCE:  MOVLW  01
0CD0:  ADDWF  xAF,W
0CD2:  MOVWF  01
0CD4:  MOVLW  00
0CD6:  ADDWFC xB0,W
0CD8:  MOVWF  03
0CDA:  MOVFF  01,FE9
0CDE:  MOVLW  04
0CE0:  ADDWF  03,W
0CE2:  MOVWF  FEA
0CE4:  CLRF   03
0CE6:  MOVFF  FEF,01
0CEA:  MOVFF  03,02
.................... } 
0CEE:  MOVLB  0
0CF0:  GOTO   0D12 (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
087A:  MOVLB  2
087C:  BCF    xAE.0
087E:  BTFSC  xAD.7
0880:  BSF    xAE.0
....................    endpoint &= 0x7F; 
0882:  BCF    xAD.7
....................     
....................    if (direction)  
0884:  BTFSS  xAE.0
0886:  BRA    08AA
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
0888:  MOVF   xAD,W
088A:  MULLW  08
088C:  MOVF   FF3,W
088E:  CLRF   xB0
0890:  MOVWF  xAF
0892:  MOVLW  04
0894:  ADDWF  xAF,F
0896:  MOVLW  00
0898:  ADDWFC xB0,F
089A:  MOVFF  2AF,FE9
089E:  MOVLW  04
08A0:  ADDWF  xB0,W
08A2:  MOVWF  FEA
08A4:  MOVLW  84
08A6:  MOVWF  FEF
....................    } 
....................    else  
08A8:  BRA    08BE
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
08AA:  MOVF   xAD,W
08AC:  MULLW  08
08AE:  MOVF   FF3,W
08B0:  CLRF   xB0
08B2:  MOVWF  FE9
08B4:  MOVLW  04
08B6:  ADDWF  xB0,W
08B8:  MOVWF  FEA
08BA:  MOVLW  84
08BC:  MOVWF  FEF
....................    } 
.................... } 
08BE:  MOVLB  0
08C0:  GOTO   0952 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0832:  MOVLB  2
0834:  BCF    xAE.0
0836:  BTFSC  xAD.7
0838:  BSF    xAE.0
....................    endpoint &= 0x7F; 
083A:  BCF    xAD.7
....................     
....................    if (direction)  
083C:  BTFSS  xAE.0
083E:  BRA    0862
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0840:  MOVF   xAD,W
0842:  MULLW  08
0844:  MOVF   FF3,W
0846:  CLRF   xB0
0848:  MOVWF  xAF
084A:  MOVLW  04
084C:  ADDWF  xAF,F
084E:  MOVLW  00
0850:  ADDWFC xB0,F
0852:  MOVFF  2AF,FE9
0856:  MOVLW  04
0858:  ADDWF  xB0,W
085A:  MOVWF  FEA
085C:  MOVLW  88
085E:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
0860:  BRA    0874
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0862:  MOVF   xAD,W
0864:  MULLW  08
0866:  MOVF   FF3,W
0868:  CLRF   xB0
086A:  MOVWF  FE9
086C:  MOVLW  04
086E:  ADDWF  xB0,W
0870:  MOVWF  FEA
0872:  CLRF   FEF
....................    } 
.................... } 
0874:  MOVLB  0
0876:  GOTO   0942 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08C4:  MOVLB  2
08C6:  BCF    xAE.0
08C8:  BTFSC  xAD.7
08CA:  BSF    xAE.0
....................    endpoint &= 0x7F; 
08CC:  BCF    xAD.7
....................     
....................    if (direction)  
08CE:  BTFSS  xAE.0
08D0:  BRA    08F4
....................    { 
....................       st=EP_BDxST_I(endpoint); 
08D2:  MOVF   xAD,W
08D4:  MULLW  08
08D6:  MOVF   FF3,W
08D8:  CLRF   xB1
08DA:  MOVWF  xB0
08DC:  MOVLW  04
08DE:  ADDWF  xB0,F
08E0:  MOVLW  00
08E2:  ADDWFC xB1,F
08E4:  MOVFF  2B0,FE9
08E8:  MOVLW  04
08EA:  ADDWF  xB1,W
08EC:  MOVWF  FEA
08EE:  MOVFF  FEF,2AF
....................    } 
....................    else  
08F2:  BRA    0908
....................    { 
....................       st=EP_BDxST_O(endpoint); 
08F4:  MOVF   xAD,W
08F6:  MULLW  08
08F8:  MOVF   FF3,W
08FA:  CLRF   xB1
08FC:  MOVWF  FE9
08FE:  MOVLW  04
0900:  ADDWF  xB1,W
0902:  MOVWF  FEA
0904:  MOVFF  FEF,2AF
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0908:  BTFSS  xAF.7
090A:  BRA    0910
090C:  BTFSC  xAF.2
090E:  BRA    0914
0910:  MOVLW  00
0912:  BRA    0916
0914:  MOVLW  01
0916:  MOVWF  01
.................... } 
0918:  MOVLB  0
091A:  GOTO   096A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
0D3E:  MOVFF  2AE,F6E
....................     
....................    if (address)  
0D42:  MOVLB  2
0D44:  MOVF   xAE,F
0D46:  BZ    0D4E
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0D48:  MOVLW  04
0D4A:  MOVWF  2B
....................    } 
....................    else  
0D4C:  BRA    0D52
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0D4E:  MOVLW  02
0D50:  MOVWF  2B
....................    } 
.................... } 
0D52:  MOVLB  0
0D54:  GOTO   0D62 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
053C:  MOVLB  2
053E:  MOVF   xAD,F
0540:  BNZ   054E
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0542:  MOVLW  04
0544:  MOVWF  2B
....................       usb_disable_endpoints(); 
0546:  MOVLB  0
0548:  RCALL  037A
....................    } 
....................    else  
054A:  BRA    06D6
054C:  MOVLB  2
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
054E:  MOVLW  05
0550:  MOVWF  2B
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
0552:  MOVLW  04
0554:  MOVWF  xB0
0556:  MOVLW  28
0558:  MOVWF  xAF
....................       for (en=1; en<USB_NUM_UEP; en++)  
055A:  MOVLW  01
055C:  MOVWF  xAE
055E:  MOVF   xAE,W
0560:  SUBLW  0F
0562:  BTFSS  FD8.0
0564:  BRA    06D6
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
0566:  MOVFF  2AE,2B6
056A:  MOVLB  0
056C:  RCALL  0326
....................          new_uep = 0; 
056E:  MOVLB  2
0570:  CLRF   xB1
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0572:  CLRF   03
0574:  MOVF   xAE,W
0576:  MOVLB  0
0578:  RCALL  00F2
057A:  SUBLW  FF
057C:  BZ    0624
....................          { 
....................             new_uep = 0x04; 
057E:  MOVLW  04
0580:  MOVLB  2
0582:  MOVWF  xB1
....................             len = usb_ep_rx_size[en]; 
0584:  BCF    FD8.0
0586:  RLCF   xAE,W
0588:  CLRF   03
058A:  MOVLB  0
058C:  RCALL  0142
058E:  TBLRD*+
0590:  MOVFF  FF5,03
0594:  MOVLB  2
0596:  MOVWF  xB2
0598:  MOVFF  03,2B3
....................             EP_BDxCNT_O(en) = len; 
059C:  MOVF   xAE,W
059E:  MULLW  08
05A0:  MOVF   FF3,W
05A2:  CLRF   xB6
05A4:  MOVWF  xB5
05A6:  MOVLW  01
05A8:  ADDWF  xB5,W
05AA:  MOVWF  01
05AC:  MOVLW  00
05AE:  ADDWFC xB6,W
05B0:  MOVWF  03
05B2:  MOVFF  01,FE9
05B6:  MOVLW  04
05B8:  ADDWF  03,W
05BA:  MOVWF  FEA
05BC:  MOVFF  2B2,FEF
....................             EP_BDxADR_O(en) = addy; 
05C0:  MOVF   xAE,W
05C2:  MULLW  08
05C4:  MOVF   FF3,W
05C6:  CLRF   xB6
05C8:  MOVWF  xB5
05CA:  MOVLW  02
05CC:  ADDWF  xB5,W
05CE:  MOVWF  01
05D0:  MOVLW  00
05D2:  ADDWFC xB6,W
05D4:  MOVWF  03
05D6:  MOVFF  01,FE9
05DA:  MOVLW  04
05DC:  ADDWF  03,W
05DE:  MOVWF  FEA
05E0:  MOVFF  2B0,FEC
05E4:  MOVF   FED,F
05E6:  MOVFF  2AF,FEF
....................             addy += usb_ep_rx_size[en]; 
05EA:  BCF    FD8.0
05EC:  RLCF   xAE,W
05EE:  CLRF   03
05F0:  MOVLB  0
05F2:  RCALL  0142
05F4:  TBLRD*+
05F6:  MOVFF  FF5,03
05FA:  MOVLB  2
05FC:  ADDWF  xAF,F
05FE:  MOVF   03,W
0600:  ADDWFC xB0,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0602:  MOVLW  88
0604:  MOVWF  xB4
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0606:  BTFSC  xB3.0
0608:  BSF    xB4.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
060A:  BTFSC  xB3.1
060C:  BSF    xB4.1
....................             EP_BDxST_O(en) = i; 
060E:  MOVF   xAE,W
0610:  MULLW  08
0612:  MOVF   FF3,W
0614:  CLRF   xB6
0616:  MOVWF  FE9
0618:  MOVLW  04
061A:  ADDWF  xB6,W
061C:  MOVWF  FEA
061E:  MOVFF  2B4,FEF
0622:  MOVLB  0
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0624:  CLRF   03
0626:  MOVLB  2
0628:  MOVF   xAE,W
062A:  MOVLB  0
062C:  RCALL  00D2
062E:  SUBLW  FF
0630:  BZ    06A0
....................          { 
....................             new_uep |= 0x02; 
0632:  MOVLB  2
0634:  BSF    xB1.1
....................             EP_BDxADR_I(en) = addy; 
0636:  MOVF   xAE,W
0638:  MULLW  08
063A:  MOVF   FF3,W
063C:  CLRF   xB6
063E:  MOVWF  xB5
0640:  MOVLW  04
0642:  ADDWF  xB5,F
0644:  MOVLW  00
0646:  ADDWFC xB6,F
0648:  MOVLW  02
064A:  ADDWF  xB5,W
064C:  MOVWF  01
064E:  MOVLW  00
0650:  ADDWFC xB6,W
0652:  MOVWF  03
0654:  MOVFF  01,FE9
0658:  MOVLW  04
065A:  ADDWF  03,W
065C:  MOVWF  FEA
065E:  MOVFF  2B0,FEC
0662:  MOVF   FED,F
0664:  MOVFF  2AF,FEF
....................             addy += usb_ep_tx_size[en]; 
0668:  BCF    FD8.0
066A:  RLCF   xAE,W
066C:  CLRF   03
066E:  MOVLB  0
0670:  RCALL  0112
0672:  TBLRD*+
0674:  MOVFF  FF5,03
0678:  MOVLB  2
067A:  ADDWF  xAF,F
067C:  MOVF   03,W
067E:  ADDWFC xB0,F
....................             EP_BDxST_I(en) = 0x40; 
0680:  MOVF   xAE,W
0682:  MULLW  08
0684:  MOVF   FF3,W
0686:  CLRF   xB6
0688:  MOVWF  xB5
068A:  MOVLW  04
068C:  ADDWF  xB5,F
068E:  MOVLW  00
0690:  ADDWFC xB6,F
0692:  MOVFF  2B5,FE9
0696:  MOVLW  04
0698:  ADDWF  xB6,W
069A:  MOVWF  FEA
069C:  MOVLW  40
069E:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
06A0:  MOVLB  2
06A2:  MOVF   xB1,W
06A4:  SUBLW  06
06A6:  BNZ   06AC
06A8:  MOVLW  0E
06AA:  MOVWF  xB1
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
06AC:  CLRF   03
06AE:  MOVF   xAE,W
06B0:  MOVLB  0
06B2:  RCALL  00D2
06B4:  SUBLW  01
06B6:  BZ    06BE
06B8:  MOVLB  2
06BA:  BSF    xB1.4
06BC:  MOVLB  0
....................           
....................          UEP(en) = new_uep; 
06BE:  CLRF   03
06C0:  MOVLB  2
06C2:  MOVF   xAE,W
06C4:  ADDLW  70
06C6:  MOVWF  FE9
06C8:  MOVLW  0F
06CA:  ADDWFC 03,W
06CC:  MOVWF  FEA
06CE:  MOVFF  2B1,FEF
....................       } 
06D2:  INCF   xAE,F
06D4:  BRA    055E
06D6:  MOVLB  0
....................    } 
.................... } 
06D8:  GOTO   0780 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0326:  CLRF   03
0328:  MOVLB  2
032A:  MOVF   xB6,W
032C:  ADDLW  70
032E:  MOVWF  FE9
0330:  MOVLW  0F
0332:  ADDWFC 03,W
0334:  MOVWF  FEA
0336:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0338:  MOVFF  2B6,2B7
033C:  MOVLB  0
033E:  RCALL  02D6
0340:  MOVF   01,F
0342:  BZ    0376
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
0344:  MOVLB  2
0346:  MOVF   xB6,W
0348:  MULLW  08
034A:  MOVF   FF3,W
034C:  CLRF   xB8
034E:  MOVWF  FE9
0350:  MOVLW  04
0352:  ADDWF  xB8,W
0354:  MOVWF  FEA
0356:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
0358:  MOVF   xB6,W
035A:  MULLW  08
035C:  MOVF   FF3,W
035E:  CLRF   xB8
0360:  MOVWF  xB7
0362:  MOVLW  04
0364:  ADDWF  xB7,F
0366:  MOVLW  00
0368:  ADDWFC xB8,F
036A:  MOVFF  2B7,FE9
036E:  MOVLW  04
0370:  ADDWF  xB8,W
0372:  MOVWF  FEA
0374:  CLRF   FEF
0376:  MOVLB  0
....................    } 
.................... } 
0378:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
037A:  MOVLW  01
037C:  MOVLB  2
037E:  MOVWF  xB5
0380:  MOVF   xB5,W
0382:  SUBLW  0F
0384:  BNC   0394
....................       usb_disable_endpoint(i); 
0386:  MOVFF  2B5,2B6
038A:  MOVLB  0
038C:  RCALL  0326
038E:  MOVLB  2
0390:  INCF   xB5,F
0392:  BRA    0380
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
0394:  MOVLB  0
0396:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0FD0:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0FD2:  MOVF   2B,F
0FD4:  BNZ   0FD8
0FD6:  BRA    1054
....................    if (UIR)  
0FD8:  MOVF   F68,F
0FDA:  BZ    1054
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0FDC:  BTFSS  F68.2
0FDE:  BRA    0FE8
0FE0:  BTFSS  F69.2
0FE2:  BRA    0FE8
0FE4:  GOTO   0290
....................  
....................       if (UCON_SUSPND) return; 
0FE8:  BTFSS  F6D.1
0FEA:  BRA    0FEE
0FEC:  BRA    1054
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0FEE:  BTFSS  F68.5
0FF0:  BRA    0FFA
0FF2:  BTFSS  F69.5
0FF4:  BRA    0FFA
0FF6:  GOTO   02C0
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0FFA:  BTFSS  F68.1
0FFC:  BRA    1006
0FFE:  BTFSS  F69.1
1000:  BRA    1006
1002:  GOTO   02CE
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
1006:  BTFSS  F68.0
1008:  BRA    1012
100A:  BTFSS  F69.0
100C:  BRA    1012
100E:  GOTO   03E6
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
1012:  BTFSS  F68.4
1014:  BRA    101E
1016:  BTFSS  F69.4
1018:  BRA    101E
101A:  GOTO   0410
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
101E:  BTFSS  F68.6
1020:  BRA    102A
1022:  BTFSS  F69.6
1024:  BRA    102A
1026:  GOTO   041A
....................  
....................       TRNAttempts = 0; 
102A:  MOVLB  2
102C:  CLRF   xAA
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
102E:  BTFSS  F68.3
1030:  BRA    1046
1032:  BTFSS  F69.3
1034:  BRA    1046
....................          { 
....................             USTATCopy = U1STAT; 
1036:  MOVFF  F6C,2A
....................             usb_clear_trn(); 
103A:  MOVLB  0
103C:  CALL   0004
....................             usb_isr_tok_dne(); 
1040:  BRA    0E56
....................          } 
....................          else 
1042:  BRA    1048
1044:  MOVLB  2
....................             break; 
1046:  BRA    1052
....................       } while (TRNAttempts++ < 4); 
1048:  MOVLB  2
104A:  MOVF   xAA,W
104C:  INCF   xAA,F
104E:  SUBLW  03
1050:  BC    102E
1052:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
1054:  GOTO   0084
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
041A:  BCF    F68.6
.................... } 
041C:  GOTO   102A (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
03E6:  CLRF   F6A
....................    UIR = 0; 
03E8:  CLRF   F68
....................    UEIE = 0x9F; 
03EA:  MOVLW  9F
03EC:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
03EE:  MOVLW  3D
03F0:  MOVWF  F69
....................  
....................    UADDR = 0; 
03F2:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
03F4:  RCALL  037A
....................     
....................    usb_token_reset(); 
03F6:  RCALL  03BA
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
03F8:  MOVLW  16
03FA:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
03FC:  BTFSS  F68.3
03FE:  BRA    0404
....................       usb_clear_trn(); 
0400:  RCALL  0004
....................    } 
0402:  BRA    03FC
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0404:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
0406:  RCALL  02A0
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0408:  MOVLW  03
040A:  MOVWF  2B
.................... } 
040C:  GOTO   1012 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
02A0:  MOVLW  08
02A2:  MOVLB  4
02A4:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
02A6:  MOVLW  04
02A8:  MOVWF  x03
02AA:  MOVLW  18
02AC:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
02AE:  MOVLW  88
02B0:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
02B2:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
02B4:  MOVLW  04
02B6:  MOVWF  x07
02B8:  MOVLW  20
02BA:  MOVWF  x06
.................... } 
02BC:  MOVLB  0
02BE:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
02CE:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
02D0:  BCF    F68.1
.................... } 
02D2:  GOTO   1006 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0410:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0412:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0414:  BSF    F6D.1
.................... } 
0416:  GOTO   101E (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
0290:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
0292:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
0294:  BTFSS  F68.2
0296:  BRA    029C
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0298:  BCF    F68.2
....................    } 
029A:  BRA    0294
.................... } 
029C:  GOTO   0FE8 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
02C0:  BTFSS  F70.0
02C2:  BRA    02C8
....................    { 
....................       usb_init_ep0_setup(); 
02C4:  RCALL  02A0
....................       bit_clear(UEP(0), 0); 
02C6:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
02C8:  BCF    F68.5
.................... } 
02CA:  GOTO   0FFA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0420:  MOVFF  2B0,2C
0424:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
0988:  MOVLW  FE
098A:  MOVWF  2C
098C:  RETLW  00
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
0426:  MOVLW  FF
0428:  MOVWF  2C
042A:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0E56:  RRCF   2A,W
0E58:  MOVLB  2
0E5A:  MOVWF  xAB
0E5C:  RRCF   xAB,F
0E5E:  RRCF   xAB,F
0E60:  MOVLW  1F
0E62:  ANDWF  xAB,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0E64:  MOVF   2A,F
0E66:  BNZ   0F06
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0E68:  MOVLB  4
0E6A:  MOVF   x00,W
0E6C:  ANDLW  3C
0E6E:  MOVLB  2
0E70:  MOVWF  xAC
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0E72:  MOVLW  43
0E74:  MOVLB  4
0E76:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0E78:  MOVLB  2
0E7A:  MOVF   xAC,W
0E7C:  SUBLW  34
0E7E:  BNZ   0ECA
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0E80:  MOVLB  4
0E82:  MOVF   x04,W
0E84:  ANDLW  80
0E86:  BZ    0E8A
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0E88:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0E8A:  MOVLB  0
0E8C:  BRA    0A3E
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0E8E:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0E90:  INCFSZ 2C,W
0E92:  BRA    0EA2
....................             usb_flush_out(0, USB_DTS_STALL); 
0E94:  MOVLB  2
0E96:  CLRF   xAE
0E98:  MOVLW  03
0E9A:  MOVWF  xAF
0E9C:  MOVLB  0
0E9E:  RCALL  0A72
....................          else  
0EA0:  BRA    0EC6
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0EA2:  MOVLB  2
0EA4:  CLRF   xAE
0EA6:  MOVLW  02
0EA8:  MOVWF  xAF
0EAA:  MOVLB  0
0EAC:  RCALL  0A72
....................             if (__setup_0_tx_size != 0xFE) 
0EAE:  MOVF   2C,W
0EB0:  SUBLW  FE
0EB2:  BZ    0EC6
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0EB4:  MOVLB  2
0EB6:  CLRF   xB6
0EB8:  CLRF   xB8
0EBA:  MOVFF  2C,2B7
0EBE:  MOVLW  04
0EC0:  MOVWF  xB9
0EC2:  MOVLB  0
0EC4:  RCALL  0B76
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
0EC6:  BRA    0F02
0EC8:  MOVLB  2
0ECA:  MOVF   xAC,W
0ECC:  SUBLW  04
0ECE:  BNZ   0F04
....................       { 
....................          usb_isr_tok_out_dne(0); 
0ED0:  CLRF   xAD
0ED2:  MOVLB  0
0ED4:  RCALL  0D20
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0ED6:  MOVLB  2
0ED8:  CLRF   xAE
0EDA:  MOVLW  02
0EDC:  MOVWF  xAF
0EDE:  MOVLB  0
0EE0:  RCALL  0A72
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0EE2:  MOVF   2C,W
0EE4:  SUBLW  FE
0EE6:  BZ    0F00
0EE8:  INCFSZ 2C,W
0EEA:  BRA    0EEE
0EEC:  BRA    0F00
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0EEE:  MOVLB  2
0EF0:  CLRF   xB6
0EF2:  CLRF   xB8
0EF4:  MOVFF  2C,2B7
0EF8:  MOVLW  01
0EFA:  MOVWF  xB9
0EFC:  MOVLB  0
0EFE:  RCALL  0B76
....................          } 
....................       } 
....................       else 
0F00:  BRA    0F02
0F02:  MOVLB  2
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
0F04:  BRA    0FCA
0F06:  MOVF   2A,W
0F08:  SUBLW  04
0F0A:  BNZ   0F3C
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
0F0C:  MOVLW  43
0F0E:  MOVLB  4
0F10:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
0F12:  MOVLW  FF
0F14:  MOVWF  2C
....................       usb_isr_tok_in_dne(0); 
0F16:  MOVLB  2
0F18:  CLRF   xAD
0F1A:  MOVLB  0
0F1C:  RCALL  0E24
....................       if (__setup_0_tx_size!=0xFF) 
0F1E:  INCFSZ 2C,W
0F20:  BRA    0F24
0F22:  BRA    0F38
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0F24:  MOVLB  2
0F26:  CLRF   xB6
0F28:  CLRF   xB8
0F2A:  MOVFF  2C,2B7
0F2E:  MOVLW  02
0F30:  MOVWF  xB9
0F32:  MOVLB  0
0F34:  RCALL  0B76
....................       else 
0F36:  BRA    0F38
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
0F38:  BRA    0FC8
0F3A:  MOVLB  2
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0F3C:  BTFSC  2A.2
0F3E:  BRA    0F7A
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
0F40:  MOVF   xAB,W
0F42:  MULLW  08
0F44:  MOVF   FF3,W
0F46:  CLRF   xAE
0F48:  MOVWF  01
0F4A:  MOVLW  04
0F4C:  ADDWF  xAE,W
0F4E:  MOVWF  03
0F50:  MOVF   xAB,W
0F52:  MULLW  08
0F54:  MOVF   FF3,W
0F56:  CLRF   xB0
0F58:  MOVWF  FE9
0F5A:  MOVLW  04
0F5C:  ADDWF  xB0,W
0F5E:  MOVWF  FEA
0F60:  MOVF   FEF,W
0F62:  ANDLW  43
0F64:  MOVFF  03,FEA
0F68:  MOVFF  01,FE9
0F6C:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
0F6E:  MOVFF  2AB,2AD
0F72:  MOVLB  0
0F74:  RCALL  0D20
....................       } 
....................       else  
0F76:  BRA    0FC8
0F78:  MOVLB  2
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
0F7A:  MOVF   xAB,W
0F7C:  MULLW  08
0F7E:  MOVF   FF3,W
0F80:  CLRF   xAE
0F82:  MOVWF  xAD
0F84:  MOVLW  04
0F86:  ADDWF  xAD,F
0F88:  MOVLW  00
0F8A:  ADDWFC xAE,F
0F8C:  MOVFF  2AD,01
0F90:  MOVLW  04
0F92:  ADDWF  xAE,W
0F94:  MOVWF  03
0F96:  MOVF   xAB,W
0F98:  MULLW  08
0F9A:  MOVF   FF3,W
0F9C:  CLRF   xB0
0F9E:  MOVWF  xAF
0FA0:  MOVLW  04
0FA2:  ADDWF  xAF,F
0FA4:  MOVLW  00
0FA6:  ADDWFC xB0,F
0FA8:  MOVFF  2AF,FE9
0FAC:  MOVLW  04
0FAE:  ADDWF  xB0,W
0FB0:  MOVWF  FEA
0FB2:  MOVF   FEF,W
0FB4:  ANDLW  43
0FB6:  MOVFF  03,FEA
0FBA:  MOVFF  2AD,FE9
0FBE:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
0FC0:  MOVFF  2AB,2AD
0FC4:  MOVLB  0
0FC6:  RCALL  0E24
0FC8:  MOVLB  2
....................       } 
....................    } 
.................... } 
0FCA:  MOVLB  0
0FCC:  GOTO   1042 (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1B54:  MOVF   24,W
1B56:  MOVWF  01
.................... } 
1B58:  GOTO   1B66 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
03BA:  MOVLB  2
03BC:  CLRF   xAB
03BE:  MOVF   xAB,W
03C0:  SUBLW  01
03C2:  BNC   03D8
....................       USB_Interface[i] = 0;   //reset each interface to default 
03C4:  CLRF   03
03C6:  MOVF   xAB,W
03C8:  ADDLW  30
03CA:  MOVWF  FE9
03CC:  MOVLW  00
03CE:  ADDWFC 03,W
03D0:  MOVWF  FEA
03D2:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
03D4:  INCF   xAB,F
03D6:  BRA    03BE
....................    usb_cdc_init(); 
03D8:  MOVLB  0
03DA:  RCALL  0398
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
03DC:  CLRF   24
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
03DE:  MOVLW  01
03E0:  MOVWF  25
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
03E2:  CLRF   23
.................... } 
03E4:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
02D6:  MOVLB  2
02D8:  BCF    xB8.0
02DA:  BTFSC  xB7.7
02DC:  BSF    xB8.0
....................     
....................    endpoint &= 0x7F; 
02DE:  BCF    xB7.7
....................     
....................    if (endpoint > 16) 
02E0:  MOVF   xB7,W
02E2:  SUBLW  10
02E4:  BC    02EC
....................       return(FALSE); 
02E6:  MOVLW  00
02E8:  MOVWF  01
02EA:  BRA    0322
....................     
....................    if (direction) { //IN 
02EC:  BTFSS  xB8.0
02EE:  BRA    030A
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
02F0:  CLRF   03
02F2:  MOVF   xB7,W
02F4:  MOVLB  0
02F6:  RCALL  00D2
02F8:  SUBLW  FF
02FA:  BNZ   0300
02FC:  MOVLW  00
02FE:  BRA    0302
0300:  MOVLW  01
0302:  MOVWF  01
0304:  MOVLB  2
0306:  BRA    0322
....................    } 
....................    else {   //OUT 
0308:  BRA    0322
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
030A:  CLRF   03
030C:  MOVF   xB7,W
030E:  MOVLB  0
0310:  RCALL  00F2
0312:  SUBLW  FF
0314:  BNZ   031A
0316:  MOVLW  00
0318:  BRA    031C
031A:  MOVLW  01
031C:  MOVWF  01
031E:  MOVLB  2
0320:  BRA    0322
....................    } 
.................... } 
0322:  MOVLB  0
0324:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
0E24:  MOVLB  2
0E26:  MOVF   xAD,F
0E28:  BNZ   0E46
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0E2A:  DECFSZ 23,W
0E2C:  BRA    0E38
0E2E:  MOVLB  0
0E30:  CALL   042C
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0E34:  BRA    0E42
0E36:  MOVLB  2
0E38:  MOVF   23,W
0E3A:  SUBLW  02
0E3C:  BNZ   0E44
0E3E:  MOVLB  0
0E40:  BRA    0D58
0E42:  MOVLB  2
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0E44:  BRA    0E52
0E46:  MOVF   xAD,W
0E48:  SUBLW  02
0E4A:  BNZ   0E52
....................       usb_isr_tok_in_cdc_data_dne(); 
0E4C:  MOVLB  0
0E4E:  BRA    0E1A
0E50:  MOVLB  2
....................   } 
....................   #endif 
.................... } 
0E52:  MOVLB  0
0E54:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0D20:  MOVLB  2
0D22:  MOVF   xAD,F
0D24:  BNZ   0D2E
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0D26:  MOVLB  0
0D28:  BRA    0C52
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0D2A:  BRA    0D38
0D2C:  MOVLB  2
0D2E:  MOVF   xAD,W
0D30:  SUBLW  02
0D32:  BNZ   0D3A
....................       usb_isr_tok_out_cdc_data_dne(); 
0D34:  MOVLB  0
0D36:  BRA    0D04
0D38:  MOVLB  2
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0D3A:  MOVLB  0
0D3C:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0A3E:  CLRF   23
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0A40:  MOVLB  4
0A42:  MOVF   x18,W
0A44:  ANDLW  7F
0A46:  XORLW  00
0A48:  MOVLB  0
0A4A:  BZ    0A5A
0A4C:  XORLW  01
0A4E:  BZ    0A5E
0A50:  XORLW  03
0A52:  BZ    0A62
0A54:  XORLW  23
0A56:  BZ    0A66
0A58:  BRA    0A6A
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0A5A:  BRA    06DC
....................          break; 
0A5C:  BRA    0A6E
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0A5E:  BRA    0794
....................          break; 
0A60:  BRA    0A6E
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0A62:  BRA    091E
....................          break; 
0A64:  BRA    0A6E
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
0A66:  BRA    098E
....................          break; 
0A68:  BRA    0A6E
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0A6A:  RCALL  0426
....................          break; 
0A6C:  BRA    0A6E
....................    } 
.................... } 
0A6E:  GOTO   0E8E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
06DC:  MOVLB  4
06DE:  MOVF   x19,W
06E0:  XORLW  00
06E2:  MOVLB  0
06E4:  BZ    0700
06E6:  XORLW  01
06E8:  BZ    0714
06EA:  XORLW  02
06EC:  BZ    072E
06EE:  XORLW  06
06F0:  BZ    0746
06F2:  XORLW  03
06F4:  BZ    0758
06F6:  XORLW  0E
06F8:  BZ    075C
06FA:  XORLW  01
06FC:  BZ    076C
06FE:  BRA    078C
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0700:  MOVFF  25,420
....................             usb_ep0_tx_buffer[1]=0; 
0704:  MOVLB  4
0706:  CLRF   x21
....................             usb_request_send_response(2); 
0708:  MOVLW  02
070A:  MOVLB  2
070C:  MOVWF  xB0
070E:  MOVLB  0
0710:  RCALL  0420
....................             break; 
0712:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0714:  MOVLB  4
0716:  DECFSZ x1A,W
0718:  BRA    0728
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
071A:  MOVLW  01
071C:  ANDWF  25,F
....................                usb_put_0len_0(); 
071E:  MOVLB  2
0720:  CLRF   xB0
0722:  MOVLB  0
0724:  RCALL  0420
....................             } 
....................             else 
0726:  BRA    072C
....................                usb_request_stall(); 
0728:  MOVLB  0
072A:  RCALL  0426
....................             break; 
072C:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
072E:  MOVLB  4
0730:  DECFSZ x1A,W
0732:  BRA    0740
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0734:  BSF    25.1
....................                usb_put_0len_0(); 
0736:  MOVLB  2
0738:  CLRF   xB0
073A:  MOVLB  0
073C:  RCALL  0420
....................             } 
....................             else 
073E:  BRA    0744
....................                usb_request_stall(); 
0740:  MOVLB  0
0742:  RCALL  0426
....................             break; 
0744:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
0746:  MOVLW  02
0748:  MOVWF  23
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
074A:  MOVFF  41A,2D
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
074E:  MOVLB  2
0750:  CLRF   xB0
0752:  MOVLB  0
0754:  RCALL  0420
....................             break; 
0756:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0758:  BRA    04A2
....................             break; 
075A:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
075C:  MOVFF  24,420
....................             usb_request_send_response(1); 
0760:  MOVLW  01
0762:  MOVLB  2
0764:  MOVWF  xB0
0766:  MOVLB  0
0768:  RCALL  0420
....................             break; 
076A:  BRA    0790
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
076C:  MOVLB  4
076E:  MOVF   x1A,W
0770:  SUBLW  01
0772:  BNC   0788
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
0774:  MOVFF  41A,24
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0778:  MOVFF  41A,2AD
077C:  MOVLB  0
077E:  BRA    053C
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
0780:  MOVLB  2
0782:  CLRF   xB0
0784:  MOVLB  0
0786:  RCALL  0420
....................             } 
....................             break; 
0788:  MOVLB  0
078A:  BRA    0790
....................  
....................       default: 
....................             usb_request_stall(); 
078C:  RCALL  0426
....................             break; 
078E:  BRA    0790
....................    } 
.................... } 
0790:  GOTO   0A6E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
0794:  MOVFF  24,2AD
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
0798:  MOVLB  4
079A:  MOVF   x19,W
079C:  XORLW  00
079E:  MOVLB  0
07A0:  BZ    07AC
07A2:  XORLW  0A
07A4:  BZ    07BE
07A6:  XORLW  01
07A8:  BZ    0800
07AA:  BRA    082A
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
07AC:  MOVLB  4
07AE:  CLRF   x20
....................             usb_ep0_tx_buffer[1]=0; 
07B0:  CLRF   x21
....................             usb_request_send_response(2); 
07B2:  MOVLW  02
07B4:  MOVLB  2
07B6:  MOVWF  xB0
07B8:  MOVLB  0
07BA:  RCALL  0420
....................             break; 
07BC:  BRA    082E
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
07BE:  MOVLB  2
07C0:  MOVF   xAD,F
07C2:  BZ    07FA
07C4:  MOVLW  01
07C6:  SUBWF  xAD,W
07C8:  CLRF   03
07CA:  MOVLB  0
07CC:  RCALL  01C6
07CE:  MOVWF  01
07D0:  MOVLB  4
07D2:  SUBWF  x1C,W
07D4:  BTFSS  FD8.0
07D6:  BRA    07DC
07D8:  MOVLB  2
07DA:  BRA    07FA
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
07DC:  CLRF   03
07DE:  MOVF   x1C,W
07E0:  ADDLW  30
07E2:  MOVWF  FE9
07E4:  MOVLW  00
07E6:  ADDWFC 03,W
07E8:  MOVWF  FEA
07EA:  MOVFF  FEF,420
....................                usb_request_send_response(1);; //send byte back 
07EE:  MOVLW  01
07F0:  MOVLB  2
07F2:  MOVWF  xB0
07F4:  MOVLB  0
07F6:  RCALL  0420
....................             } 
....................             else 
07F8:  BRA    07FE
....................                usb_request_stall(); 
07FA:  MOVLB  0
07FC:  RCALL  0426
....................             break; 
07FE:  BRA    082E
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0800:  MOVLB  2
0802:  MOVF   xAD,F
0804:  BZ    0824
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0806:  CLRF   03
0808:  MOVLB  4
080A:  MOVF   x1C,W
080C:  ADDLW  30
080E:  MOVWF  FE9
0810:  MOVLW  00
0812:  ADDWFC 03,W
0814:  MOVWF  FEA
0816:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
081A:  MOVLB  2
081C:  CLRF   xB0
081E:  MOVLB  0
0820:  RCALL  0420
....................             } 
....................             else 
0822:  BRA    0828
....................                usb_request_stall(); 
0824:  MOVLB  0
0826:  RCALL  0426
....................             break; 
0828:  BRA    082E
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
082A:  RCALL  0426
....................             break; 
082C:  BRA    082E
....................    } 
.................... } 
082E:  GOTO   0A6E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
091E:  MOVFF  41C,2B7
0922:  RCALL  02D6
0924:  MOVF   01,F
0926:  BZ    0984
....................       switch(usb_ep0_rx_buffer[1]) { 
0928:  MOVLB  4
092A:  MOVF   x19,W
092C:  XORLW  01
092E:  MOVLB  0
0930:  BZ    093C
0932:  XORLW  02
0934:  BZ    094C
0936:  XORLW  03
0938:  BZ    095C
093A:  BRA    0980
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
093C:  MOVFF  41C,2AD
0940:  BRA    0832
....................                usb_put_0len_0(); 
0942:  MOVLB  2
0944:  CLRF   xB0
0946:  MOVLB  0
0948:  RCALL  0420
....................                break; 
094A:  BRA    0984
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
094C:  MOVFF  41C,2AD
0950:  BRA    087A
....................                      usb_put_0len_0(); 
0952:  MOVLB  2
0954:  CLRF   xB0
0956:  MOVLB  0
0958:  RCALL  0420
....................                      break; 
095A:  BRA    0984
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
095C:  MOVLB  4
095E:  CLRF   x20
....................                usb_ep0_tx_buffer[1]=0; 
0960:  CLRF   x21
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0962:  MOVFF  41C,2AD
0966:  MOVLB  0
0968:  BRA    08C4
096A:  MOVF   01,F
096C:  BZ    0974
....................                   usb_ep0_tx_buffer[0]=1; 
096E:  MOVLW  01
0970:  MOVLB  4
0972:  MOVWF  x20
....................                } 
....................                usb_request_send_response(2); 
0974:  MOVLW  02
0976:  MOVLB  2
0978:  MOVWF  xB0
097A:  MOVLB  0
097C:  RCALL  0420
....................                break; 
097E:  BRA    0984
....................  
....................          default: 
....................             usb_request_stall(); 
0980:  RCALL  0426
....................             break; 
0982:  BRA    0984
....................       } 
....................    } 
.................... } 
0984:  GOTO   0A6E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
04A2:  CLRF   2E
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
04A4:  CLRF   26
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
04A6:  MOVLB  4
04A8:  MOVF   x1B,W
04AA:  XORLW  01
04AC:  MOVLB  0
04AE:  BZ    04BE
04B0:  XORLW  03
04B2:  BZ    04C8
04B4:  XORLW  01
04B6:  BZ    04CE
04B8:  XORLW  22
04BA:  BZ    04F2
04BC:  BRA    051C
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
04BE:  MOVLW  12
04C0:  MOVWF  2F
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
04C2:  MOVLW  03
04C4:  MOVWF  26
....................             break; 
04C6:  BRA    0520
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
04C8:  MOVLW  43
04CA:  MOVWF  2F
....................             break; 
04CC:  BRA    0520
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
04CE:  MOVLW  02
04D0:  MOVWF  26
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
04D2:  CLRF   03
04D4:  MOVLB  4
04D6:  MOVF   x1A,W
04D8:  ADDLW  27
04DA:  MOVWF  FE9
04DC:  MOVLW  00
04DE:  ADDWFC 03,W
04E0:  MOVWF  FEA
04E2:  MOVFF  FEF,2E
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
04E6:  CLRF   03
04E8:  MOVF   2E,W
04EA:  MOVLB  0
04EC:  RCALL  021A
04EE:  MOVWF  2F
....................             break; 
04F0:  BRA    0520
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
04F2:  BCF    FD8.0
04F4:  MOVLB  4
04F6:  RLCF   x1A,W
04F8:  CLRF   03
04FA:  MOVLB  0
04FC:  RCALL  01D8
04FE:  TBLRD*+
0500:  MOVFF  FF5,03
0504:  MOVWF  2E
....................             if (usb_getdesc_ptr!=0xFF) { 
0506:  INCFSZ 2E,W
0508:  BRA    050C
050A:  BRA    0518
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
050C:  CLRF   03
050E:  MOVF   2E,W
0510:  RCALL  0172
0512:  MOVWF  2F
....................                break; 
0514:  BRA    0520
....................             } 
....................             else { 
0516:  BRA    051C
....................                usb_request_stall(); 
0518:  RCALL  0426
....................                return; 
051A:  BRA    0538
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
051C:  RCALL  0426
....................             return; 
051E:  BRA    0538
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0520:  MOVLB  4
0522:  MOVF   x1F,F
0524:  BNZ   0530
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
0526:  MOVF   2F,W
0528:  SUBWF  x1E,W
052A:  BC    0530
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
052C:  MOVFF  41E,2F
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0530:  MOVLW  01
0532:  MOVWF  23
....................    usb_copy_desc_seg_to_ep(); 
0534:  MOVLB  0
0536:  RCALL  042C
.................... } 
0538:  GOTO   0790 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0D58:  CLRF   24
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0D5A:  CLRF   23
....................    usb_set_address(USB_address_pending); 
0D5C:  MOVFF  2D,2AE
0D60:  BRA    0D3E
....................    #endif 
.................... } 
0D62:  GOTO   0E42 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
042C:  MOVLB  2
042E:  CLRF   xAE
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0430:  MOVF   2F,F
0432:  BZ    048C
0434:  MOVF   xAE,W
0436:  SUBLW  07
0438:  BNC   048C
....................       switch(USB_stack_status.getdesc_type) { 
043A:  MOVF   26,W
043C:  XORLW  00
043E:  MOVLB  0
0440:  BZ    044C
0442:  XORLW  02
0444:  BZ    0458
0446:  XORLW  01
0448:  BZ    0464
044A:  BRA    0470
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
044C:  CLRF   03
044E:  MOVF   2E,W
0450:  RCALL  0172
0452:  MOVFF  FE8,2AF
....................             break; 
0456:  BRA    0470
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
0458:  CLRF   03
045A:  MOVF   2E,W
045C:  RCALL  021A
045E:  MOVFF  FE8,2AF
....................             break; 
0462:  BRA    0470
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
0464:  CLRF   03
0466:  MOVF   2E,W
0468:  RCALL  01F8
046A:  MOVFF  FE8,2AF
....................             break; 
046E:  BRA    0470
....................       } 
....................       usb_getdesc_ptr++; 
0470:  INCF   2E,F
....................       usb_getdesc_len--; 
0472:  DECF   2F,F
....................       usb_ep0_tx_buffer[i++]=c; 
0474:  MOVLB  2
0476:  MOVF   xAE,W
0478:  INCF   xAE,F
047A:  CLRF   03
047C:  ADDLW  20
047E:  MOVWF  FE9
0480:  MOVLW  04
0482:  ADDWFC 03,W
0484:  MOVWF  FEA
0486:  MOVFF  2AF,FEF
....................    } 
048A:  BRA    0430
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
048C:  MOVF   2F,F
048E:  BNZ   0498
0490:  MOVF   xAE,W
0492:  SUBLW  08
0494:  BZ    0498
....................          USB_stack_status.dev_req = NONE; 
0496:  CLRF   23
....................    } 
....................  
....................    usb_request_send_response(i); 
0498:  MOVFF  2AE,2B0
049C:  MOVLB  0
049E:  RCALL  0420
.................... } 
04A0:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  unsigned int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... unsigned int8 g_LastCDCDataPacketSize; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
0C52:  MOVF   x89,W
0C54:  XORLW  01
0C56:  BZ    0C62
0C58:  XORLW  02
0C5A:  BZ    0C84
0C5C:  XORLW  01
0C5E:  BZ    0C92
0C60:  BRA    0CBA
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
0C62:  CLRF   FEA
0C64:  MOVLW  3B
0C66:  MOVWF  FE9
0C68:  MOVLW  04
0C6A:  MOVWF  FE2
0C6C:  MOVLW  18
0C6E:  MOVWF  FE1
0C70:  MOVLW  08
0C72:  MOVWF  01
0C74:  MOVFF  FE6,FEE
0C78:  DECFSZ 01,F
0C7A:  BRA    0C74
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
0C7C:  MOVLW  03
0C7E:  MOVWF  x89
....................          usb_request_get_data(); 
0C80:  RCALL  0988
....................         #else 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................         #endif 
....................          break; 
0C82:  BRA    0CBE
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
0C84:  MOVLB  2
0C86:  CLRF   xB0
0C88:  MOVLB  0
0C8A:  CALL   0420
....................          __usb_cdc_state=0; 
0C8E:  CLRF   x89
....................          break; 
0C90:  BRA    0CBE
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0C92:  CLRF   FEA
0C94:  MOVLW  32
0C96:  MOVWF  FE9
0C98:  MOVLW  04
0C9A:  MOVWF  FE2
0C9C:  MOVLW  18
0C9E:  MOVWF  FE1
0CA0:  MOVLW  07
0CA2:  MOVWF  01
0CA4:  MOVFF  FE6,FEE
0CA8:  DECFSZ 01,F
0CAA:  BRA    0CA4
....................          __usb_cdc_state=0; 
0CAC:  CLRF   x89
....................          usb_put_0len_0(); 
0CAE:  MOVLB  2
0CB0:  CLRF   xB0
0CB2:  MOVLB  0
0CB4:  CALL   0420
....................          break; 
0CB8:  BRA    0CBE
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0CBA:  CLRF   x89
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
0CBC:  BRA    0CBE
....................    } 
.................... } 
0CBE:  GOTO   0D2A (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
098E:  MOVLB  4
0990:  DECFSZ x1C,W
0992:  BRA    0996
0994:  BRA    099A
0996:  MOVF   x1C,F
0998:  BNZ   0A38
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
099A:  MOVF   x19,W
099C:  XORLW  00
099E:  MOVLB  0
09A0:  BZ    09B8
09A2:  XORLW  01
09A4:  BZ    09C0
09A6:  XORLW  21
09A8:  BZ    09E2
09AA:  XORLW  01
09AC:  BZ    09EC
09AE:  XORLW  03
09B0:  BZ    0A12
09B2:  XORLW  01
09B4:  BZ    0A20
09B6:  BRA    0A32
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
09B8:  MOVLW  01
09BA:  MOVWF  x89
....................             usb_request_get_data(); 
09BC:  RCALL  0988
....................             break; 
09BE:  BRA    0A36
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
09C0:  MOVLW  04
09C2:  MOVWF  FEA
09C4:  MOVLW  20
09C6:  MOVWF  FE9
09C8:  CLRF   FE2
09CA:  MOVLW  3B
09CC:  MOVWF  FE1
09CE:  MOVLW  08
09D0:  MOVWF  01
09D2:  MOVFF  FE6,FEE
09D6:  DECFSZ 01,F
09D8:  BRA    09D2
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
09DA:  MOVFF  41E,2B0
09DE:  RCALL  0420
....................             break; 
09E0:  BRA    0A36
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
09E2:  MOVLW  02
09E4:  MOVWF  x89
....................             usb_cdc_got_set_line_coding=TRUE; 
09E6:  BSF    x86.0
....................             usb_request_get_data(); 
09E8:  RCALL  0988
....................             break; 
09EA:  BRA    0A36
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
09EC:  MOVLW  04
09EE:  MOVWF  FEA
09F0:  MOVLW  20
09F2:  MOVWF  FE9
09F4:  CLRF   FE2
09F6:  MOVLW  32
09F8:  MOVWF  FE1
09FA:  MOVLW  07
09FC:  MOVWF  01
09FE:  MOVFF  FE6,FEE
0A02:  DECFSZ 01,F
0A04:  BRA    09FE
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0A06:  MOVLW  07
0A08:  MOVLB  2
0A0A:  MOVWF  xB0
0A0C:  MOVLB  0
0A0E:  RCALL  0420
....................             break; 
0A10:  BRA    0A36
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0A12:  MOVFF  41A,87
....................             usb_put_0len_0(); 
0A16:  MOVLB  2
0A18:  CLRF   xB0
0A1A:  MOVLB  0
0A1C:  RCALL  0420
....................             break; 
0A1E:  BRA    0A36
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0A20:  MOVFF  41A,3A
0A24:  MOVFF  41B,39
....................             usb_put_0len_0(); 
0A28:  MOVLB  2
0A2A:  CLRF   xB0
0A2C:  MOVLB  0
0A2E:  RCALL  0420
....................             break; 
0A30:  BRA    0A36
....................  
....................          default: 
....................             usb_request_stall(); 
0A32:  RCALL  0426
....................             break; 
0A34:  BRA    0A36
0A36:  MOVLB  4
....................       } 
....................    } 
.................... } 
0A38:  MOVLB  0
0A3A:  GOTO   0A6E (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
0D04:  BSF    x83.0
....................    usb_cdc_get_buffer_status.index=0; 
0D06:  CLRF   x85
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0D08:  MOVLW  02
0D0A:  MOVLB  2
0D0C:  MOVWF  xAE
0D0E:  MOVLB  0
0D10:  BRA    0CC2
0D12:  MOVFF  01,84
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
0D16:  MOVF   x84,F
0D18:  BNZ   0D1C
....................    { 
....................       usb_cdc_get_discard(); 
0D1A:  RCALL  0CF4
....................    } 
.................... } 
0D1C:  GOTO   0D38 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    //putc('!'); 
....................    if (usb_cdc_put_buffer_nextin /* || (g_LastCDCDataPacketSize == USB_CDC_DATA_IN_SIZE)*/ )  
*
0E1A:  MOVF   x82,F
0E1C:  BZ    0E20
....................    { 
....................       //printf("FL3 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
0E1E:  RCALL  0DF8
....................    } 
.................... } 
0E20:  GOTO   0E50 (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................    usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
*
0DF8:  MOVLW  02
0DFA:  MOVLB  2
0DFC:  MOVWF  xAE
0DFE:  CLRF   xB0
0E00:  MOVLW  43
0E02:  MOVWF  xAF
0E04:  CLRF   xB2
0E06:  MOVFF  82,2B1
0E0A:  MOVLW  02
0E0C:  MOVWF  xB3
0E0E:  MOVLB  0
0E10:  RCALL  0D66
....................    g_LastCDCDataPacketSize = usb_cdc_put_buffer_nextin; 
0E12:  MOVFF  82,88
....................    usb_cdc_put_buffer_nextin=0; 
0E16:  CLRF   x82
.................... } 
0E18:  RETLW  00
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
0398:  CLRF   35
039A:  CLRF   34
039C:  MOVLW  25
039E:  MOVWF  33
03A0:  MOVLW  80
03A2:  MOVWF  32
....................    usb_cdc_line_coding.bCharFormat = 0; 
03A4:  CLRF   36
....................    usb_cdc_line_coding.bParityType = 0; 
03A6:  CLRF   37
....................    usb_cdc_line_coding.bDataBits = 8; 
03A8:  MOVLW  08
03AA:  MOVWF  38
....................    (int8)usb_cdc_carrier = 0; 
03AC:  CLRF   x87
....................    usb_cdc_got_set_line_coding = FALSE; 
03AE:  BCF    x86.0
....................    usb_cdc_break = 0; 
03B0:  CLRF   3A
03B2:  CLRF   39
....................    usb_cdc_put_buffer_nextin = 0; 
03B4:  CLRF   x82
....................    usb_cdc_get_buffer_status.got = 0; 
03B6:  BCF    x83.0
.................... } 
03B8:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
0CF4:  BCF    x83.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0CF6:  MOVLW  02
0CF8:  MOVLB  2
0CFA:  MOVWF  xAE
0CFC:  MOVWF  xAF
0CFE:  MOVLB  0
0D00:  RCALL  0A72
.................... } 
0D02:  RETLW  00
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
*
2738:  BTFSC  x83.0
273A:  BRA    273E
273C:  BRA    2738
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
273E:  MOVF   x85,W
2740:  INCF   x85,F
2742:  CLRF   03
2744:  ADDLW  30
2746:  MOVWF  FE9
2748:  MOVLW  04
274A:  ADDWFC 03,W
274C:  MOVWF  FEA
274E:  MOVFF  FEF,1DB
2752:  MOVLB  1
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
2754:  MOVLB  0
2756:  MOVF   x84,W
2758:  SUBWF  x85,W
275A:  BNC   276C
275C:  CLRF   19
275E:  BTFSC  FF2.7
2760:  BSF    19.7
2762:  BCF    FF2.7
....................    { 
....................       usb_cdc_get_discard(); 
2764:  CALL   0CF4
2768:  BTFSC  19.7
276A:  BSF    FF2.7
....................    } 
....................  
....................    return(c); 
276C:  MOVLB  1
276E:  MOVFF  1DB,01
.................... } 
2772:  MOVLB  0
2774:  RETLW  00
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................  #if defined(__PCH__) 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie = INT_GIE; 
*
146E:  MOVLB  2
1470:  BCF    x9B.0
1472:  BTFSC  FF2.7
1474:  BSF    x9B.0
....................    INT_GIE = 0; 
1476:  BCF    FF2.7
....................  #else 
....................    int16 oldSR; 
....................     
....................    oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
1478:  MOVLB  0
147A:  MOVF   x82,W
147C:  SUBLW  3E
147E:  BC    1484
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
1480:  MOVLW  3E
1482:  MOVWF  x82
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
1484:  MOVF   x82,W
1486:  INCF   x82,F
1488:  CLRF   03
148A:  ADDLW  43
148C:  MOVWF  FE9
148E:  MOVLW  00
1490:  ADDWFC 03,W
1492:  MOVWF  FEA
1494:  MOVFF  29A,FEF
....................  
....................    //renable global interrupts 
....................   #if defined(__PCH__) 
....................    INT_GIE = old_gie; 
1498:  BCF    FF2.7
149A:  MOVLB  2
149C:  BTFSC  x9B.0
149E:  BSF    FF2.7
....................   #else 
....................    SR = oldSR; 
....................   #endif 
.................... } 
14A0:  MOVLB  0
14A2:  GOTO   14AC (RETURN)
....................  
.................... void usb_cdc_putc_fast(char c)  
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
14A6:  MOVFF  299,29A
14AA:  BRA    146E
14AC:  CLRF   19
14AE:  BTFSC  FF2.7
14B0:  BSF    19.7
14B2:  BCF    FF2.7
....................    if (usb_cdc_put_buffer_free())  
14B4:  MOVLW  02
14B6:  MOVLB  2
14B8:  MOVWF  xBB
14BA:  MOVLB  0
14BC:  CALL   0B32
14C0:  BTFSC  19.7
14C2:  BSF    FF2.7
14C4:  MOVF   01,F
14C6:  BZ    14D6
14C8:  CLRF   19
14CA:  BTFSC  FF2.7
14CC:  BSF    19.7
14CE:  BCF    FF2.7
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
14D0:  RCALL  0DF8
14D2:  BTFSC  19.7
14D4:  BSF    FF2.7
....................    } 
....................    //putc('*'); 
.................... } 
14D6:  RETLW  00
....................  
.................... void usb_cdc_putc(char c)  
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
*
2776:  MOVF   x82,W
2778:  SUBLW  3E
277A:  BC    27AA
277C:  CLRF   19
277E:  BTFSC  FF2.7
2780:  BSF    19.7
2782:  BCF    FF2.7
....................       if (usb_cdc_put_buffer_free())  
2784:  MOVLW  02
2786:  MOVLB  2
2788:  MOVWF  xBB
278A:  MOVLB  0
278C:  CALL   0B32
2790:  BTFSC  19.7
2792:  BSF    FF2.7
2794:  MOVF   01,F
2796:  BZ    27A8
2798:  CLRF   19
279A:  BTFSC  FF2.7
279C:  BSF    19.7
279E:  BCF    FF2.7
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
27A0:  CALL   0DF8
27A4:  BTFSC  19.7
27A6:  BSF    FF2.7
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
27A8:  BRA    2776
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
27AA:  MOVFF  1DB,299
27AE:  CALL   14A6
.................... } 
27B2:  RETLW  00
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... { 
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    for (;;) 
....................    { 
....................       c = *ptr++; 
....................       if (!c) 
....................          break; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_out_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD		0x55 
.................... #define MEMORIA_CMD_VER_INFO		0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD				0x40 
.................... #define MEMORIA_CMD_READ_FILE		0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK			0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON		0x01 
.................... #define MEMORIA_OFF		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT		12 
.................... #define MEMORIA_NAME_TERMINATOR		0x00 
.................... #define MEMORIA_DELIMITADOR			0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE		0x00 
.................... #define MEMORIA_LOW_PERFORMANCE		0x40 
....................  
.................... #define FILE_WR 1 
.................... #define FILE_RD 0 
....................  
.................... //extern char MEM_info[5]; 
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... void MEMORIA_getinfo(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char* filename, short modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char* data, unsigned int size); 
.................... void MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char* buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
109A:  MOVLW  08
109C:  MOVWF  01
109E:  MOVLW  04
10A0:  MOVWF  00
10A2:  DECFSZ 00,F
10A4:  BRA    10A2
10A6:  BCF    F8A.1
10A8:  BCF    F93.1
10AA:  MOVLW  04
10AC:  MOVWF  00
10AE:  DECFSZ 00,F
10B0:  BRA    10AE
10B2:  MOVLB  1
10B4:  RLCF   xF8,F
10B6:  BCF    F8A.0
10B8:  BTFSC  FD8.0
10BA:  BSF    F93.0
10BC:  BTFSS  FD8.0
10BE:  BCF    F93.0
10C0:  BSF    F93.1
10C2:  BTFSS  F81.1
10C4:  BRA    10C2
10C6:  DECFSZ 01,F
10C8:  BRA    10CC
10CA:  BRA    10D0
10CC:  MOVLB  0
10CE:  BRA    109E
10D0:  MOVLW  04
10D2:  MOVWF  00
10D4:  DECFSZ 00,F
10D6:  BRA    10D4
10D8:  BCF    F8A.1
10DA:  BCF    F93.1
10DC:  NOP   
10DE:  BSF    F93.0
10E0:  MOVLW  04
10E2:  MOVWF  00
10E4:  DECFSZ 00,F
10E6:  BRA    10E4
10E8:  MOVLW  04
10EA:  MOVWF  00
10EC:  DECFSZ 00,F
10EE:  BRA    10EC
10F0:  BSF    F93.1
10F2:  BTFSS  F81.1
10F4:  BRA    10F2
10F6:  CLRF   01
10F8:  MOVLW  04
10FA:  MOVWF  00
10FC:  DECFSZ 00,F
10FE:  BRA    10FC
1100:  BTFSC  F81.0
1102:  BSF    01.0
1104:  BCF    F8A.1
1106:  BCF    F93.1
1108:  BCF    F8A.0
110A:  BCF    F93.0
110C:  MOVLB  0
110E:  RETLW  00
1110:  MOVLW  08
1112:  MOVLB  1
1114:  MOVWF  xF9
1116:  MOVFF  00,1FA
111A:  BSF    F93.0
111C:  MOVLW  04
111E:  MOVWF  00
1120:  DECFSZ 00,F
1122:  BRA    1120
1124:  BSF    F93.1
1126:  BTFSS  F81.1
1128:  BRA    1126
112A:  BTFSC  F81.0
112C:  BSF    FD8.0
112E:  BTFSS  F81.0
1130:  BCF    FD8.0
1132:  RLCF   01,F
1134:  MOVLW  04
1136:  MOVWF  00
1138:  DECFSZ 00,F
113A:  BRA    1138
113C:  BCF    F93.1
113E:  BCF    F8A.1
1140:  DECFSZ xF9,F
1142:  BRA    111A
1144:  BSF    F93.0
1146:  MOVLW  04
1148:  MOVWF  00
114A:  DECFSZ 00,F
114C:  BRA    114A
114E:  BCF    F8A.0
1150:  MOVF   xFA,W
1152:  BTFSS  FD8.2
1154:  BCF    F93.0
1156:  NOP   
1158:  BSF    F93.1
115A:  BTFSS  F81.1
115C:  BRA    115A
115E:  MOVLW  04
1160:  MOVWF  00
1162:  DECFSZ 00,F
1164:  BRA    1162
1166:  BCF    F8A.1
1168:  BCF    F93.1
116A:  MOVLW  04
116C:  MOVWF  00
116E:  DECFSZ 00,F
1170:  BRA    116E
1172:  BCF    F8A.0
1174:  BCF    F93.0
1176:  MOVLB  0
1178:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_seg = 0x00; 
....................  
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(unsigned int canal, int16 *buffer); 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA_H 
.................... #define CAPTURA_FRECUENCIA_H 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... /* 
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
.................... */ 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... /*struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
.................... */ 
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
.................... //canales de lectura 
.................... #define CCP_CANAL_1 1 
.................... #define CCP_CANAL_2 2 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_8|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
.................... 	Q=-1:   ccp inabilitado 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
.................... int semaforo_ccp = 0; 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... void CP_activar_captura(int canal); 
.................... void CP_desativar_captura(); 
.................... int CP_ocupado(); 
.................... int CP_done(); 
.................... int32 CP_obtener_resultado(); 
....................  
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "configuracion.h" 
.................... #ifndef CONFIGURACION_H 
.................... #define CONFIGURACION_H 
....................  
.................... // opciones de configuracion 
.................... #define CONF_SALIR    '9' 
.................... #define CONF_SET_FECHA  '1' 
.................... #define CONF_GET_FECHA  '2' 
.................... #define CONF_SET_CANAL  '3' 
.................... #define CONF_GET_CANAL  '4' 
.................... #define CONF_SET_DATO   '5' 
.................... #define CONF_GET_DATO   '6' 
....................  
.................... #define CONF_ACK        0x06 
.................... #define CONF_NOACK    0x15 
....................  
.................... //direccion del byte de canales activos y bit de canales 
.................... #define CONF_DIR_CANAl        0x08 
.................... #define CONF_CCP_VEL_BIT    0 
.................... #define CONF_CCP_REV_BIT    1 
.................... #define CONF_CCP_BIT            2 
.................... #define CONF_AD_VEL_BIT        3 
.................... #define CONF_AD_REV_BIT        4 
....................  
.................... // numeracion de sensores 
.................... #define ACC_x        0 
.................... #define ACC_y        1 
.................... #define ACC_z        2 
.................... #define AD_VEL     3 
.................... #define AD_REV        4 
.................... #define CCP_VEl     5 
.................... #define CCP_REV     6 
....................  
....................  
.................... // para el switch de log 
.................... #define LOG_ENABLE    1 
.................... #define LOG_DISABLE    0 
.................... #define LOG_LINE ("\n\r%X:%X:%X:%X:%X:%X:%X:%X:%LX:%LX") 
....................  
.................... // definicion de pines de indicadores 
.................... #define INDICADOR_POWER    PIN_E0 
.................... #define INDICADOR_USB        PIN_E1 
.................... #define INDICADOR_RUN        PIN_E2 
....................  
.................... // esto es para debug 
.................... #ifdef SIMULACION 
....................     #define cout     
....................     #define cin        getc               
.................... #else 
....................     #define cout    usb_cdc_putc_fast, 
....................     #define cin        usb_cdc_getc 
....................     #define putc    usb_cdc_putc 
.................... #endif 
....................  
.................... // definciones utilizadas en el nucleo 
.................... int1 salida = 0; 
.................... byte CONF_CANAL_ACTIVO = 0; 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................     int canal_ccp = CCP_CANAL_1; 
.................... #endif    //CAPTURA_FRECUENCIA_H 
....................  
.................... int myerror = 0; 
.................... int16 lectura = 0; 
.................... char noLog[] = "\n\rno se puede guardar"; 
.................... char testfile[] = "prueba"; 
.................... char buffer_log[39]; 
.................... //int32 resultado = 0; 
.................... struct Log { 
....................     byte dia; 
....................     byte mes; 
....................     byte anio; 
....................     byte hor; 
....................     byte min; 
....................     byte seg; 
....................     int8 sensor; 
....................     int8 no_data; 
....................     int32 value; 
....................     int16 crc; 
.................... } data; 
....................  
.................... void iniciar_perifericos(); 
.................... int sensor_activo(int sensor); 
.................... void modo_configuracion(); 
.................... #endif 
....................  
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
....................  
.................... #ifdef use_rtos 
.................... void activar_tareas(); 
.................... void desactivar_tareas(); 
....................  
....................  
.................... //ifdef MEMORIA_H 
.................... void guardar(){ 
*
1BC0:  MOVLB  2
1BC2:  CLRF   x8D
1BC4:  CLRF   x8E
....................    unsigned int nBytes = 0, escritos = 0; 
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
1BC6:  BSF    F95.2
1BC8:  BTFSS  F83.2
1BCA:  BRA    1E08
....................       sprintf(buffer_log,LOG_LINE, 
....................             DS_dia, DS_mes, DS_anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
1BCC:  MOVLB  0
1BCE:  CLRF   xF7
1BD0:  MOVLW  C1
1BD2:  MOVWF  xF6
1BD4:  MOVLW  0A
1BD6:  MOVLB  2
1BD8:  MOVWF  x91
1BDA:  MOVLB  0
1BDC:  CALL   13CE
1BE0:  MOVLW  0D
1BE2:  MOVLB  2
1BE4:  MOVWF  x91
1BE6:  MOVLB  0
1BE8:  CALL   13CE
1BEC:  MOVFF  8B,28F
1BF0:  MOVLW  37
1BF2:  MOVLB  2
1BF4:  MOVWF  x90
1BF6:  MOVLB  0
1BF8:  CALL   13EE
1BFC:  MOVLW  3A
1BFE:  MOVLB  2
1C00:  MOVWF  x91
1C02:  MOVLB  0
1C04:  CALL   13CE
1C08:  MOVFF  8C,28F
1C0C:  MOVLW  37
1C0E:  MOVLB  2
1C10:  MOVWF  x90
1C12:  MOVLB  0
1C14:  CALL   13EE
1C18:  MOVLW  3A
1C1A:  MOVLB  2
1C1C:  MOVWF  x91
1C1E:  MOVLB  0
1C20:  CALL   13CE
1C24:  MOVFF  8D,28F
1C28:  MOVLW  37
1C2A:  MOVLB  2
1C2C:  MOVWF  x90
1C2E:  MOVLB  0
1C30:  CALL   13EE
1C34:  MOVLW  3A
1C36:  MOVLB  2
1C38:  MOVWF  x91
1C3A:  MOVLB  0
1C3C:  CALL   13CE
1C40:  MOVFF  EB,28F
1C44:  MOVLW  37
1C46:  MOVLB  2
1C48:  MOVWF  x90
1C4A:  MOVLB  0
1C4C:  CALL   13EE
1C50:  MOVLW  3A
1C52:  MOVLB  2
1C54:  MOVWF  x91
1C56:  MOVLB  0
1C58:  CALL   13CE
1C5C:  MOVFF  EC,28F
1C60:  MOVLW  37
1C62:  MOVLB  2
1C64:  MOVWF  x90
1C66:  MOVLB  0
1C68:  CALL   13EE
1C6C:  MOVLW  3A
1C6E:  MOVLB  2
1C70:  MOVWF  x91
1C72:  MOVLB  0
1C74:  CALL   13CE
1C78:  MOVFF  ED,28F
1C7C:  MOVLW  37
1C7E:  MOVLB  2
1C80:  MOVWF  x90
1C82:  MOVLB  0
1C84:  CALL   13EE
1C88:  MOVLW  3A
1C8A:  MOVLB  2
1C8C:  MOVWF  x91
1C8E:  MOVLB  0
1C90:  CALL   13CE
1C94:  MOVFF  EE,28F
1C98:  MOVLW  37
1C9A:  MOVLB  2
1C9C:  MOVWF  x90
1C9E:  MOVLB  0
1CA0:  CALL   13EE
1CA4:  MOVLW  3A
1CA6:  MOVLB  2
1CA8:  MOVWF  x91
1CAA:  MOVLB  0
1CAC:  CALL   13CE
1CB0:  MOVFF  EF,28F
1CB4:  MOVLW  37
1CB6:  MOVLB  2
1CB8:  MOVWF  x90
1CBA:  MOVLB  0
1CBC:  CALL   13EE
1CC0:  MOVLW  3A
1CC2:  MOVLB  2
1CC4:  MOVWF  x91
1CC6:  MOVLB  0
1CC8:  CALL   13CE
1CCC:  MOVFF  F3,28F
1CD0:  MOVLW  37
1CD2:  MOVLB  2
1CD4:  MOVWF  x90
1CD6:  MOVLB  0
1CD8:  CALL   13EE
1CDC:  MOVFF  F2,28F
1CE0:  MOVLW  37
1CE2:  MOVLB  2
1CE4:  MOVWF  x90
1CE6:  MOVLB  0
1CE8:  CALL   13EE
1CEC:  MOVFF  F1,28F
1CF0:  MOVLW  37
1CF2:  MOVLB  2
1CF4:  MOVWF  x90
1CF6:  MOVLB  0
1CF8:  CALL   13EE
1CFC:  MOVFF  F0,28F
1D00:  MOVLW  37
1D02:  MOVLB  2
1D04:  MOVWF  x90
1D06:  MOVLB  0
1D08:  CALL   13EE
1D0C:  MOVLW  3A
1D0E:  MOVLB  2
1D10:  MOVWF  x91
1D12:  MOVLB  0
1D14:  CALL   13CE
1D18:  MOVFF  F5,28F
1D1C:  MOVLW  37
1D1E:  MOVLB  2
1D20:  MOVWF  x90
1D22:  MOVLB  0
1D24:  CALL   13EE
1D28:  MOVFF  F4,28F
1D2C:  MOVLW  37
1D2E:  MOVLB  2
1D30:  MOVWF  x90
1D32:  MOVLB  0
1D34:  CALL   13EE
....................              
....................       #ifdef MEMORIA_H 
....................       nBytes = strlen(buffer_log); 
1D38:  MOVLB  2
1D3A:  CLRF   x93
1D3C:  MOVLW  C1
1D3E:  MOVWF  x92
1D40:  MOVLB  0
1D42:  CALL   1434
1D46:  MOVFF  01,28D
....................       if((myerror = MEMORIA_open(testfile, FILE_WR)) != 0){ 
1D4A:  MOVLB  2
1D4C:  CLRF   x90
1D4E:  MOVLW  BA
1D50:  MOVWF  x8F
1D52:  MOVLW  01
1D54:  MOVWF  x91
1D56:  MOVLB  0
1D58:  BRA    16B0
1D5A:  MOVFF  01,A1
1D5E:  MOVF   xA1,F
1D60:  BZ    1D88
....................          printf(usb_cdc_putc_fast,"\n\rMO%d",myerror); 
1D62:  MOVLW  58
1D64:  MOVWF  FF6
1D66:  MOVLW  10
1D68:  MOVWF  FF7
1D6A:  MOVLW  04
1D6C:  MOVLB  2
1D6E:  MOVWF  x93
1D70:  MOVLB  0
1D72:  CALL   14D8
1D76:  MOVFF  A1,293
1D7A:  MOVLW  1F
1D7C:  MOVLB  2
1D7E:  MOVWF  x94
1D80:  MOVLB  0
1D82:  CALL   152C
....................       }else{ 
1D86:  BRA    1DF6
....................          if( (myerror = MEMORIA_write(nBytes)) != 0 ){ 
1D88:  MOVFF  28D,28F
1D8C:  BRA    18E0
1D8E:  MOVFF  01,A1
1D92:  MOVF   xA1,F
1D94:  BZ    1DBC
....................             printf(usb_cdc_putc_fast,"\n\rMW%d",myerror); 
1D96:  MOVLW  60
1D98:  MOVWF  FF6
1D9A:  MOVLW  10
1D9C:  MOVWF  FF7
1D9E:  MOVLW  04
1DA0:  MOVLB  2
1DA2:  MOVWF  x93
1DA4:  MOVLB  0
1DA6:  CALL   14D8
1DAA:  MOVFF  A1,293
1DAE:  MOVLW  1F
1DB0:  MOVLB  2
1DB2:  MOVWF  x94
1DB4:  MOVLB  0
1DB6:  CALL   152C
....................          }else{ 
1DBA:  BRA    1DF6
....................             escritos = MEMORIA_set_data(buffer_log, nBytes); 
1DBC:  MOVLB  2
1DBE:  CLRF   x90
1DC0:  MOVLW  C1
1DC2:  MOVWF  x8F
1DC4:  MOVFF  28D,291
1DC8:  MOVLB  0
1DCA:  BRA    19D8
1DCC:  MOVFF  01,28E
....................             printf(usb_cdc_putc_fast,"\n\rMS%d", escritos); 
1DD0:  MOVLW  68
1DD2:  MOVWF  FF6
1DD4:  MOVLW  10
1DD6:  MOVWF  FF7
1DD8:  MOVLW  04
1DDA:  MOVLB  2
1DDC:  MOVWF  x93
1DDE:  MOVLB  0
1DE0:  CALL   14D8
1DE4:  MOVFF  28E,293
1DE8:  MOVLW  1F
1DEA:  MOVLB  2
1DEC:  MOVWF  x94
1DEE:  MOVLB  0
1DF0:  CALL   152C
....................             MEMORIA_close(); 
1DF4:  BRA    1A9A
....................          } 
....................       } 
....................       #endif   //MEMORIA_H 
....................        
....................       if(_debug_usb()){ 
1DF6:  RCALL  1B7E
1DF8:  MOVF   01,F
1DFA:  BZ    1E04
....................          printf(cout buffer_log); 
1DFC:  CLRF   FEA
1DFE:  MOVLW  C1
1E00:  MOVWF  FE9
1E02:  RCALL  1B9C
....................       } 
....................    }else{ 
1E04:  BRA    1E18
1E06:  MOVLB  2
....................       if(_debug_usb()){ 
1E08:  MOVLB  0
1E0A:  RCALL  1B7E
1E0C:  MOVF   01,F
1E0E:  BZ    1E18
....................          printf(cout nolog); 
1E10:  CLRF   FEA
1E12:  MOVLW  A4
1E14:  MOVWF  FE9
1E16:  RCALL  1B9C
....................       } 
....................    } 
....................    //if(_debug_usb()){printf(usb_cdc_putc_fast,"%s %u",buffer_log, nBytes);} 
.................... } 
1E18:  RETLW  00
....................  
.................... /* 
.................... #else 
.................... void guardar(){ 
....................    if(_debug_usb()){ 
....................       if(input(PIN_LOG) == LOG_ENABLE){ 
....................          sprintf(buffer_log,LOG_LINE, 
....................             data.dia, data.mes, data.anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
....................          printf(cout buffer_log); 
....................       } else { 
....................          printf(cout nolog); 
....................       } 
....................    } 
.................... } 
.................... #endif 
.................... */ 
....................  
.................... #task (rate=500ms, max=5ms) 
.................... void proceso2(){    
....................    salida = (salida)? 0 : 1; 
*
1070:  BTFSS  x86.1
1072:  BRA    1078
1074:  MOVLW  00
1076:  BRA    107A
1078:  MOVLW  01
107A:  BCF    x86.1
107C:  BTFSC  FE8.0
107E:  BSF    x86.1
....................    if(salida) output_bit(INDICADOR_RUN, 1); 
1080:  BTFSS  x86.1
1082:  BRA    108A
1084:  BSF    F8D.2
1086:  BCF    F96.2
....................    else output_bit(INDICADOR_RUN, 0); 
1088:  BRA    108E
108A:  BCF    F8D.2
108C:  BCF    F96.2
....................    //rtos_yield(); 
.................... } 
108E:  MOVLW  70
1090:  MOVWF  xFD
1092:  MOVLW  10
1094:  MOVWF  xFE
1096:  GOTO   309C
.................... /* 
.................... #task (rate=100ms, max=50ms) 
.................... void testMemoria(){ 
....................    data.sensor = 255; 
....................    data.value = rand(); 
....................    data.crc = rand(); 
....................    ++data.no_data; 
....................    guardar(); 
....................    rtos_yield(); 
.................... }  
.................... */ 
....................  
.................... #ifdef DS1307_H 
.................... #task (rate=500ms, max=50ms) 
.................... void reloj(){ 
....................    ds1307_get_date(DS_dia, DS_mes, DS_anio, DS_vic); 
....................    ds1307_get_time(DS_hor, DS_min, DS_seg); 
....................    data.dia = DS_dia; 
*
1356:  MOVFF  8B,E8
....................    data.mes = DS_mes; 
135A:  MOVFF  8C,E9
....................    data.anio = DS_anio; 
135E:  MOVFF  8D,EA
....................    data.hor = DS_hor; 
1362:  MOVFF  8E,EB
....................    data.min = DS_min; 
1366:  MOVFF  8F,EC
....................    data.seg = DS_seg; 
136A:  MOVFF  90,ED
....................    //rtos_yield(); 
.................... } 
136E:  MOVLW  A4
1370:  MOVLB  1
1372:  MOVWF  x0C
1374:  MOVLW  11
1376:  MOVWF  x0D
1378:  GOTO   309C
.................... #endif   //DS1307_H 
....................  
.................... #ifdef ANALOGO_DIGITAL_H 
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea1() 
....................    { 
....................       AD_leer_canal(ACC_x,&lectura); 
*
1E1A:  MOVLB  2
1E1C:  CLRF   x70
1E1E:  CLRF   x72
1E20:  MOVLW  A2
1E22:  MOVWF  x71
1E24:  MOVLB  0
1E26:  CALL   137C
....................       data.sensor = ACC_x; 
1E2A:  CLRF   xEE
....................       data.value = lectura; 
1E2C:  CLRF   xF3
1E2E:  CLRF   xF2
1E30:  MOVFF  A3,F1
1E34:  MOVFF  A2,F0
....................       ++data.no_data; 
1E38:  INCF   xEF,F
....................       guardar(); 
1E3A:  RCALL  1BC0
....................       //rtos_yield(); 
....................    } 
1E3C:  MOVLW  1A
1E3E:  MOVLB  1
1E40:  MOVWF  x1B
1E42:  MOVLW  1E
1E44:  MOVWF  x1C
1E46:  GOTO   309C
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea2(){ 
....................       AD_leer_canal(ACC_y,&lectura); 
1E4A:  MOVLW  01
1E4C:  MOVLB  2
1E4E:  MOVWF  x70
1E50:  CLRF   x72
1E52:  MOVLW  A2
1E54:  MOVWF  x71
1E56:  MOVLB  0
1E58:  CALL   137C
....................       data.sensor = ACC_y; 
1E5C:  MOVLW  01
1E5E:  MOVWF  xEE
....................       data.value = lectura; 
1E60:  CLRF   xF3
1E62:  CLRF   xF2
1E64:  MOVFF  A3,F1
1E68:  MOVFF  A2,F0
....................       ++data.no_data; 
1E6C:  INCF   xEF,F
....................       guardar(); 
1E6E:  RCALL  1BC0
....................       //rtos_yield(); 
....................    } 
1E70:  MOVLW  4A
1E72:  MOVLB  1
1E74:  MOVWF  x2A
1E76:  MOVLW  1E
1E78:  MOVWF  x2B
1E7A:  GOTO   309C
....................     
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea3(){ 
....................       AD_leer_canal(ACC_z,&lectura); 
1E7E:  MOVLW  02
1E80:  MOVLB  2
1E82:  MOVWF  x70
1E84:  CLRF   x72
1E86:  MOVLW  A2
1E88:  MOVWF  x71
1E8A:  MOVLB  0
1E8C:  CALL   137C
....................       data.sensor = ACC_z; 
1E90:  MOVLW  02
1E92:  MOVWF  xEE
....................       data.value = lectura; 
1E94:  CLRF   xF3
1E96:  CLRF   xF2
1E98:  MOVFF  A3,F1
1E9C:  MOVFF  A2,F0
....................       ++data.no_data; 
1EA0:  INCF   xEF,F
....................       guardar(); 
1EA2:  RCALL  1BC0
....................       //rtos_yield(); 
....................    } 
1EA4:  MOVLW  7E
1EA6:  MOVLB  1
1EA8:  MOVWF  x39
1EAA:  MOVLW  1E
1EAC:  MOVWF  x3A
1EAE:  GOTO   309C
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_VEL(){ 
....................       if(!sensor_activo(AD_VEL)){return;} 
*
1EFA:  MOVLW  03
1EFC:  MOVLB  2
1EFE:  MOVWF  x8D
1F00:  MOVLB  0
1F02:  RCALL  1EB2
1F04:  MOVF   01,F
1F06:  BNZ   1F0A
1F08:  BRA    1F30
....................       AD_leer_canal(AD_VEL,&lectura); 
1F0A:  MOVLW  03
1F0C:  MOVLB  2
1F0E:  MOVWF  x70
1F10:  CLRF   x72
1F12:  MOVLW  A2
1F14:  MOVWF  x71
1F16:  MOVLB  0
1F18:  CALL   137C
....................       data.sensor = AD_VEL; 
1F1C:  MOVLW  03
1F1E:  MOVWF  xEE
....................       data.value = lectura; 
1F20:  CLRF   xF3
1F22:  CLRF   xF2
1F24:  MOVFF  A3,F1
1F28:  MOVFF  A2,F0
....................       ++data.no_data; 
1F2C:  INCF   xEF,F
....................       guardar(); 
1F2E:  RCALL  1BC0
....................       //rtos_yield(); 
....................    } 
1F30:  MOVLW  FA
1F32:  MOVLB  1
1F34:  MOVWF  x48
1F36:  MOVLW  1E
1F38:  MOVWF  x49
1F3A:  GOTO   309C
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_REV(){ 
....................       if(!sensor_activo(AD_REV)){return;} 
1F3E:  MOVLW  04
1F40:  MOVLB  2
1F42:  MOVWF  x8D
1F44:  MOVLB  0
1F46:  RCALL  1EB2
1F48:  MOVF   01,F
1F4A:  BNZ   1F4E
1F4C:  BRA    1F74
....................       AD_leer_canal(AD_REV,&lectura); 
1F4E:  MOVLW  04
1F50:  MOVLB  2
1F52:  MOVWF  x70
1F54:  CLRF   x72
1F56:  MOVLW  A2
1F58:  MOVWF  x71
1F5A:  MOVLB  0
1F5C:  CALL   137C
....................       data.sensor = AD_REV; 
1F60:  MOVLW  04
1F62:  MOVWF  xEE
....................       data.value = lectura; 
1F64:  CLRF   xF3
1F66:  CLRF   xF2
1F68:  MOVFF  A3,F1
1F6C:  MOVFF  A2,F0
....................       ++data.no_data; 
1F70:  INCF   xEF,F
....................       guardar(); 
1F72:  RCALL  1BC0
....................       //rtos_yield(); 
....................    } 
1F74:  MOVLW  3E
1F76:  MOVLB  1
1F78:  MOVWF  x57
1F7A:  MOVLW  1F
1F7C:  MOVWF  x58
1F7E:  GOTO   309C
.................... #endif   //ANALOGO_DIGITAL_H 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................    #task (rate=850ms, max=50ms) 
....................    void rpm(){ 
....................       // agregar una condicion para comprobar que esta tarea este abilitada para 
....................       // ejecutarse 
....................       if(!(sensor_activo(CCP_VEL)||sensor_activo(CCP_REV))){return;} 
*
205E:  MOVLW  05
2060:  MOVLB  2
2062:  MOVWF  x8D
2064:  MOVLB  0
2066:  RCALL  1EB2
2068:  MOVF   01,F
206A:  BNZ   207C
206C:  MOVLW  06
206E:  MOVLB  2
2070:  MOVWF  x8D
2072:  MOVLB  0
2074:  RCALL  1EB2
2076:  MOVF   01,F
2078:  BNZ   207C
207A:  BRA    20F0
....................        
....................       if(!CP_ocupado()){ 
207C:  BRA    1F82
207E:  MOVF   01,F
2080:  BNZ   20C2
....................          desactivar_tareas(); 
2082:  BRA    1F92
....................          if(canal_ccp == CCP_CANAL_1){ 
2084:  DECFSZ xA0,W
2086:  BRA    20A0
....................             canal_ccp = (sensor_activo(CCP_VEL))? CCP_CANAL_2 : CCP_CANAL_1; 
2088:  MOVLW  05
208A:  MOVLB  2
208C:  MOVWF  x8D
208E:  MOVLB  0
2090:  RCALL  1EB2
2092:  MOVF   01,F
2094:  BZ    209A
2096:  MOVLW  02
2098:  BRA    209C
209A:  MOVLW  01
209C:  MOVWF  xA0
....................          }else   if(canal_ccp == CCP_CANAL_2){ 
209E:  BRA    20BC
20A0:  MOVF   xA0,W
20A2:  SUBLW  02
20A4:  BNZ   20BC
....................             canal_ccp = (sensor_activo(CCP_REV))? CCP_CANAL_1 : CCP_CANAL_2; 
20A6:  MOVLW  06
20A8:  MOVLB  2
20AA:  MOVWF  x8D
20AC:  MOVLB  0
20AE:  RCALL  1EB2
20B0:  MOVF   01,F
20B2:  BZ    20B8
20B4:  MOVLW  01
20B6:  BRA    20BA
20B8:  MOVLW  02
20BA:  MOVWF  xA0
....................          } 
....................           
....................          //canal_ccp = (canal_ccp == CCP_CANAL_1)? CCP_CANAL_2 : CCP_CANAL_1; 
....................          CP_activar_captura(canal_ccp); 
20BC:  MOVFF  A0,28D
20C0:  BRA    1FAC
....................       } 
....................       //rtos_await(Q_CCP == 2);                        
....................       if(!CP_done()){ 
20C2:  BRA    1FE6
20C4:  MOVF   01,F
20C6:  BNZ   20CA
....................          //rtos_yield(); 
....................          return; 
20C8:  BRA    20F0
....................       }   
....................       data.value = CP_obtener_resultado(); 
20CA:  BRA    1FF8
20CC:  MOVFF  03,F3
20D0:  MOVFF  02,F2
20D4:  MOVFF  01,F1
20D8:  MOVFF  00,F0
....................       CP_desativar_captura(); 
20DC:  BRA    2014
....................       data.sensor = (canal_ccp == CCP_CANAL_1)? CCP_REV: CCP_VEL; 
20DE:  DECFSZ xA0,W
20E0:  BRA    20E6
20E2:  MOVLW  06
20E4:  BRA    20E8
20E6:  MOVLW  05
20E8:  MOVWF  xEE
....................       data.no_data++; 
20EA:  INCF   xEF,F
....................       guardar(); 
20EC:  RCALL  1BC0
....................       activar_tareas(); 
20EE:  BRA    2044
....................       //rtos_yield(); 
....................    } 
20F0:  MOVLW  5E
20F2:  MOVLB  1
20F4:  MOVWF  x66
20F6:  MOVLW  20
20F8:  MOVWF  x67
20FA:  GOTO   309C
.................... #endif   //CAPTURA_FRECUENCIA_H 
....................  
.................... void activar_tareas(){ 
....................    rtos_enable(reloj); 
*
2044:  MOVLB  1
2046:  BCF    x07.7
....................    rtos_enable(proceso2); 
2048:  MOVLB  0
204A:  BCF    xF8.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_enable(Tarea1); 
204C:  MOVLB  1
204E:  BCF    x16.7
....................    rtos_enable(Tarea2); 
2050:  BCF    x25.7
....................    rtos_enable(Tarea3); 
2052:  BCF    x34.7
....................    rtos_enable(leer_AD_REV); 
2054:  BCF    x52.7
....................    rtos_enable(leer_AD_VEL); 
2056:  BCF    x43.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
2058:  MOVLB  0
205A:  GOTO   20F0 (RETURN)
....................  
.................... void desactivar_tareas(){ 
....................    rtos_disable(reloj); 
*
1F92:  MOVLB  1
1F94:  BSF    x07.7
....................    rtos_disable(proceso2); 
1F96:  MOVLB  0
1F98:  BSF    xF8.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_disable(Tarea1); 
1F9A:  MOVLB  1
1F9C:  BSF    x16.7
....................    rtos_disable(Tarea2); 
1F9E:  BSF    x25.7
....................    rtos_disable(Tarea3); 
1FA0:  BSF    x34.7
....................    rtos_disable(leer_AD_REV); 
1FA2:  BSF    x52.7
....................    rtos_disable(leer_AD_VEL); 
1FA4:  BSF    x43.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
1FA6:  MOVLB  0
1FA8:  GOTO   2084 (RETURN)
....................  
.................... #endif   //use_rtos 
....................  
.................... //#include "test.c"   // comentar esto en la aplicacion final 
....................  
.................... /*======================= configuracon de dispositivos =======================*/ 
.................... void setup_devices(){ 
....................    iniciar_perifericos(); 
*
26E0:  BRA    267C
....................     
....................    setup_psp(PSP_DISABLED); 
26E2:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
26E4:  BCF    FD1.0
....................    setup_spi(SPI_SS_DISABLED); 
26E6:  BCF    FC6.5
26E8:  BCF    F94.7
26EA:  BSF    F93.0
26EC:  BCF    F93.1
26EE:  MOVLW  01
26F0:  MOVWF  FC6
26F2:  MOVLW  00
26F4:  MOVWF  FC7
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
26F6:  MOVLW  88
26F8:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
26FA:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
26FC:  MOVLW  00
26FE:  MOVWF  FCA
2700:  MOVLW  00
2702:  MOVWF  FCB
....................    #ifndef CAPTURA_FRECUENCIA_H 
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    setup_ccp1(CCP_OFF); 
....................    #endif 
....................    setup_comparator(NC_NC_NC_NC); 
2704:  MOVLW  07
2706:  MOVWF  FB4
2708:  MOVF   F92,W
270A:  MOVWF  F92
270C:  MOVLW  0D
270E:  MOVWF  00
2710:  DECFSZ 00,F
2712:  BRA    2710
2714:  MOVF   FB4,W
2716:  BCF    FA1.6
....................    setup_vref(FALSE); 
2718:  CLRF   FB5
....................     
....................    /*===================para los indicadores========================*/ 
....................    set_tris_e(0x00); 
271A:  MOVLW  00
271C:  MOVWF  F96
....................    set_tris_b(0x00); 
271E:  MOVWF  F93
....................    set_tris_c(CONFIG_PORT_C);      //configuracion para el modulo de memoria y CCP. mirar Nucleo.h 
2720:  MOVLW  83
2722:  MOVWF  F94
....................    set_tris_d(CONFIG_PORT_D); 
2724:  MOVLW  4E
2726:  MOVWF  F95
....................    output_bit(INDICADOR_USB, 0); 
2728:  BCF    F8D.1
272A:  BCF    F96.1
....................    output_bit(INDICADOR_POWER, 1); 
272C:  BSF    F8D.0
272E:  BCF    F96.0
....................    output_bit(INDICADOR_RUN, 1); 
2730:  BSF    F8D.2
2732:  BCF    F96.2
....................    //output_low(SPI_SCL); 
....................    //output_high(SPI_SS); 
....................    //output_low(SPI_MOSI); 
....................    //output_high(SPI_MISO); 
....................    //delay_ms(3000); 
....................     
....................     
....................    return; 
.................... } 
2734:  GOTO   2ED0 (RETURN)
....................  
.................... /*=========================================================================== 
.................... ||                               MAIN                                        || 
.................... =============================================================================*/ 
.................... void main(void) { 
*
2CA6:  CLRF   FF8
2CA8:  BCF    FD0.7
2CAA:  BSF    07.7
2CAC:  CLRF   FEA
2CAE:  CLRF   FE9
2CB0:  CLRF   2B
2CB2:  CLRF   2F
2CB4:  CLRF   x82
2CB6:  CLRF   x89
2CB8:  CLRF   x8A
2CBA:  CLRF   x8B
2CBC:  CLRF   x8C
2CBE:  CLRF   x8D
2CC0:  CLRF   x8E
2CC2:  CLRF   x8F
2CC4:  CLRF   x90
2CC6:  MOVLW  FD
2CC8:  MOVWF  x91
2CCA:  MOVLW  05
2CCC:  MOVWF  x92
2CCE:  MOVWF  x93
2CD0:  MOVLW  FF
2CD2:  MOVWF  x94
2CD4:  CLRF   x95
2CD6:  CLRF   x99
2CD8:  CLRF   x98
2CDA:  CLRF   x97
2CDC:  CLRF   x96
2CDE:  CLRF   x9D
2CE0:  CLRF   x9C
2CE2:  CLRF   x9B
2CE4:  CLRF   x9A
2CE6:  CLRF   x9E
2CE8:  BCF    x86.1
2CEA:  CLRF   x9F
2CEC:  MOVLW  01
2CEE:  MOVWF  xA0
2CF0:  CLRF   xA1
2CF2:  CLRF   xA3
2CF4:  CLRF   xA2
2CF6:  MOVLB  1
2CF8:  CLRF   x70
2CFA:  BSF    FB8.3
2CFC:  MOVLW  A0
2CFE:  MOVWF  FAF
2D00:  MOVLW  01
2D02:  MOVWF  FB0
2D04:  MOVLW  A6
2D06:  MOVWF  FAC
2D08:  MOVLW  90
2D0A:  MOVWF  FAB
2D0C:  MOVLB  0
2D0E:  BCF    x86.2
2D10:  BCF    x86.3
2D12:  BCF    x86.4
2D14:  BCF    x86.5
2D16:  MOVLB  1
2D18:  CLRF   xBF
2D1A:  CLRF   xC0
2D1C:  CLRF   xC1
2D1E:  CLRF   xC5
2D20:  CLRF   xC4
2D22:  CLRF   xC3
2D24:  CLRF   xC2
2D26:  MOVLW  01
2D28:  MOVWF  xD7
2D2A:  MOVLW  80
2D2C:  MOVWF  xD8
2D2E:  MOVLW  40
2D30:  MOVWF  xD9
2D32:  MOVLW  15
2D34:  MOVWF  xDA
2D36:  MOVF   FC1,W
2D38:  ANDLW  C0
2D3A:  IORLW  0F
2D3C:  MOVWF  FC1
2D3E:  MOVLW  07
2D40:  MOVWF  FB4
2D42:  MOVLW  03
2D44:  MOVWF  1B
2D46:  CLRF   1C
2D48:  CLRF   1D
2D4A:  CLRF   1E
2D4C:  CLRF   27
2D4E:  MOVLW  04
2D50:  MOVWF  28
2D52:  MOVLW  0C
2D54:  MOVWF  29
2D56:  MOVLW  0A
2D58:  MOVLB  0
2D5A:  MOVWF  xA4
2D5C:  MOVLW  0D
2D5E:  MOVWF  xA5
2D60:  MOVLW  6E
2D62:  MOVWF  xA6
2D64:  MOVLW  6F
2D66:  MOVWF  xA7
2D68:  MOVLW  20
2D6A:  MOVWF  xA8
2D6C:  MOVLW  73
2D6E:  MOVWF  xA9
2D70:  MOVLW  65
2D72:  MOVWF  xAA
2D74:  MOVLW  20
2D76:  MOVWF  xAB
2D78:  MOVLW  70
2D7A:  MOVWF  xAC
2D7C:  MOVLW  75
2D7E:  MOVWF  xAD
2D80:  MOVLW  65
2D82:  MOVWF  xAE
2D84:  MOVLW  64
2D86:  MOVWF  xAF
2D88:  MOVLW  65
2D8A:  MOVWF  xB0
2D8C:  MOVLW  20
2D8E:  MOVWF  xB1
2D90:  MOVLW  67
2D92:  MOVWF  xB2
2D94:  MOVLW  75
2D96:  MOVWF  xB3
2D98:  MOVLW  61
2D9A:  MOVWF  xB4
2D9C:  MOVLW  72
2D9E:  MOVWF  xB5
2DA0:  MOVLW  64
2DA2:  MOVWF  xB6
2DA4:  MOVLW  61
2DA6:  MOVWF  xB7
2DA8:  MOVLW  72
2DAA:  MOVWF  xB8
2DAC:  CLRF   xB9
2DAE:  MOVLW  70
2DB0:  MOVWF  xBA
2DB2:  MOVLW  72
2DB4:  MOVWF  xBB
2DB6:  MOVLW  75
2DB8:  MOVWF  xBC
2DBA:  MOVLW  65
2DBC:  MOVWF  xBD
2DBE:  MOVLW  62
2DC0:  MOVWF  xBE
2DC2:  MOVLW  61
2DC4:  MOVWF  xBF
2DC6:  CLRF   xC0
2DC8:  CLRF   xF6
2DCA:  CLRF   xF7
2DCC:  MOVLW  4C
2DCE:  MOVLB  1
2DD0:  MOVWF  x71
2DD2:  MOVLW  75
2DD4:  MOVWF  x72
2DD6:  MOVLW  6E
2DD8:  MOVWF  x73
2DDA:  MOVLW  65
2DDC:  MOVWF  x74
2DDE:  MOVLW  73
2DE0:  MOVWF  x75
2DE2:  CLRF   x76
2DE4:  CLRF   x77
2DE6:  CLRF   x78
2DE8:  CLRF   x79
2DEA:  CLRF   x7A
2DEC:  CLRF   x7B
2DEE:  MOVLW  4D
2DF0:  MOVWF  x7C
2DF2:  MOVLW  61
2DF4:  MOVWF  x7D
2DF6:  MOVLW  72
2DF8:  MOVWF  x7E
2DFA:  MOVLW  74
2DFC:  MOVWF  x7F
2DFE:  MOVLW  65
2E00:  MOVWF  x80
2E02:  MOVLW  73
2E04:  MOVWF  x81
2E06:  CLRF   x82
2E08:  CLRF   x83
2E0A:  CLRF   x84
2E0C:  CLRF   x85
2E0E:  CLRF   x86
2E10:  MOVLW  4D
2E12:  MOVWF  x87
2E14:  MOVLW  69
2E16:  MOVWF  x88
2E18:  MOVLW  E9
2E1A:  MOVWF  x89
2E1C:  MOVLW  72
2E1E:  MOVWF  x8A
2E20:  MOVLW  63
2E22:  MOVWF  x8B
2E24:  MOVLW  6F
2E26:  MOVWF  x8C
2E28:  MOVLW  6C
2E2A:  MOVWF  x8D
2E2C:  MOVLW  65
2E2E:  MOVWF  x8E
2E30:  MOVLW  73
2E32:  MOVWF  x8F
2E34:  CLRF   x90
2E36:  CLRF   x91
2E38:  MOVLW  4A
2E3A:  MOVWF  x92
2E3C:  MOVLW  75
2E3E:  MOVWF  x93
2E40:  MOVLW  65
2E42:  MOVWF  x94
2E44:  MOVLW  76
2E46:  MOVWF  x95
2E48:  MOVLW  65
2E4A:  MOVWF  x96
2E4C:  MOVLW  73
2E4E:  MOVWF  x97
2E50:  CLRF   x98
2E52:  CLRF   x99
2E54:  CLRF   x9A
2E56:  CLRF   x9B
2E58:  CLRF   x9C
2E5A:  MOVLW  56
2E5C:  MOVWF  x9D
2E5E:  MOVLW  69
2E60:  MOVWF  x9E
2E62:  MOVLW  65
2E64:  MOVWF  x9F
2E66:  MOVLW  72
2E68:  MOVWF  xA0
2E6A:  MOVLW  6E
2E6C:  MOVWF  xA1
2E6E:  MOVLW  65
2E70:  MOVWF  xA2
2E72:  MOVLW  73
2E74:  MOVWF  xA3
2E76:  CLRF   xA4
2E78:  CLRF   xA5
2E7A:  CLRF   xA6
2E7C:  CLRF   xA7
2E7E:  MOVLW  53
2E80:  MOVWF  xA8
2E82:  MOVLW  E1
2E84:  MOVWF  xA9
2E86:  MOVLW  62
2E88:  MOVWF  xAA
2E8A:  MOVLW  61
2E8C:  MOVWF  xAB
2E8E:  MOVLW  64
2E90:  MOVWF  xAC
2E92:  MOVLW  6F
2E94:  MOVWF  xAD
2E96:  CLRF   xAE
2E98:  CLRF   xAF
2E9A:  CLRF   xB0
2E9C:  CLRF   xB1
2E9E:  CLRF   xB2
2EA0:  MOVLW  44
2EA2:  MOVWF  xB3
2EA4:  MOVLW  6F
2EA6:  MOVWF  xB4
2EA8:  MOVLW  6D
2EAA:  MOVWF  xB5
2EAC:  MOVLW  69
2EAE:  MOVWF  xB6
2EB0:  MOVLW  6E
2EB2:  MOVWF  xB7
2EB4:  MOVLW  67
2EB6:  MOVWF  xB8
2EB8:  MOVLW  6F
2EBA:  MOVWF  xB9
2EBC:  CLRF   xBA
2EBE:  CLRF   xBB
2EC0:  CLRF   xBE
2EC2:  CLRF   xC6
2EC4:  CLRF   xC7
2EC6:  CLRF   xC8
2EC8:  CLRF   xC9
2ECA:  CLRF   xCA
....................    setup_devices(); 
2ECC:  MOVLB  0
2ECE:  BRA    26E0
....................    #ifdef use_rtos 
....................    _debug_usb(); 
2ED0:  CALL   1B7E
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
2ED4:  BSF    F95.2
2ED6:  BTFSS  F83.2
2ED8:  BRA    2EDE
....................       modo_configuracion();   // si esta el log activo entra en modo configuracion 
2EDA:  BRA    291C
....................    }else{ 
2EDC:  BRA    3158
....................       rtos_run(); //A partir de aqu comenzar la ejecucin de las tareas 
2EDE:  CLRF   xF8
2EE0:  CLRF   xFA
2EE2:  MOVLW  0A
2EE4:  MOVWF  xF9
2EE6:  CLRF   xFC
2EE8:  CLRF   xFB
2EEA:  MOVLB  1
2EEC:  CLRF   x02
2EEE:  CLRF   x01
2EF0:  CLRF   x00
2EF2:  MOVLB  0
2EF4:  CLRF   xFF
2EF6:  MOVLW  FF
2EF8:  MOVLB  1
2EFA:  MOVWF  x04
2EFC:  MOVWF  x03
2EFE:  CLRF   x06
2F00:  CLRF   x05
2F02:  MOVLW  70
2F04:  MOVLB  0
2F06:  MOVWF  xFD
2F08:  MOVLW  10
2F0A:  MOVWF  xFE
2F0C:  MOVLB  1
2F0E:  CLRF   x07
2F10:  CLRF   x09
2F12:  MOVLW  0A
2F14:  MOVWF  x08
2F16:  CLRF   x0B
2F18:  CLRF   x0A
2F1A:  CLRF   x11
2F1C:  CLRF   x10
2F1E:  CLRF   x0F
2F20:  CLRF   x0E
2F22:  MOVLW  FF
2F24:  MOVWF  x13
2F26:  MOVWF  x12
2F28:  CLRF   x15
2F2A:  CLRF   x14
2F2C:  MOVLW  A4
2F2E:  MOVWF  x0C
2F30:  MOVLW  11
2F32:  MOVWF  x0D
2F34:  CLRF   x16
2F36:  CLRF   x18
2F38:  MOVLW  06
2F3A:  MOVWF  x17
2F3C:  CLRF   x1A
2F3E:  CLRF   x19
2F40:  CLRF   x20
2F42:  CLRF   x1F
2F44:  CLRF   x1E
2F46:  CLRF   x1D
2F48:  MOVLW  FF
2F4A:  MOVWF  x22
2F4C:  MOVWF  x21
2F4E:  CLRF   x24
2F50:  CLRF   x23
2F52:  MOVLW  1A
2F54:  MOVWF  x1B
2F56:  MOVLW  1E
2F58:  MOVWF  x1C
2F5A:  CLRF   x25
2F5C:  CLRF   x27
2F5E:  MOVLW  06
2F60:  MOVWF  x26
2F62:  CLRF   x29
2F64:  CLRF   x28
2F66:  CLRF   x2F
2F68:  CLRF   x2E
2F6A:  CLRF   x2D
2F6C:  CLRF   x2C
2F6E:  MOVLW  FF
2F70:  MOVWF  x31
2F72:  MOVWF  x30
2F74:  CLRF   x33
2F76:  CLRF   x32
2F78:  MOVLW  4A
2F7A:  MOVWF  x2A
2F7C:  MOVLW  1E
2F7E:  MOVWF  x2B
2F80:  CLRF   x34
2F82:  CLRF   x36
2F84:  MOVLW  06
2F86:  MOVWF  x35
2F88:  CLRF   x38
2F8A:  CLRF   x37
2F8C:  CLRF   x3E
2F8E:  CLRF   x3D
2F90:  CLRF   x3C
2F92:  CLRF   x3B
2F94:  MOVLW  FF
2F96:  MOVWF  x40
2F98:  MOVWF  x3F
2F9A:  CLRF   x42
2F9C:  CLRF   x41
2F9E:  MOVLW  7E
2FA0:  MOVWF  x39
2FA2:  MOVLW  1E
2FA4:  MOVWF  x3A
2FA6:  CLRF   x43
2FA8:  CLRF   x45
2FAA:  MOVLW  09
2FAC:  MOVWF  x44
2FAE:  CLRF   x47
2FB0:  CLRF   x46
2FB2:  CLRF   x4D
2FB4:  CLRF   x4C
2FB6:  CLRF   x4B
2FB8:  CLRF   x4A
2FBA:  MOVLW  FF
2FBC:  MOVWF  x4F
2FBE:  MOVWF  x4E
2FC0:  CLRF   x51
2FC2:  CLRF   x50
2FC4:  MOVLW  FA
2FC6:  MOVWF  x48
2FC8:  MOVLW  1E
2FCA:  MOVWF  x49
2FCC:  CLRF   x52
2FCE:  CLRF   x54
2FD0:  MOVLW  09
2FD2:  MOVWF  x53
2FD4:  CLRF   x56
2FD6:  CLRF   x55
2FD8:  CLRF   x5C
2FDA:  CLRF   x5B
2FDC:  CLRF   x5A
2FDE:  CLRF   x59
2FE0:  MOVLW  FF
2FE2:  MOVWF  x5E
2FE4:  MOVWF  x5D
2FE6:  CLRF   x60
2FE8:  CLRF   x5F
2FEA:  MOVLW  3E
2FEC:  MOVWF  x57
2FEE:  MOVLW  1F
2FF0:  MOVWF  x58
2FF2:  CLRF   x61
2FF4:  CLRF   x63
2FF6:  MOVLW  11
2FF8:  MOVWF  x62
2FFA:  CLRF   x65
2FFC:  CLRF   x64
2FFE:  CLRF   x6B
3000:  CLRF   x6A
3002:  CLRF   x69
3004:  CLRF   x68
3006:  MOVLW  FF
3008:  MOVWF  x6D
300A:  MOVWF  x6C
300C:  CLRF   x6F
300E:  CLRF   x6E
3010:  MOVLW  5E
3012:  MOVWF  x66
3014:  MOVLW  20
3016:  MOVWF  x67
3018:  CLRF   1A
301A:  MOVLW  81
301C:  MOVWF  FD5
301E:  MOVLW  0B
3020:  MOVWF  FD7
3022:  MOVLW  DC
3024:  MOVWF  FD6
3026:  BCF    FF2.2
3028:  MOVLW  81
302A:  MOVWF  FD5
302C:  MOVLW  0B
302E:  MOVWF  FD7
3030:  MOVLW  DC
3032:  MOVWF  FD6
3034:  BCF    FF2.2
3036:  CLRF   1C
3038:  MOVLW  08
303A:  MOVWF  1B
303C:  BCF    FD8.0
303E:  RLCF   1A,W
3040:  MOVWF  00
3042:  MOVLB  0
3044:  CALL   025E
3048:  MOVWF  02
304A:  MOVLW  01
304C:  ADDWF  00,W
304E:  CALL   025E
3052:  MOVWF  03
3054:  MOVFF  03,FEA
3058:  MOVFF  02,FE9
305C:  MOVFF  FEF,02
3060:  INCF   FE9,F
3062:  MOVFF  FEF,00
3066:  MOVFF  FEC,01
306A:  INCF   FEC,F
306C:  MOVFF  FEF,03
3070:  BNZ   3076
3072:  INCF   FEC,F
3074:  MOVF   FED,F
3076:  MOVF   FEC,W
3078:  SUBWF  01,W
307A:  BNZ   3134
307C:  MOVF   00,W
307E:  SUBWF  03,W
3080:  BNZ   3134
3082:  MOVF   FED,F
3084:  MOVF   FED,F
3086:  CLRF   FEE
3088:  CLRF   FEE
308A:  BTFSC  02.7
308C:  BRA    3134
308E:  MOVF   FEC,F
3090:  MOVFF  FEC,FFA
3094:  MOVF   FED,F
3096:  MOVFF  FEF,FE8
309A:  MOVWF  FF9
309C:  MOVLB  0
309E:  BCF    FD8.0
30A0:  RLCF   1A,W
30A2:  MOVWF  00
30A4:  CALL   025E
30A8:  MOVWF  02
30AA:  MOVLW  01
30AC:  ADDWF  00,W
30AE:  CALL   025E
30B2:  MOVWF  03
30B4:  MOVFF  03,FEA
30B8:  MOVFF  02,FE9
30BC:  BTFSS  FF2.2
30BE:  BRA    30C2
30C0:  BSF    FEF.4
30C2:  MOVLW  07
30C4:  ADDWF  FE9,F
30C6:  MOVLW  00
30C8:  ADDWFC FEA,F
30CA:  MOVF   FD6,W
30CC:  MOVFF  FD7,03
30D0:  ADDLW  24
30D2:  MOVWF  01
30D4:  MOVLW  0B
30D6:  SUBWFB 03,W
30D8:  MOVWF  02
30DA:  MOVF   01,W
30DC:  ADDWF  FEF,F
30DE:  MOVF   02,W
30E0:  ADDWFC FEC,W
30E2:  MOVWF  FEF
30E4:  MOVLW  00
30E6:  ADDWFC FEC,W
30E8:  MOVWF  FEF
30EA:  MOVLW  00
30EC:  ADDWFC FEC,W
30EE:  MOVWF  FEF
30F0:  MOVF   FED,F
30F2:  MOVF   FED,F
30F4:  MOVF   FED,F
30F6:  MOVF   FEC,W
30F8:  MOVF   FEC,W
30FA:  MOVF   FEC,W
30FC:  MOVF   FEC,W
30FE:  MOVF   02,W
3100:  SUBWF  FEC,W
3102:  BNC   3118
3104:  BNZ   310E
3106:  MOVF   FED,F
3108:  MOVF   01,W
310A:  SUBWF  FEE,W
310C:  BNC   3118
310E:  MOVF   FED,F
3110:  MOVF   01,W
3112:  MOVWF  FEF
3114:  MOVF   02,W
3116:  MOVWF  FEC
3118:  MOVF   FEE,F
311A:  MOVF   FEC,W
311C:  SUBWF  02,W
311E:  BNC   3134
3120:  BNZ   312A
3122:  MOVF   FED,F
3124:  MOVF   01,W
3126:  SUBWF  FEE,W
3128:  BC    3134
312A:  MOVF   FED,F
312C:  MOVF   01,W
312E:  MOVWF  FEF
3130:  MOVF   02,W
3132:  MOVWF  FEC
3134:  INCF   1A,F
3136:  MOVLW  08
3138:  SUBWF  1A,W
313A:  BTFSC  FD8.2
313C:  BRA    3142
313E:  MOVLB  1
3140:  BRA    303C
3142:  CLRF   1A
3144:  MOVF   FD6,W
3146:  MOVFF  FD7,03
314A:  BTFSS  FF2.2
314C:  BRA    3152
314E:  MOVLB  1
3150:  BRA    302C
3152:  BRA    3144
3154:  MOVLW  FF
3156:  MOVWF  1A
....................    } 
....................    #else 
....................    while(1){ 
....................       if(_debug_usb()){ 
....................          test_comunicacion(); 
....................          test_reloj(); 
....................          //test_ADC(); 
....................          //test_memoria(); 
....................          //test_ccp(); 
....................          delay_ms(333); 
....................       }else{ 
....................          salida = (salida)? 0 : 1; 
....................          if(salida) output_bit(INDICADOR_RUN, 1); 
....................          else output_bit(INDICADOR_RUN, 0); 
....................          delay_ms(333); 
....................       } 
....................      } 
....................    #endif 
.................... } 
....................  
.................... /*======================= implementacion de tareas =======================*/ 
.................... #include "comunicacion.c" 
.................... //#include "Nucleo.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... #include <usb_cdc.h> 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... unsigned int indice = 0; 
.................... int COM_init(){ 
3158:  SLEEP 
.................... 	usb_detach();  
*
2298:  RCALL  1AFC
.................... 	usb_cdc_init(); 
229A:  CALL   0398
....................    usb_init_cs(); 
229E:  BRA    2292
....................    /*usb_task(); 
....................    if(usb_attached()){ 
....................       if(usb_enumerated()){ 
....................          return (USB_OK); 
....................       }else{ 
....................          return(USB_NO_ENUMERATED); 
....................       } 
....................    } 
....................    return (USB_NO_ATTACHED);*/ 
....................    return COM_sense(); 
22A0:  RCALL  1B5C
22A2:  MOVF   01,W
.................... } 
22A4:  GOTO   267E (RETURN)
....................  
.................... int8 COM_sense(){ 
....................    usb_task(); 
*
1B5C:  BRA    1B22
....................    if(usb_attached()){ 
1B5E:  BSF    F95.3
1B60:  BTFSS  F83.3
1B62:  BRA    1B78
....................       if(usb_enumerated()){ 
1B64:  BRA    1B54
1B66:  MOVF   01,F
1B68:  BZ    1B72
....................          return (USB_OK); 
1B6A:  MOVLW  01
1B6C:  MOVWF  01
1B6E:  BRA    1B7C
....................       }else{ 
1B70:  BRA    1B78
....................          return(USB_NO_ENUMERATED); 
1B72:  MOVLW  00
1B74:  MOVWF  01
1B76:  BRA    1B7C
....................       } 
....................    } 
....................    return(USB_NO_ATTACHED); 
1B78:  MOVLW  FF
1B7A:  MOVWF  01
.................... } 
1B7C:  RETLW  00
....................  
.................... //de aqui en adelante hay que quitar estas funciones que no se utilizan 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1){ 
....................    indice = 0; 
....................    if(!COM_READY) return(-1); 
....................    while(indice < leng){ 
....................       if(wait == 1) 
....................          usb_cdc_putc(buffer[indice]); 
....................       else 
....................          usb_cdc_putc_fast(buffer[indice]); 
....................       indice++; 
....................    } 
....................    return (indice); 
.................... } 
....................  
.................... int8 COM_recive(char* buffer, unsigned int8 leng){ 
....................    indice = 0; 
....................    if(!COM_READY) return (-1); 
....................    while(indice < leng){ 
....................       if(usb_cdc_kbhit()){ 
....................          buffer[indice] = usb_cdc_getc(); 
....................          indice++; 
....................       } 
....................    } 
....................    return(indice); 
.................... } 
....................  
.................... void COM_printf(char* message){ 
.................... 	printf(usb_cdc_putc,"%s\n\r",message); 
.................... } 
....................  
.................... #include "analogo_digital.c" 
.................... //#include "Nucleo.h" 
.................... //#include "analogo_digital.h" 
.................... #ifdef ANALOGO_DIGITAL_H 
....................  
.................... #define ADC_TAD_MUL_4      0x10 
.................... #define ADC_INPUT_PORT		0x2F 
....................  
.................... int AD_init_adc(){ 
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); // default 
.................... #endif 
.................... */	 
.................... 	output_a(0x00); 
*
23F2:  CLRF   F92
23F4:  CLRF   F89
.................... 	set_tris_a(ADC_INPUT_PORT);		//RA0 a RA4 entradas 
23F6:  MOVLW  2F
23F8:  MOVWF  F92
.................... 	setup_adc_ports(AN0_TO_AN4); 
23FA:  MOVF   FC1,W
23FC:  ANDLW  C0
23FE:  IORLW  0A
2400:  MOVWF  FC1
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_4|VSS_VDD);	 
2402:  BCF    FC0.0
2404:  BSF    FC0.1
2406:  BCF    FC0.2
2408:  BSF    FC0.7
240A:  BSF    FC2.0
.................... 	return (0); 
240C:  MOVLW  00
240E:  MOVWF  01
.................... } 
2410:  GOTO   2692 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
137C:  MOVLB  2
137E:  RLCF   x70,W
1380:  MOVWF  00
1382:  RLCF   00,F
1384:  MOVLW  FC
1386:  ANDWF  00,F
1388:  MOVF   FC2,W
138A:  ANDLW  C3
138C:  IORWF  00,W
138E:  MOVWF  FC2
.................... 	delay_us(10); 
1390:  MOVLW  0D
1392:  MOVWF  00
1394:  DECFSZ 00,F
1396:  BRA    1394
.................... 	read_adc(ADC_START_ONLY); 
1398:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
139A:  BCF    x73.0
139C:  BTFSS  FC2.1
139E:  BSF    x73.0
.................... 	}while(!done); 
13A0:  BTFSS  x73.0
13A2:  BRA    139A
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
13A4:  MOVFF  272,03
13A8:  MOVFF  271,FE9
13AC:  MOVFF  272,FEA
13B0:  BTFSC  FC2.1
13B2:  BRA    13B0
13B4:  MOVFF  FC3,FEF
13B8:  MOVFF  FC4,FEC
.................... 	delay_us(20); 
13BC:  MOVLW  1A
13BE:  MOVWF  00
13C0:  DECFSZ 00,F
13C2:  BRA    13C0
13C4:  NOP   
.................... 	return (0); 
13C6:  MOVLW  00
13C8:  MOVWF  01
.................... } 
13CA:  MOVLB  0
13CC:  RETLW  00
....................  
.................... #endif	//ANALOGO_DIGITAL_H 
....................  
.................... #include "ds1307.c" 
.................... //#include "Nucleo.h" 
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
....................  
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_seg = 0x00; 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
2472:  MOVLB  1
2474:  CLRF   xDC
....................  
....................   byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
2476:  BSF    F93.0
2478:  MOVLW  04
247A:  MOVWF  00
247C:  DECFSZ 00,F
247E:  BRA    247C
2480:  BSF    F93.1
2482:  MOVLW  04
2484:  MOVWF  00
2486:  DECFSZ 00,F
2488:  BRA    2486
248A:  BCF    F8A.0
248C:  BCF    F93.0
248E:  MOVLW  04
2490:  MOVWF  00
2492:  DECFSZ 00,F
2494:  BRA    2492
2496:  BCF    F8A.1
2498:  BCF    F93.1
....................   i2c_write(0xD0); 
249A:  MOVLW  D0
249C:  MOVWF  xF8
249E:  MOVLB  0
24A0:  CALL   109A
....................   i2c_write(0x00); 
24A4:  MOVLB  1
24A6:  CLRF   xF8
24A8:  MOVLB  0
24AA:  CALL   109A
....................   i2c_start(); 
24AE:  BSF    F93.0
24B0:  MOVLW  04
24B2:  MOVWF  00
24B4:  DECFSZ 00,F
24B6:  BRA    24B4
24B8:  BSF    F93.1
24BA:  MOVLW  04
24BC:  MOVWF  00
24BE:  DECFSZ 00,F
24C0:  BRA    24BE
24C2:  BTFSS  F81.1
24C4:  BRA    24C2
24C6:  BCF    F8A.0
24C8:  BCF    F93.0
24CA:  MOVLW  04
24CC:  MOVWF  00
24CE:  DECFSZ 00,F
24D0:  BRA    24CE
24D2:  BCF    F8A.1
24D4:  BCF    F93.1
....................   i2c_write(0xD1); 
24D6:  MOVLW  D1
24D8:  MOVLB  1
24DA:  MOVWF  xF8
24DC:  MOVLB  0
24DE:  CALL   109A
....................   seconds = ds1307_bcd2bin(i2c_read(0)); 
24E2:  CLRF   00
24E4:  CALL   1110
24E8:  MOVFF  01,1DD
24EC:  MOVFF  01,1F9
24F0:  CALL   117A
24F4:  MOVFF  01,1DC
....................   i2c_stop(); 
24F8:  BCF    F93.0
24FA:  NOP   
24FC:  BSF    F93.1
24FE:  BTFSS  F81.1
2500:  BRA    24FE
2502:  MOVLW  04
2504:  MOVWF  00
2506:  DECFSZ 00,F
2508:  BRA    2506
250A:  BRA    250C
250C:  NOP   
250E:  BSF    F93.0
2510:  MOVLW  04
2512:  MOVWF  00
2514:  DECFSZ 00,F
2516:  BRA    2514
....................   seconds &= 0x7F; 
2518:  MOVLB  1
251A:  BCF    xDC.7
....................  
....................   delay_us(3); 
251C:  MOVLW  03
251E:  MOVWF  00
2520:  DECFSZ 00,F
2522:  BRA    2520
2524:  BRA    2526
....................  
....................   i2c_start(); 
2526:  BSF    F93.0
2528:  MOVLW  04
252A:  MOVWF  00
252C:  DECFSZ 00,F
252E:  BRA    252C
2530:  BSF    F93.1
2532:  MOVLW  04
2534:  MOVWF  00
2536:  DECFSZ 00,F
2538:  BRA    2536
253A:  BCF    F8A.0
253C:  BCF    F93.0
253E:  MOVLW  04
2540:  MOVWF  00
2542:  DECFSZ 00,F
2544:  BRA    2542
2546:  BCF    F8A.1
2548:  BCF    F93.1
....................   i2c_write(0xD0); 
254A:  MOVLW  D0
254C:  MOVWF  xF8
254E:  MOVLB  0
2550:  CALL   109A
....................   i2c_write(0x00); 
2554:  MOVLB  1
2556:  CLRF   xF8
2558:  MOVLB  0
255A:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(seconds)); 
255E:  MOVFF  1DC,1E2
2562:  RCALL  244A
2564:  MOVFF  01,1DD
2568:  MOVFF  01,1F8
256C:  CALL   109A
....................   i2c_start(); 
2570:  BSF    F93.0
2572:  MOVLW  04
2574:  MOVWF  00
2576:  DECFSZ 00,F
2578:  BRA    2576
257A:  BSF    F93.1
257C:  MOVLW  04
257E:  MOVWF  00
2580:  DECFSZ 00,F
2582:  BRA    2580
2584:  BTFSS  F81.1
2586:  BRA    2584
2588:  BCF    F8A.0
258A:  BCF    F93.0
258C:  MOVLW  04
258E:  MOVWF  00
2590:  DECFSZ 00,F
2592:  BRA    2590
2594:  BCF    F8A.1
2596:  BCF    F93.1
....................   i2c_write(0xD0); 
2598:  MOVLW  D0
259A:  MOVLB  1
259C:  MOVWF  xF8
259E:  MOVLB  0
25A0:  CALL   109A
....................   i2c_write(0x07); 
25A4:  MOVLW  07
25A6:  MOVLB  1
25A8:  MOVWF  xF8
25AA:  MOVLB  0
25AC:  CALL   109A
....................   i2c_write(val); 
25B0:  MOVFF  1DB,1F8
25B4:  CALL   109A
....................   i2c_stop(); 
25B8:  BCF    F93.0
25BA:  NOP   
25BC:  BSF    F93.1
25BE:  BTFSS  F81.1
25C0:  BRA    25BE
25C2:  MOVLW  04
25C4:  MOVWF  00
25C6:  DECFSZ 00,F
25C8:  BRA    25C6
25CA:  BRA    25CC
25CC:  NOP   
25CE:  BSF    F93.0
25D0:  MOVLW  04
25D2:  MOVWF  00
25D4:  DECFSZ 00,F
25D6:  BRA    25D4
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
25D8:  GOTO   26A6 (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
*
27B4:  MOVLB  1
27B6:  BCF    xE1.7
....................   hr &= 0x3F; 
27B8:  MOVLW  3F
27BA:  ANDWF  xDF,F
....................  
....................   i2c_start(); 
27BC:  BSF    F93.0
27BE:  MOVLW  04
27C0:  MOVWF  00
27C2:  DECFSZ 00,F
27C4:  BRA    27C2
27C6:  BSF    F93.1
27C8:  MOVLW  04
27CA:  MOVWF  00
27CC:  DECFSZ 00,F
27CE:  BRA    27CC
27D0:  BCF    F8A.0
27D2:  BCF    F93.0
27D4:  MOVLW  04
27D6:  MOVWF  00
27D8:  DECFSZ 00,F
27DA:  BRA    27D8
27DC:  BCF    F8A.1
27DE:  BCF    F93.1
....................   i2c_write(0xD0); 
27E0:  MOVLW  D0
27E2:  MOVWF  xF8
27E4:  MOVLB  0
27E6:  CALL   109A
....................   i2c_write(0x00); 
27EA:  MOVLB  1
27EC:  CLRF   xF8
27EE:  MOVLB  0
27F0:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(sec)); 
27F4:  MOVFF  1E1,1E2
27F8:  RCALL  244A
27FA:  MOVFF  01,1E2
27FE:  MOVFF  01,1F8
2802:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(min)); 
2806:  MOVFF  1E0,1E2
280A:  RCALL  244A
280C:  MOVFF  01,1E2
2810:  MOVFF  01,1F8
2814:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(hr)); 
2818:  MOVFF  1DF,1E2
281C:  RCALL  244A
281E:  MOVFF  01,1E2
2822:  MOVFF  01,1F8
2826:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(dow)); 
282A:  MOVFF  1DE,1E2
282E:  RCALL  244A
2830:  MOVFF  01,1E2
2834:  MOVFF  01,1F8
2838:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(day)); 
283C:  MOVFF  1DB,1E2
2840:  RCALL  244A
2842:  MOVFF  01,1E2
2846:  MOVFF  01,1F8
284A:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(mth)); 
284E:  MOVFF  1DC,1E2
2852:  RCALL  244A
2854:  MOVFF  01,1E2
2858:  MOVFF  01,1F8
285C:  CALL   109A
....................   i2c_write(ds1307_bin2bcd(year)); 
2860:  MOVFF  1DD,1E2
2864:  RCALL  244A
2866:  MOVFF  01,1E2
286A:  MOVFF  01,1F8
286E:  CALL   109A
....................   i2c_stop(); 
2872:  BCF    F93.0
2874:  NOP   
2876:  BSF    F93.1
2878:  BTFSS  F81.1
287A:  BRA    2878
287C:  MOVLW  04
287E:  MOVWF  00
2880:  DECFSZ 00,F
2882:  BRA    2880
2884:  BRA    2886
2886:  NOP   
2888:  BSF    F93.0
288A:  MOVLW  04
288C:  MOVWF  00
288E:  DECFSZ 00,F
2890:  BRA    288E
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
2892:  GOTO   29B2 (RETURN)
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
11A4:  BSF    F93.0
11A6:  MOVLW  04
11A8:  MOVWF  00
11AA:  DECFSZ 00,F
11AC:  BRA    11AA
11AE:  BSF    F93.1
11B0:  MOVLW  04
11B2:  MOVWF  00
11B4:  DECFSZ 00,F
11B6:  BRA    11B4
11B8:  BCF    F8A.0
11BA:  BCF    F93.0
11BC:  MOVLW  04
11BE:  MOVWF  00
11C0:  DECFSZ 00,F
11C2:  BRA    11C0
11C4:  BCF    F8A.1
11C6:  BCF    F93.1
*
29C8:  BSF    F93.0
29CA:  MOVLW  04
29CC:  MOVWF  00
29CE:  DECFSZ 00,F
29D0:  BRA    29CE
29D2:  BSF    F93.1
29D4:  MOVLW  04
29D6:  MOVWF  00
29D8:  DECFSZ 00,F
29DA:  BRA    29D8
29DC:  BCF    F8A.0
29DE:  BCF    F93.0
29E0:  MOVLW  04
29E2:  MOVWF  00
29E4:  DECFSZ 00,F
29E6:  BRA    29E4
29E8:  BCF    F8A.1
29EA:  BCF    F93.1
....................   i2c_write(0xD0); 
*
11C8:  MOVLW  D0
11CA:  MOVLB  1
11CC:  MOVWF  xF8
11CE:  MOVLB  0
11D0:  RCALL  109A
*
29EC:  MOVLW  D0
29EE:  MOVLB  1
29F0:  MOVWF  xF8
29F2:  MOVLB  0
29F4:  CALL   109A
....................   i2c_write(0x03); 
*
11D2:  MOVLW  03
11D4:  MOVLB  1
11D6:  MOVWF  xF8
11D8:  MOVLB  0
11DA:  RCALL  109A
*
29F8:  MOVLW  03
29FA:  MOVLB  1
29FC:  MOVWF  xF8
29FE:  MOVLB  0
2A00:  CALL   109A
....................   i2c_start(); 
*
11DC:  BSF    F93.0
11DE:  MOVLW  04
11E0:  MOVWF  00
11E2:  DECFSZ 00,F
11E4:  BRA    11E2
11E6:  BSF    F93.1
11E8:  MOVLW  04
11EA:  MOVWF  00
11EC:  DECFSZ 00,F
11EE:  BRA    11EC
11F0:  BTFSS  F81.1
11F2:  BRA    11F0
11F4:  BCF    F8A.0
11F6:  BCF    F93.0
11F8:  MOVLW  04
11FA:  MOVWF  00
11FC:  DECFSZ 00,F
11FE:  BRA    11FC
1200:  BCF    F8A.1
1202:  BCF    F93.1
*
2A04:  BSF    F93.0
2A06:  MOVLW  04
2A08:  MOVWF  00
2A0A:  DECFSZ 00,F
2A0C:  BRA    2A0A
2A0E:  BSF    F93.1
2A10:  MOVLW  04
2A12:  MOVWF  00
2A14:  DECFSZ 00,F
2A16:  BRA    2A14
2A18:  BTFSS  F81.1
2A1A:  BRA    2A18
2A1C:  BCF    F8A.0
2A1E:  BCF    F93.0
2A20:  MOVLW  04
2A22:  MOVWF  00
2A24:  DECFSZ 00,F
2A26:  BRA    2A24
2A28:  BCF    F8A.1
2A2A:  BCF    F93.1
....................   i2c_write(0xD1); 
*
1204:  MOVLW  D1
1206:  MOVLB  1
1208:  MOVWF  xF8
120A:  MOVLB  0
120C:  RCALL  109A
*
2A2C:  MOVLW  D1
2A2E:  MOVLB  1
2A30:  MOVWF  xF8
2A32:  MOVLB  0
2A34:  CALL   109A
....................   dow = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
120E:  MOVLW  01
1210:  MOVWF  00
1212:  RCALL  1110
1214:  MOVF   01,W
1216:  ANDLW  7F
1218:  MOVLB  1
121A:  MOVWF  xF4
121C:  MOVWF  xF9
121E:  MOVLB  0
1220:  RCALL  117A
1222:  MOVFF  01,8A
*
2A38:  MOVLW  01
2A3A:  MOVWF  00
2A3C:  CALL   1110
2A40:  MOVF   01,W
2A42:  ANDLW  7F
2A44:  MOVLB  1
2A46:  MOVWF  xF4
2A48:  MOVWF  xF9
2A4A:  MOVLB  0
2A4C:  CALL   117A
2A50:  MOVFF  01,EF
....................   day = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
1226:  MOVLW  01
1228:  MOVWF  00
122A:  RCALL  1110
122C:  MOVF   01,W
122E:  ANDLW  3F
1230:  MOVLB  1
1232:  MOVWF  xF4
1234:  MOVWF  xF9
1236:  MOVLB  0
1238:  RCALL  117A
123A:  MOVFF  01,8B
*
2A54:  MOVLW  01
2A56:  MOVWF  00
2A58:  CALL   1110
2A5C:  MOVF   01,W
2A5E:  ANDLW  3F
2A60:  MOVLB  1
2A62:  MOVWF  xF4
2A64:  MOVWF  xF9
2A66:  MOVLB  0
2A68:  CALL   117A
2A6C:  MOVFF  01,E8
....................   mth = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
123E:  MOVLW  01
1240:  MOVWF  00
1242:  RCALL  1110
1244:  MOVF   01,W
1246:  ANDLW  1F
1248:  MOVLB  1
124A:  MOVWF  xF4
124C:  MOVWF  xF9
124E:  MOVLB  0
1250:  RCALL  117A
1252:  MOVFF  01,8C
*
2A70:  MOVLW  01
2A72:  MOVWF  00
2A74:  CALL   1110
2A78:  MOVF   01,W
2A7A:  ANDLW  1F
2A7C:  MOVLB  1
2A7E:  MOVWF  xF4
2A80:  MOVWF  xF9
2A82:  MOVLB  0
2A84:  CALL   117A
2A88:  MOVFF  01,E9
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
1256:  CLRF   00
1258:  RCALL  1110
125A:  MOVFF  01,1F4
125E:  MOVFF  01,1F9
1262:  RCALL  117A
1264:  MOVFF  01,8D
*
2A8C:  CLRF   00
2A8E:  CALL   1110
2A92:  MOVFF  01,1F4
2A96:  MOVFF  01,1F9
2A9A:  CALL   117A
2A9E:  MOVFF  01,EA
....................   i2c_stop(); 
*
1268:  BCF    F93.0
126A:  NOP   
126C:  BSF    F93.1
126E:  BTFSS  F81.1
1270:  BRA    126E
1272:  MOVLW  04
1274:  MOVWF  00
1276:  DECFSZ 00,F
1278:  BRA    1276
127A:  BRA    127C
127C:  NOP   
127E:  BSF    F93.0
1280:  MOVLW  04
1282:  MOVWF  00
1284:  DECFSZ 00,F
1286:  BRA    1284
*
2AA2:  BCF    F93.0
2AA4:  NOP   
2AA6:  BSF    F93.1
2AA8:  BTFSS  F81.1
2AAA:  BRA    2AA8
2AAC:  MOVLW  04
2AAE:  MOVWF  00
2AB0:  DECFSZ 00,F
2AB2:  BRA    2AB0
2AB4:  BRA    2AB6
2AB6:  NOP   
2AB8:  BSF    F93.0
2ABA:  MOVLW  04
2ABC:  MOVWF  00
2ABE:  DECFSZ 00,F
2AC0:  BRA    2ABE
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
1288:  BSF    F93.0
128A:  MOVLW  04
128C:  MOVWF  00
128E:  DECFSZ 00,F
1290:  BRA    128E
1292:  BSF    F93.1
1294:  MOVLW  04
1296:  MOVWF  00
1298:  DECFSZ 00,F
129A:  BRA    1298
129C:  BCF    F8A.0
129E:  BCF    F93.0
12A0:  MOVLW  04
12A2:  MOVWF  00
12A4:  DECFSZ 00,F
12A6:  BRA    12A4
12A8:  BCF    F8A.1
12AA:  BCF    F93.1
*
2AC2:  BSF    F93.0
2AC4:  MOVLW  04
2AC6:  MOVWF  00
2AC8:  DECFSZ 00,F
2ACA:  BRA    2AC8
2ACC:  BSF    F93.1
2ACE:  MOVLW  04
2AD0:  MOVWF  00
2AD2:  DECFSZ 00,F
2AD4:  BRA    2AD2
2AD6:  BCF    F8A.0
2AD8:  BCF    F93.0
2ADA:  MOVLW  04
2ADC:  MOVWF  00
2ADE:  DECFSZ 00,F
2AE0:  BRA    2ADE
2AE2:  BCF    F8A.1
2AE4:  BCF    F93.1
....................   i2c_write(0xD0); 
*
12AC:  MOVLW  D0
12AE:  MOVLB  1
12B0:  MOVWF  xF8
12B2:  MOVLB  0
12B4:  RCALL  109A
*
2AE6:  MOVLW  D0
2AE8:  MOVLB  1
2AEA:  MOVWF  xF8
2AEC:  MOVLB  0
2AEE:  CALL   109A
....................   i2c_write(0x00); 
*
12B6:  MOVLB  1
12B8:  CLRF   xF8
12BA:  MOVLB  0
12BC:  RCALL  109A
*
2AF2:  MOVLB  1
2AF4:  CLRF   xF8
2AF6:  MOVLB  0
2AF8:  CALL   109A
....................   i2c_start(); 
*
12BE:  BSF    F93.0
12C0:  MOVLW  04
12C2:  MOVWF  00
12C4:  DECFSZ 00,F
12C6:  BRA    12C4
12C8:  BSF    F93.1
12CA:  MOVLW  04
12CC:  MOVWF  00
12CE:  DECFSZ 00,F
12D0:  BRA    12CE
12D2:  BTFSS  F81.1
12D4:  BRA    12D2
12D6:  BCF    F8A.0
12D8:  BCF    F93.0
12DA:  MOVLW  04
12DC:  MOVWF  00
12DE:  DECFSZ 00,F
12E0:  BRA    12DE
12E2:  BCF    F8A.1
12E4:  BCF    F93.1
*
2AFC:  BSF    F93.0
2AFE:  MOVLW  04
2B00:  MOVWF  00
2B02:  DECFSZ 00,F
2B04:  BRA    2B02
2B06:  BSF    F93.1
2B08:  MOVLW  04
2B0A:  MOVWF  00
2B0C:  DECFSZ 00,F
2B0E:  BRA    2B0C
2B10:  BTFSS  F81.1
2B12:  BRA    2B10
2B14:  BCF    F8A.0
2B16:  BCF    F93.0
2B18:  MOVLW  04
2B1A:  MOVWF  00
2B1C:  DECFSZ 00,F
2B1E:  BRA    2B1C
2B20:  BCF    F8A.1
2B22:  BCF    F93.1
....................   i2c_write(0xD1); 
*
12E6:  MOVLW  D1
12E8:  MOVLB  1
12EA:  MOVWF  xF8
12EC:  MOVLB  0
12EE:  RCALL  109A
*
2B24:  MOVLW  D1
2B26:  MOVLB  1
2B28:  MOVWF  xF8
2B2A:  MOVLB  0
2B2C:  CALL   109A
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
12F0:  MOVLW  01
12F2:  MOVWF  00
12F4:  RCALL  1110
12F6:  MOVF   01,W
12F8:  ANDLW  7F
12FA:  MOVLB  1
12FC:  MOVWF  xF4
12FE:  MOVWF  xF9
1300:  MOVLB  0
1302:  RCALL  117A
1304:  MOVFF  01,90
*
2B30:  MOVLW  01
2B32:  MOVWF  00
2B34:  CALL   1110
2B38:  MOVF   01,W
2B3A:  ANDLW  7F
2B3C:  MOVLB  1
2B3E:  MOVWF  xF4
2B40:  MOVWF  xF9
2B42:  MOVLB  0
2B44:  CALL   117A
2B48:  MOVFF  01,ED
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1308:  MOVLW  01
130A:  MOVWF  00
130C:  RCALL  1110
130E:  MOVF   01,W
1310:  ANDLW  7F
1312:  MOVLB  1
1314:  MOVWF  xF4
1316:  MOVWF  xF9
1318:  MOVLB  0
131A:  RCALL  117A
131C:  MOVFF  01,8F
*
2B4C:  MOVLW  01
2B4E:  MOVWF  00
2B50:  CALL   1110
2B54:  MOVF   01,W
2B56:  ANDLW  7F
2B58:  MOVLB  1
2B5A:  MOVWF  xF4
2B5C:  MOVWF  xF9
2B5E:  MOVLB  0
2B60:  CALL   117A
2B64:  MOVFF  01,EC
....................   hr = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
1320:  CLRF   00
1322:  RCALL  1110
1324:  MOVF   01,W
1326:  ANDLW  3F
1328:  MOVLB  1
132A:  MOVWF  xF4
132C:  MOVWF  xF9
132E:  MOVLB  0
1330:  RCALL  117A
1332:  MOVFF  01,8E
*
2B68:  CLRF   00
2B6A:  CALL   1110
2B6E:  MOVF   01,W
2B70:  ANDLW  3F
2B72:  MOVLB  1
2B74:  MOVWF  xF4
2B76:  MOVWF  xF9
2B78:  MOVLB  0
2B7A:  CALL   117A
2B7E:  MOVFF  01,EB
....................   i2c_stop(); 
*
1336:  BCF    F93.0
1338:  NOP   
133A:  BSF    F93.1
133C:  BTFSS  F81.1
133E:  BRA    133C
1340:  MOVLW  04
1342:  MOVWF  00
1344:  DECFSZ 00,F
1346:  BRA    1344
1348:  BRA    134A
134A:  NOP   
134C:  BSF    F93.0
134E:  MOVLW  04
1350:  MOVWF  00
1352:  DECFSZ 00,F
1354:  BRA    1352
*
2B82:  BCF    F93.0
2B84:  NOP   
2B86:  BSF    F93.1
2B88:  BTFSS  F81.1
2B8A:  BRA    2B88
2B8C:  MOVLW  04
2B8E:  MOVWF  00
2B90:  DECFSZ 00,F
2B92:  BRA    2B90
2B94:  BRA    2B96
2B96:  NOP   
2B98:  BSF    F93.0
2B9A:  MOVLW  04
2B9C:  MOVWF  00
2B9E:  DECFSZ 00,F
2BA0:  BRA    2B9E
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................   char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
25DC:  BSF    F93.0
25DE:  MOVLW  04
25E0:  MOVWF  00
25E2:  DECFSZ 00,F
25E4:  BRA    25E2
25E6:  BSF    F93.1
25E8:  MOVLW  04
25EA:  MOVWF  00
25EC:  DECFSZ 00,F
25EE:  BRA    25EC
25F0:  BCF    F8A.0
25F2:  BCF    F93.0
25F4:  MOVLW  04
25F6:  MOVWF  00
25F8:  DECFSZ 00,F
25FA:  BRA    25F8
25FC:  BCF    F8A.1
25FE:  BCF    F93.1
....................   i2c_write(0xD0); 
2600:  MOVLW  D0
2602:  MOVLB  1
2604:  MOVWF  xF8
2606:  MOVLB  0
2608:  CALL   109A
....................   i2c_write(addr); 
260C:  MOVFF  1DB,1F8
2610:  CALL   109A
....................  
....................   i2c_start(); 
2614:  BSF    F93.0
2616:  MOVLW  04
2618:  MOVWF  00
261A:  DECFSZ 00,F
261C:  BRA    261A
261E:  BSF    F93.1
2620:  MOVLW  04
2622:  MOVWF  00
2624:  DECFSZ 00,F
2626:  BRA    2624
2628:  BTFSS  F81.1
262A:  BRA    2628
262C:  BCF    F8A.0
262E:  BCF    F93.0
2630:  MOVLW  04
2632:  MOVWF  00
2634:  DECFSZ 00,F
2636:  BRA    2634
2638:  BCF    F8A.1
263A:  BCF    F93.1
....................   i2c_write(0xD1); 
263C:  MOVLW  D1
263E:  MOVLB  1
2640:  MOVWF  xF8
2642:  MOVLB  0
2644:  CALL   109A
....................   retval = i2c_read(0); 
2648:  CLRF   00
264A:  CALL   1110
264E:  MOVFF  01,1DC
....................   i2c_stop(); 
2652:  BCF    F93.0
2654:  NOP   
2656:  BSF    F93.1
2658:  BTFSS  F81.1
265A:  BRA    2658
265C:  MOVLW  04
265E:  MOVWF  00
2660:  DECFSZ 00,F
2662:  BRA    2660
2664:  BRA    2666
2666:  NOP   
2668:  BSF    F93.0
266A:  MOVLW  04
266C:  MOVWF  00
266E:  DECFSZ 00,F
2670:  BRA    266E
....................  
.................... return(retval); 
2672:  MOVLB  1
2674:  MOVFF  1DC,01
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
2678:  MOVLB  0
267A:  RETLW  00
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
2896:  BSF    F93.0
2898:  MOVLW  04
289A:  MOVWF  00
289C:  DECFSZ 00,F
289E:  BRA    289C
28A0:  BSF    F93.1
28A2:  MOVLW  04
28A4:  MOVWF  00
28A6:  DECFSZ 00,F
28A8:  BRA    28A6
28AA:  BCF    F8A.0
28AC:  BCF    F93.0
28AE:  MOVLW  04
28B0:  MOVWF  00
28B2:  DECFSZ 00,F
28B4:  BRA    28B2
28B6:  BCF    F8A.1
28B8:  BCF    F93.1
....................   i2c_write(0xD0); 
28BA:  MOVLW  D0
28BC:  MOVLB  1
28BE:  MOVWF  xF8
28C0:  MOVLB  0
28C2:  CALL   109A
....................   i2c_write(addr); 
28C6:  MOVFF  1DB,1F8
28CA:  CALL   109A
....................   i2c_write(value); 
28CE:  MOVFF  1DC,1F8
28D2:  CALL   109A
....................   i2c_stop(); 
28D6:  BCF    F93.0
28D8:  NOP   
28DA:  BSF    F93.1
28DC:  BTFSS  F81.1
28DE:  BRA    28DC
28E0:  MOVLW  04
28E2:  MOVWF  00
28E4:  DECFSZ 00,F
28E6:  BRA    28E4
28E8:  BRA    28EA
28EA:  NOP   
28EC:  BSF    F93.0
28EE:  MOVLW  04
28F0:  MOVWF  00
28F2:  DECFSZ 00,F
28F4:  BRA    28F2
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
28F6:  RETLW  00
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................   byte lday; 
....................   byte lmonth; 
....................   byte lyr; 
....................   byte ldow; 
....................   ds1307_get_date(lday,lmonth,lyr,ldow); 
....................   sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
244A:  MOVFF  1E2,1E3
....................   retval = 0; 
244E:  MOVLB  1
2450:  CLRF   xE4
....................   while(1){ 
....................     if(temp >= 10){ 
2452:  MOVF   xE3,W
2454:  SUBLW  09
2456:  BC    2462
....................       temp -= 10; 
2458:  MOVLW  0A
245A:  SUBWF  xE3,F
....................       retval += 0x10; 
245C:  MOVLW  10
245E:  ADDWF  xE4,F
....................     }else{ 
2460:  BRA    2468
....................       retval += temp; 
2462:  MOVF   xE3,W
2464:  ADDWF  xE4,F
....................       break; 
2466:  BRA    246A
....................     } 
....................   } 
2468:  BRA    2452
....................   return(retval); 
246A:  MOVFF  1E4,01
.................... } 
246E:  MOVLB  0
2470:  RETLW  00
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
117A:  MOVFF  1F9,1FA
....................   temp >>= 1; 
117E:  BCF    FD8.0
1180:  MOVLB  1
1182:  RRCF   xFA,F
....................   temp &= 0x78; 
1184:  MOVLW  78
1186:  ANDWF  xFA,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
1188:  RRCF   xFA,W
118A:  MOVWF  00
118C:  RRCF   00,F
118E:  MOVLW  3F
1190:  ANDWF  00,F
1192:  MOVF   00,W
1194:  ADDWF  xFA,W
1196:  MOVWF  xFB
1198:  MOVF   xF9,W
119A:  ANDLW  0F
119C:  ADDWF  xFB,W
119E:  MOVWF  01
.................... } 
11A0:  MOVLB  0
11A2:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
.................... /* 
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x03); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
....................   year = ds1307_bcd2bin(i2c_read(0)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
....................   temp >>= 1; 
....................   temp &= 0x78; 
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... } 
.................... */ 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "captura_frecuencia.c" 
.................... #ifdef CAPTURA_FRECUENCIA_H 
.................... //#include "captura_frecuencia.h" 
.................... /* 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #endif 
.................... */ 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
20FE:  INCF   x95,F
.................... } 
....................  
2100:  BCF    FA1.1
2102:  GOTO   0084
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
2106:  MOVF   x94,W
2108:  SUBLW  FF
210A:  BNZ   211C
....................    	setup_ccp1(CCP_CAPTURE_FE); 
210C:  BSF    F94.2
210E:  CLRF   FBD
2110:  MOVLW  04
2112:  MOVWF  FBD
2114:  CLRF   FB7
2116:  CLRF   FB6
....................    	Q_CCP = 0; 
2118:  CLRF   x94
....................    }else if(Q_CCP == 0){ 
211A:  BRA    21A4
211C:  MOVF   x94,F
211E:  BNZ   2158
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
2120:  CLRF   01
2122:  MOVFF  95,2AC
2126:  MOVLB  2
2128:  CLRF   xAA
212A:  CLRF   xAB
212C:  MOVF   FBE,W
212E:  ADDWF  xAA,W
2130:  MOVLB  0
2132:  MOVWF  x9A
2134:  MOVF   FBF,W
2136:  MOVLB  2
2138:  ADDWFC xAB,W
213A:  MOVLB  0
213C:  MOVWF  x9B
213E:  MOVLW  00
2140:  MOVLB  2
2142:  ADDWFC xAC,W
2144:  MOVLB  0
2146:  MOVWF  x9C
2148:  MOVLW  00
214A:  MOVLB  2
214C:  ADDWFC 01,W
214E:  MOVLB  0
2150:  MOVWF  x9D
....................    	Q_CCP = 1; 
2152:  MOVLW  01
2154:  MOVWF  x94
....................    }else if(Q_CCP == 1){ 
2156:  BRA    21A4
2158:  DECFSZ x94,W
215A:  BRA    21A4
....................    	disable_interrupts(INT_CCP1); 
215C:  BCF    F9D.2
....................    	tiempo_inicial = tiempo_final; 
215E:  MOVFF  9D,99
2162:  MOVFF  9C,98
2166:  MOVFF  9B,97
216A:  MOVFF  9A,96
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
216E:  CLRF   01
2170:  MOVFF  95,2AC
2174:  MOVLB  2
2176:  CLRF   xAA
2178:  CLRF   xAB
217A:  MOVF   FBE,W
217C:  ADDWF  xAA,W
217E:  MOVLB  0
2180:  MOVWF  x9A
2182:  MOVF   FBF,W
2184:  MOVLB  2
2186:  ADDWFC xAB,W
2188:  MOVLB  0
218A:  MOVWF  x9B
218C:  MOVLW  00
218E:  MOVLB  2
2190:  ADDWFC xAC,W
2192:  MOVLB  0
2194:  MOVWF  x9C
2196:  MOVLW  00
2198:  MOVLB  2
219A:  ADDWFC 01,W
219C:  MOVLB  0
219E:  MOVWF  x9D
....................    	Q_CCP = 2; 
21A0:  MOVLW  02
21A2:  MOVWF  x94
....................    } 
.................... } 
....................  
21A4:  BCF    F9E.2
21A6:  GOTO   0084
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
21AA:  MOVF   x94,W
21AC:  SUBLW  FF
21AE:  BNZ   21C0
....................    	setup_ccp1(CCP_CAPTURE_FE); 
21B0:  BSF    F94.2
21B2:  CLRF   FBD
21B4:  MOVLW  04
21B6:  MOVWF  FBD
21B8:  CLRF   FB7
21BA:  CLRF   FB6
....................    	Q_CCP = 0; 
21BC:  CLRF   x94
....................    }else if(Q_CCP == 0){ 
21BE:  BRA    2248
21C0:  MOVF   x94,F
21C2:  BNZ   21FC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
21C4:  CLRF   01
21C6:  MOVFF  95,2AC
21CA:  MOVLB  2
21CC:  CLRF   xAA
21CE:  CLRF   xAB
21D0:  MOVF   FBB,W
21D2:  ADDWF  xAA,W
21D4:  MOVLB  0
21D6:  MOVWF  x9A
21D8:  MOVF   FBC,W
21DA:  MOVLB  2
21DC:  ADDWFC xAB,W
21DE:  MOVLB  0
21E0:  MOVWF  x9B
21E2:  MOVLW  00
21E4:  MOVLB  2
21E6:  ADDWFC xAC,W
21E8:  MOVLB  0
21EA:  MOVWF  x9C
21EC:  MOVLW  00
21EE:  MOVLB  2
21F0:  ADDWFC 01,W
21F2:  MOVLB  0
21F4:  MOVWF  x9D
....................    	Q_CCP = 1; 
21F6:  MOVLW  01
21F8:  MOVWF  x94
....................    }else if(Q_CCP == 1){ 
21FA:  BRA    2248
21FC:  DECFSZ x94,W
21FE:  BRA    2248
....................    	disable_interrupts(INT_CCP2); 
2200:  BCF    FA0.0
....................    	tiempo_inicial = tiempo_final; 
2202:  MOVFF  9D,99
2206:  MOVFF  9C,98
220A:  MOVFF  9B,97
220E:  MOVFF  9A,96
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
2212:  CLRF   01
2214:  MOVFF  95,2AC
2218:  MOVLB  2
221A:  CLRF   xAA
221C:  CLRF   xAB
221E:  MOVF   FBB,W
2220:  ADDWF  xAA,W
2222:  MOVLB  0
2224:  MOVWF  x9A
2226:  MOVF   FBC,W
2228:  MOVLB  2
222A:  ADDWFC xAB,W
222C:  MOVLB  0
222E:  MOVWF  x9B
2230:  MOVLW  00
2232:  MOVLB  2
2234:  ADDWFC xAC,W
2236:  MOVLB  0
2238:  MOVWF  x9C
223A:  MOVLW  00
223C:  MOVLB  2
223E:  ADDWFC 01,W
2240:  MOVLB  0
2242:  MOVWF  x9D
....................    	Q_CCP = 2; 
2244:  MOVLW  02
2246:  MOVWF  x94
....................    } 
.................... } 
....................  
2248:  BCF    FA1.0
224A:  GOTO   0084
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
*
2414:  MOVFF  91,FB1
....................    T3CON.TMR3ON = 0; 
2418:  BCF    FB1.0
....................    set_timer3(0); 
241A:  CLRF   FB3
241C:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
241E:  MOVF   x92,W
2420:  ANDLW  08
2422:  BTFSC  FD8.2
2424:  BCF    F82.2
2426:  CLRF   FBD
2428:  MOVFF  92,FBD
242C:  CLRF   FB7
242E:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
2430:  MOVF   x93,W
2432:  ANDLW  08
2434:  BTFSC  FD8.2
2436:  BCF    F82.1
2438:  CLRF   FBA
243A:  MOVFF  93,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1;                        
243E:  BSF    F94.2
2440:  BSF    F94.1
....................    return 0; 
2442:  MOVLW  00
2444:  MOVWF  01
.................... } 
2446:  GOTO   2698 (RETURN)
....................  
.................... void CP_activar_captura(int canal){ 
.................... 	//CODIGO DE MANEJO DE CCP 
.................... 	semaforo_ccp = 1; 
*
1FAC:  MOVLW  01
1FAE:  MOVWF  x9E
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
1FB0:  MOVLW  C0
1FB2:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
1FB4:  BSF    FA0.1
....................    tiempo_inicial = tiempo_final = 0; 
1FB6:  CLRF   x9D
1FB8:  CLRF   x9C
1FBA:  CLRF   x9B
1FBC:  CLRF   x9A
1FBE:  MOVFF  9D,99
1FC2:  MOVFF  9C,98
1FC6:  MOVFF  9B,97
1FCA:  MOVFF  9A,96
....................    set_timer3(0);      						//se reset timer  a 0 
1FCE:  CLRF   FB3
1FD0:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
1FD2:  BSF    FB1.0
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
1FD4:  MOVLB  2
1FD6:  DECFSZ x8D,W
1FD8:  BRA    1FDE
1FDA:  BSF    F9D.2
1FDC:  BRA    1FE0
1FDE:  BSF    FA0.0
.................... } 
1FE0:  MOVLB  0
1FE2:  GOTO   20C2 (RETURN)
....................  
.................... void CP_desativar_captura(){ 
.................... 	disable_interrupts(INT_CCP1); 
*
2014:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
2016:  BCF    FA0.0
....................    disable_interrupts(INT_TIMER3); 
2018:  BCF    FA0.1
....................    //disable_interrupts(GLOBAL); 
....................    setup_ccp2(MODO_CCP1); 
201A:  MOVF   x92,W
201C:  ANDLW  08
201E:  BTFSC  FD8.2
2020:  BCF    F82.1
2022:  CLRF   FBA
2024:  MOVFF  92,FBA
....................    setup_ccp2(MODO_CCP2); 
2028:  MOVF   x93,W
202A:  ANDLW  08
202C:  BTFSC  FD8.2
202E:  BCF    F82.1
2030:  CLRF   FBA
2032:  MOVFF  93,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
2036:  MOVLW  FF
2038:  MOVWF  x94
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
203A:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
203C:  CLRF   x95
....................    semaforo_ccp = 0; 
203E:  CLRF   x9E
.................... } 
2040:  GOTO   20DE (RETURN)
....................  
.................... int CP_ocupado(){ return (semaforo_ccp != 0);} 
*
1F82:  MOVF   x9E,F
1F84:  BNZ   1F8A
1F86:  MOVLW  00
1F88:  BRA    1F8C
1F8A:  MOVLW  01
1F8C:  MOVWF  01
1F8E:  GOTO   207E (RETURN)
.................... int CP_done(){ return (Q_CCP == 2);} 
*
1FE6:  MOVF   x94,W
1FE8:  SUBLW  02
1FEA:  BZ    1FF0
1FEC:  MOVLW  00
1FEE:  BRA    1FF2
1FF0:  MOVLW  01
1FF2:  MOVWF  01
1FF4:  GOTO   20C4 (RETURN)
....................  
.................... int32 CP_obtener_resultado(){ 
.................... 	return (tiempo_final - tiempo_inicial); 
1FF8:  MOVF   x96,W
1FFA:  SUBWF  x9A,W
1FFC:  MOVWF  00
1FFE:  MOVF   x97,W
2000:  SUBWFB x9B,W
2002:  MOVWF  01
2004:  MOVF   x98,W
2006:  SUBWFB x9C,W
2008:  MOVWF  02
200A:  MOVF   x99,W
200C:  SUBWFB x9D,W
200E:  MOVWF  03
.................... } 
2010:  GOTO   20CC (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    set_timer3(0);      					//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
....................    //while(Q_CCP != 2){;}              //espera a que se carguen los valores de los tiempos 
....................    disable_interrupts(INT_CCP1); 
....................    disable_interrupts(INT_CCP2); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
....................    return (0); 
.................... } 
.................... #endif 
....................  
.................... #include "memoria.c" 
.................... //#include "Nucleo.h" 
.................... #ifdef MEMORIA_H 
....................  
.................... //#include "memoria.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... #include <usb_cdc.h> 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... //borrar para quitar el debug de memoria 
.................... #define debug_memoria 1	 
....................  
.................... // #define MEM_RX PIN_D7 
.................... // #define MEM_TX PIN_D6	 
.................... #define MEMORIA_PIN_RESET PIN_D5 
.................... #use rs232(uart1, stream=MEMORIA, BAUD=9600, TIMEOUT=1000) 
*
176E:  BTFSS  F9E.4
1770:  BRA    176E
1772:  MOVWF  FAD
1774:  GOTO   17AC (RETURN)
*
17F2:  MOVLW  0C
17F4:  MOVLB  2
17F6:  MOVWF  x95
17F8:  MOVLW  85
17FA:  MOVWF  x94
17FC:  MOVLW  02
17FE:  MOVWF  x96
1800:  MOVLW  9B
1802:  MOVWF  x97
1804:  MOVLB  0
1806:  BRA    17D0
1808:  MOVLB  2
180A:  DECFSZ x96,F
180C:  BRA    1800
180E:  DECFSZ x94,F
1810:  BRA    1820
1812:  DECFSZ x95,F
1814:  BRA    1820
1816:  MOVLB  1
1818:  CLRF   xBE
181A:  CLRF   01
181C:  BRA    1836
181E:  MOVLB  2
1820:  BTFSS  F9E.5
1822:  BRA    17FC
1824:  MOVF   FAB,W
1826:  MOVLB  1
1828:  MOVWF  xBE
182A:  MOVF   FAE,W
182C:  MOVWF  01
182E:  BTFSS  xBE.1
1830:  BRA    1836
1832:  BCF    FAB.4
1834:  BSF    FAB.4
1836:  MOVLB  0
1838:  RETLW  00
.................... #define time_delay 1000 
....................  
.................... short MEMORIA_OK = FALSE; 
.................... short MEMORIA_HW = FALSE; 
.................... short timeout_error = FALSE; 
.................... short read_flag = 0; //utilizada por un bug en la lectura de archivos desde dispositivo de memoria 
.................... int8 MEM_proceso = INI_HW; 
.................... unsigned int i = 0; 
.................... unsigned int car = 0; 
.................... unsigned int32 tamano = 0; 
.................... char MEM_info[5] = {0x00,0x00,0x00,0x00,0x00}; 
.................... char MEM_file_name[MEMORIA_NAME_LENG_LIMIT]; 
.................... char MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
.................... char MEM_append = MEMORIA_APPEND; 
.................... //char MEM_performance = MEMORIA_HIGH_PERFORMANCE;	//cambiar a low performance 
.................... char MEM_performance = MEMORIA_LOW_PERFORMANCE; 
.................... char MEM_RESPONSE = MEMORIA_NOACK; 
....................  
.................... #ifdef debug_memoria 
.................... void update_proceso(int8 proceso){ 
.................... 	MEM_proceso = proceso; 
*
160A:  MOVFF  292,1BF
.................... 	printf(usb_cdc_putc_fast,"\n\rMp>%d", MEM_proceso); 
160E:  MOVLW  4E
1610:  MOVWF  FF6
1612:  MOVLW  22
1614:  MOVWF  FF7
1616:  MOVLW  05
1618:  MOVLB  2
161A:  MOVWF  x93
161C:  MOVLB  0
161E:  RCALL  14D8
1620:  MOVFF  1BF,293
1624:  MOVLW  1F
1626:  MOVLB  2
1628:  MOVWF  x94
162A:  MOVLB  0
162C:  RCALL  152C
.................... 	return; 
.................... } 
162E:  RETLW  00
.................... #endif 
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL INICIO DEL MODULO DE MEMORIA 
.................... 	====================================== 
.................... */ 
.................... /*==================== reset de memoria ======================*/ 
.................... int MEMORIA_reset(void){ 
.................... 	#ifdef debug_memoria 
.................... 	usb_cdc_putc_fast('r'); 
*
22D2:  MOVLW  72
22D4:  MOVLB  2
22D6:  MOVWF  x99
22D8:  MOVLB  0
22DA:  CALL   14A6
.................... 	#endif 
.................... 	output_float(PIN_D6); 
22DE:  BSF    F95.6
....................    output_low(MEMORIA_PIN_RESET); 
22E0:  BCF    F95.5
22E2:  BCF    F8C.5
....................    delay_ms(1000); 
22E4:  MOVLW  04
22E6:  MOVLB  1
22E8:  MOVWF  xDB
22EA:  MOVLW  FA
22EC:  MOVWF  xDC
22EE:  MOVLB  0
22F0:  RCALL  22A8
22F2:  MOVLB  1
22F4:  DECFSZ xDB,F
22F6:  BRA    22EA
....................    read_flag = 0; 
22F8:  MOVLB  0
22FA:  BCF    x86.5
....................    output_high(MEMORIA_PIN_RESET); 
22FC:  BCF    F95.5
22FE:  BSF    F8C.5
....................    delay_ms(3000); 
2300:  MOVLW  0C
2302:  MOVLB  1
2304:  MOVWF  xDB
2306:  MOVLW  FA
2308:  MOVWF  xDC
230A:  MOVLB  0
230C:  RCALL  22A8
230E:  MOVLB  1
2310:  DECFSZ xDB,F
2312:  BRA    2306
....................    return(0); 
2314:  MOVLW  00
2316:  MOVWF  01
.................... } 
2318:  MOVLB  0
231A:  GOTO   2684 (RETURN)
....................  
.................... /*==================== autobaudrate ======================*/ 
.................... int MEMORIA_init_hw(void){ 
231E:  MOVLW  0A
2320:  MOVLB  1
2322:  MOVWF  xDB
.................... 	int8 envios = 10; 
.................... 	#ifdef debug_memoria 
.................... 	update_proceso(INI_HW); 
2324:  MOVLB  2
2326:  CLRF   x92
2328:  MOVLB  0
232A:  CALL   160A
.................... 	#else 
.................... 	MEM_proceso = INI_HW; 
.................... 	#endif 
.................... 	 
.................... 	do{ 
.................... 		MEMORIA_putc(MEMORIA_CMD_AUTOBAUD); 
232E:  MOVLW  55
2330:  MOVLB  2
2332:  MOVWF  x93
2334:  MOVLB  0
2336:  CALL   1778
.................... 		MEM_RESPONSE = MEMORIA_getc(); 
233A:  CALL   183A
233E:  MOVFF  01,1DA
.................... 		envios --; 
2342:  MOVLB  1
2344:  DECF   xDB,F
.................... 		delay_ms(200); 
2346:  MOVLW  C8
2348:  MOVWF  xDC
234A:  MOVLB  0
234C:  RCALL  22A8
.................... 	}while((envios > 0) && (MEM_RESPONSE != MEMORIA_ACK) );                                                        
234E:  MOVLB  1
2350:  MOVF   xDB,F
2352:  BZ    2360
2354:  MOVF   xDA,W
2356:  SUBLW  06
2358:  BTFSC  FD8.2
235A:  BRA    2360
235C:  MOVLB  0
235E:  BRA    232E
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){                                 
2360:  MOVF   xDA,W
2362:  SUBLW  06
2364:  BZ    236C
.................... 		return (1); 
2366:  MOVLW  01
2368:  MOVWF  01
236A:  BRA    2386
.................... 	} 
....................     
....................    MEMORIA_HW = TRUE; 
236C:  MOVLB  0
236E:  BSF    x86.3
....................    MEMORIA_OK = FALSE; 
2370:  BCF    x86.2
....................    read_flag = 0; 
2372:  BCF    x86.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(INI_SW); 
2374:  MOVLW  01
2376:  MOVLB  2
2378:  MOVWF  x92
237A:  MOVLB  0
237C:  CALL   160A
.................... 	#else 
.................... 	MEM_proceso = INI_SW; 
.................... 	#endif 
.................... 	 
....................    return (0); 
2380:  MOVLW  00
2382:  MOVWF  01
2384:  MOVLB  1
.................... } 
2386:  MOVLB  0
2388:  GOTO   2686 (RETURN)
....................  
.................... /*==================== iniciar memoria ======================*/ 
.................... int MEMORIA_init(void){ 
....................  
....................    if(!MEMORIA_HW || (MEM_proceso != INI_SW)) return (1); 
238C:  BTFSS  x86.3
238E:  BRA    23A0
2390:  MOVLB  1
2392:  DECFSZ xBF,W
2394:  BRA    2398
2396:  BRA    239C
2398:  MOVLB  0
239A:  BRA    23A0
239C:  BRA    23A6
239E:  MOVLB  0
23A0:  MOVLW  01
23A2:  MOVWF  01
23A4:  BRA    23EE
.................... 	 
.................... 	MEMORIA_putc(MEMORIA_EXT_CMD); 
23A6:  MOVLW  40
23A8:  MOVLB  2
23AA:  MOVWF  x93
23AC:  MOVLB  0
23AE:  CALL   1778
....................    MEMORIA_putc(MEMORIA_CMD_INITIALIZE); 
23B2:  MOVLW  69
23B4:  MOVLB  2
23B6:  MOVWF  x93
23B8:  MOVLB  0
23BA:  CALL   1778
....................     
....................    MEM_RESPONSE = MEMORIA_getc(); 
23BE:  CALL   183A
23C2:  MOVFF  01,1DA
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK) return(2); 
23C6:  MOVLB  1
23C8:  MOVF   xDA,W
23CA:  SUBLW  06
23CC:  BZ    23D8
23CE:  MOVLW  02
23D0:  MOVWF  01
23D2:  MOVLB  0
23D4:  BRA    23EE
....................    else MEMORIA_OK = TRUE; 
23D6:  BRA    23DC
23D8:  MOVLB  0
23DA:  BSF    x86.2
....................     
....................    read_flag = 0; 
23DC:  BCF    x86.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
23DE:  MOVLW  02
23E0:  MOVLB  2
23E2:  MOVWF  x92
23E4:  MOVLB  0
23E6:  CALL   160A
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return (0); 
23EA:  MOVLW  00
23EC:  MOVWF  01
.................... } 
23EE:  GOTO   268C (RETURN)
....................  
.................... /*====================get info======================*/ 
.................... void MEMORIA_getinfo(){ 
....................  
.................... 	MEMORIA_putc(MEMORIA_CMD_VER_INFO); 
....................    MEM_info[0] = MEMORIA_getc(); 
....................    MEM_info[1] = MEMORIA_getc(); 
....................    MEM_info[2] = MEMORIA_getc(); 
....................    MEM_info[3] = MEMORIA_getc(); 
....................    MEM_info[4] = MEMORIA_getc(); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\rMemInf: %x %x %x %x %x", MEM_info[0],MEM_info[1],MEM_info[2],MEM_info[3],MEM_info[4]); 
....................    #endif 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL MANEJO DE ARCHIVOS 
.................... 	====================================== 
.................... */ 
....................  
.................... /*====================abrir archivo======================*/ 
....................  
.................... int MEMORIA_open(char* filename, short modo){ 
....................  
....................    if(!MEMORIA_OK) return(1); 
*
16B0:  BTFSC  x86.2
16B2:  BRA    16BA
16B4:  MOVLW  01
16B6:  MOVWF  01
16B8:  BRA    1722
....................  
....................    if(modo){ 
16BA:  MOVLB  2
16BC:  MOVF   x91,F
16BE:  BZ    16CC
....................       #ifdef debug_memoria 
.................... 		update_proceso(WR); 
16C0:  MOVLW  05
16C2:  MOVWF  x92
16C4:  MOVLB  0
16C6:  RCALL  160A
.................... 		#else 
.................... 		MEM_proceso = WR; 
.................... 		#endif 
....................    }else{ 
16C8:  BRA    16D4
16CA:  MOVLB  2
.................... 		#ifdef debug_memoria 
.................... 		update_proceso(RD); 
16CC:  MOVLW  03
16CE:  MOVWF  x92
16D0:  MOVLB  0
16D2:  RCALL  160A
.................... 		#else 
.................... 		MEM_proceso = RD; 
.................... 		#endif 
....................    } 
....................     
....................    car = strlen(filename); 
16D4:  MOVFF  290,293
16D8:  MOVFF  28F,292
16DC:  RCALL  1434
16DE:  MOVFF  01,1C1
....................    car = (car <= MEMORIA_NAME_LENG_LIMIT)? car : MEMORIA_NAME_LENG_LIMIT;  
16E2:  MOVLB  1
16E4:  MOVF   xC1,W
16E6:  SUBLW  0C
16E8:  BNC   16EE
16EA:  MOVF   xC1,W
16EC:  BRA    16F0
16EE:  MOVLW  0C
16F0:  MOVWF  xC1
....................    strncpy(MEM_file_name, filename, car); 
16F2:  MOVLW  01
16F4:  MOVLB  2
16F6:  MOVWF  x93
16F8:  MOVLW  CB
16FA:  MOVWF  x92
16FC:  MOVFF  290,295
1700:  MOVFF  28F,294
1704:  MOVFF  1C1,296
1708:  MOVLB  0
170A:  BRA    1630
....................     
....................    i = 0; 
170C:  MOVLB  1
170E:  CLRF   xC0
....................    timeout_error = FALSE; 
1710:  MOVLB  0
1712:  BCF    x86.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
1714:  MOVLW  01
1716:  MOVLB  1
1718:  MOVWF  xD7
....................    MEM_RESPONSE = MEMORIA_NOACK; 
171A:  MOVLW  15
171C:  MOVWF  xDA
....................    return (0); 
171E:  MOVLW  00
1720:  MOVWF  01
1722:  MOVLB  0
.................... } 
1724:  GOTO   1D5A (RETURN)
....................  
.................... /*==================== cancelar proceso ======================*/ 
....................  
.................... int MEMORIA_cancel(void){ 
....................  
....................    if((MEM_proceso != GET) || (MEM_proceso != SET)){ 
....................       return(-1); 
....................    } 
....................     
....................    if(MEM_proceso == GET){ 
....................       fputc(MEMORIA_NOACK, MEMORIA); 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................  
....................    if(MEM_proceso == SET){ 
....................       while(tamano > 0 ){ 
....................          fputc(0x00,MEMORIA); 
....................          --tamano; 
....................       } 
....................    } 
....................  
....................    tamano = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    return (0); 
.................... } 
....................  
.................... /*==================== enviar comando de escritura ======================*/ 
.................... /* 
....................  *BUG: puede retornar 1 0 en la primera escritura del archivo 
....................  *TODO: corregir para primera escritura  
.................... */ 
.................... int MEMORIA_write(unsigned int size){ 
....................     
....................    if(!MEMORIA_OK)return(-1); 
*
18E0:  BTFSC  x86.2
18E2:  BRA    18EA
18E4:  MOVLW  FF
18E6:  MOVWF  01
18E8:  BRA    19D4
....................    if(MEM_proceso != WR)return(-2); 
18EA:  MOVLB  1
18EC:  MOVF   xBF,W
18EE:  SUBLW  05
18F0:  BZ    18FA
18F2:  MOVLW  FE
18F4:  MOVWF  01
18F6:  MOVLB  0
18F8:  BRA    19D4
....................        
....................     
....................    //buffer maximo de 100 bytes 
....................    if((size > 0) && (size <= MAX_BUFFER)) 
18FA:  MOVLB  2
18FC:  MOVF   x8F,F
18FE:  BZ    190E
1900:  MOVF   x8F,W
1902:  SUBLW  64
1904:  BNC   190E
....................       MEM_handshaking = MEMORIA_NO_HANDSHAKING; 
1906:  MOVLB  1
1908:  CLRF   xD7
....................    else 
190A:  BRA    1918
190C:  MOVLB  2
....................       return (-3); 
190E:  MOVLW  FD
1910:  MOVWF  01
1912:  MOVLB  0
1914:  BRA    19D4
1916:  MOVLB  1
....................     
....................    tamano = (unsigned int32)size; 
1918:  CLRF   xC5
191A:  CLRF   xC4
191C:  CLRF   xC3
191E:  MOVFF  28F,1C2
....................    //tamano = (int32)size; 
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
1922:  MOVLW  40
1924:  MOVLB  2
1926:  MOVWF  x93
1928:  MOVLB  0
192A:  RCALL  1778
....................    MEMORIA_putc(MEMORIA_CMD_WRITE_FILE); 
192C:  MOVLW  74
192E:  MOVLB  2
1930:  MOVWF  x93
1932:  MOVLB  0
1934:  RCALL  1778
....................    MEMORIA_putc((MEM_handshaking | MEM_append | MEM_performance)); 
1936:  MOVLB  1
1938:  MOVF   xD7,W
193A:  IORWF  xD8,W
193C:  IORWF  xD9,W
193E:  MOVLB  2
1940:  MOVWF  x90
1942:  MOVWF  x93
1944:  MOVLB  0
1946:  RCALL  1778
....................     
....................    for(i = 0; i < car; i++) 
1948:  MOVLB  1
194A:  CLRF   xC0
194C:  MOVF   xC1,W
194E:  SUBWF  xC0,W
1950:  BC    1972
....................       MEMORIA_putc(MEM_file_name[i]); 
1952:  CLRF   03
1954:  MOVF   xC0,W
1956:  ADDLW  CB
1958:  MOVWF  FE9
195A:  MOVLW  01
195C:  ADDWFC 03,W
195E:  MOVWF  FEA
1960:  MOVFF  FEF,290
1964:  MOVFF  290,293
1968:  MOVLB  0
196A:  RCALL  1778
196C:  MOVLB  1
196E:  INCF   xC0,F
1970:  BRA    194C
....................  
....................    MEMORIA_putc(0x00); 
1972:  MOVLB  2
1974:  CLRF   x93
1976:  MOVLB  0
1978:  RCALL  1778
....................  
....................    MEMORIA_putc(make8(tamano,3)); 
197A:  MOVFF  1C5,290
197E:  MOVFF  1C5,293
1982:  RCALL  1778
....................    MEMORIA_putc(make8(tamano,2)); 
1984:  MOVFF  1C4,290
1988:  MOVFF  1C4,293
198C:  RCALL  1778
....................    MEMORIA_putc(make8(tamano,1)); 
198E:  MOVFF  1C3,290
1992:  MOVFF  1C3,293
1996:  RCALL  1778
....................    MEMORIA_putc(make8(tamano,0)); 
1998:  MOVFF  1C2,290
199C:  MOVFF  1C2,293
19A0:  RCALL  1778
....................  
....................    MEM_RESPONSE = MEMORIA_getc(); 
19A2:  RCALL  183A
19A4:  MOVFF  01,1DA
....................    //reparacion de bug a primera escritura 
....................    if(MEM_RESPONSE == 0x00){ 
19A8:  MOVLB  1
19AA:  MOVF   xDA,F
19AC:  BNZ   19B8
....................    	MEM_RESPONSE = MEMORIA_getc(); 
19AE:  MOVLB  0
19B0:  RCALL  183A
19B2:  MOVFF  01,1DA
19B6:  MOVLB  1
....................    } 
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){ 
19B8:  MOVF   xDA,W
19BA:  SUBLW  06
19BC:  BZ    19C6
....................       return (-4); 
19BE:  MOVLW  FC
19C0:  MOVWF  01
19C2:  MOVLB  0
19C4:  BRA    19D4
....................    } 
....................    #ifdef debug_memoria 
.................... 	update_proceso(SET); 
19C6:  MOVLW  06
19C8:  MOVLB  2
19CA:  MOVWF  x92
19CC:  MOVLB  0
19CE:  RCALL  160A
.................... 	#else 
.................... 	MEM_proceso = SET; 
.................... 	#endif 
....................    return (0); 
19D0:  MOVLW  00
19D2:  MOVWF  01
.................... } 
19D4:  GOTO   1D8E (RETURN)
....................  
.................... /*==================== enviar datos de escritura ======================*/ 
.................... /* 
....................  * corrwgir deacuerdo a MEMORIA_write() 
....................  */ 
.................... int MEMORIA_set_data(char *data, unsigned int size){ 
....................  
....................    if(!MEMORIA_OK)return(-5); 
19D8:  BTFSC  x86.2
19DA:  BRA    19E2
19DC:  MOVLW  FB
19DE:  MOVWF  01
19E0:  BRA    1A94
....................    if(MEM_proceso != SET) return(-6); 
19E2:  MOVLB  1
19E4:  MOVF   xBF,W
19E6:  SUBLW  06
19E8:  BZ    19F4
19EA:  MOVLW  FA
19EC:  MOVWF  01
19EE:  MOVLB  0
19F0:  BRA    1A94
19F2:  MOVLB  1
....................    if(tamano <= 0)return(-7); 
19F4:  MOVF   xC2,F
19F6:  BNZ   1A0E
19F8:  MOVF   xC3,F
19FA:  BNZ   1A0E
19FC:  MOVF   xC4,F
19FE:  BNZ   1A0E
1A00:  MOVF   xC5,F
1A02:  BNZ   1A0E
1A04:  MOVLW  F9
1A06:  MOVWF  01
1A08:  MOVLB  0
1A0A:  BRA    1A94
1A0C:  MOVLB  1
....................  
....................    i = 0; 
1A0E:  CLRF   xC0
....................    while((tamano > 0)&&(i < size)){ 
1A10:  MOVF   xC2,F
1A12:  BNZ   1A20
1A14:  MOVF   xC3,F
1A16:  BNZ   1A20
1A18:  MOVF   xC4,F
1A1A:  BNZ   1A20
1A1C:  MOVF   xC5,F
1A1E:  BZ    1A5C
1A20:  MOVLB  2
1A22:  MOVF   x91,W
1A24:  MOVLB  1
1A26:  SUBWF  xC0,W
1A28:  BC    1A5C
....................       MEMORIA_putc(data[i]); 
1A2A:  CLRF   03
1A2C:  MOVF   xC0,W
1A2E:  MOVLB  2
1A30:  ADDWF  x8F,W
1A32:  MOVWF  FE9
1A34:  MOVF   x90,W
1A36:  ADDWFC 03,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  FEF,292
1A3E:  MOVFF  292,293
1A42:  MOVLB  0
1A44:  RCALL  1778
....................       i++; 
1A46:  MOVLB  1
1A48:  INCF   xC0,F
....................       tamano--; 
1A4A:  MOVLW  FF
1A4C:  ADDWF  xC2,F
1A4E:  BTFSS  FD8.0
1A50:  ADDWF  xC3,F
1A52:  BTFSS  FD8.0
1A54:  ADDWF  xC4,F
1A56:  BTFSS  FD8.0
1A58:  ADDWF  xC5,F
....................    } 
1A5A:  BRA    1A10
....................     
....................    //si no hay mas datos 
....................    if(tamano <= 0){ 
1A5C:  MOVF   xC2,F
1A5E:  BNZ   1A90
1A60:  MOVF   xC3,F
1A62:  BNZ   1A90
1A64:  MOVF   xC4,F
1A66:  BNZ   1A90
1A68:  MOVF   xC5,F
1A6A:  BNZ   1A90
....................       MEM_RESPONSE = MEMORIA_getc(); 
1A6C:  MOVLB  0
1A6E:  RCALL  183A
1A70:  MOVFF  01,1DA
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
1A74:  MOVLB  1
1A76:  MOVF   xDA,W
1A78:  SUBLW  06
1A7A:  BZ    1A84
....................          return (-8); 
1A7C:  MOVLW  F8
1A7E:  MOVWF  01
1A80:  MOVLB  0
1A82:  BRA    1A94
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
1A84:  MOVLW  07
1A86:  MOVLB  2
1A88:  MOVWF  x92
1A8A:  MOVLB  0
1A8C:  RCALL  160A
1A8E:  MOVLB  1
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i); 
1A90:  MOVFF  1C0,01
1A94:  MOVLB  0
.................... } 
1A96:  GOTO   1DCC (RETURN)
....................  
.................... /*==================== enviar comando de lectura ======================*/ 
....................  
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes){ 
....................    char Umsb = 0, Ulsb = 0, Lmsb = 0,Llsb = 0, dummy= 0; 
....................  
....................    if(!MEMORIA_OK)return(-1); 
....................    if(MEM_proceso != RD)return(-2); 
....................  
....................    if((num_bytes > 0) && (num_bytes <= MAX_BUFFER)) 
....................       MEM_handshaking = num_bytes; 
....................    else 
....................       return (-3); 
....................     
....................     
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_READ_FILE); 
....................    MEMORIA_putc(MEM_handshaking); 
....................     
....................    for(i = 0; i < car; i++) 
....................       MEMORIA_putc(MEM_file_name[i]); 
.................... 	 
.................... 	fputc(0x00, MEMORIA); 
.................... 	// hay un bug al leer por primera vez un archivo 
.................... 	// genera 2 ACK antes del tamao del archivo 
.................... 	if(read_flag == 0){ 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		read_flag = 1; 
.................... 	} 
.................... 	//bug de comunicacion 
.................... 	 
.................... 	Umsb = fgetc(MEMORIA); 
....................    Ulsb = fgetc(MEMORIA); 
....................    Lmsb = fgetc(MEMORIA); 
....................    Llsb = fgetc(MEMORIA); 
....................     
....................    tamano = make32(Umsb,Ulsb,Lmsb,Llsb); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r==%x %x %x %x", Umsb, Ulsb,Lmsb,Llsb); 
.................... 	update_proceso(GET); 
.................... 	#else 
.................... 	MEM_proceso = GET; 
.................... 	#endif 
....................    return (tamano); 
.................... } 
....................  
....................  
.................... /*==================== obtener datos de la lectura ======================*/ 
....................  
.................... int MEMORIA_get_data(char *buffer){    
....................    char c = 0x00; 
....................  
....................    if(!MEMORIA_OK) return(-1); 
....................    if(MEM_proceso != GET) return(-2); 
....................    if(tamano <= 0) return(-3); 
....................  
....................    i = 0; 
....................    MEMORIA_putc(MEMORIA_ACK);//envia un ACK para recivir nuevos datos 
....................    while((i < MEM_handshaking) && (tamano > 0 )){ 
....................       c = MEMORIA_getc(); 
....................       buffer[i] = c; 
....................       i++; 
....................       tamano--; 
....................    } 
....................  
....................    //si alcanzo el total de datos 
....................    if(tamano == 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
....................          return (-4); 
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i);    
.................... } 
....................  
.................... /*==================== cerrar el archivo abierto ======================*/ 
....................  
.................... int MEMORIA_close(void){ 
.................... 	/* 
.................... 	* hay un bug en esta funcion que no contempla limpiar 
.................... 	* la configuracion cuando no ha iniciado el hardware o 
.................... 	* despues de un reset 
.................... 	*/ 
.................... 	/* 
....................    if(!MEMORIA_OK)return (1); 
....................    if(MEM_proceso != CLOSE) return(2); 
....................    */ 
....................    strcpy (MEM_file_name,"");	//cambiar para inicializar a 0 
1A9A:  MOVLW  01
1A9C:  MOVWF  FEA
1A9E:  MOVLW  CB
1AA0:  MOVWF  FE9
1AA2:  MOVLW  00
1AA4:  CALL   027E
1AA8:  TBLRD*-
1AAA:  TBLRD*+
1AAC:  MOVF   FF5,W
1AAE:  MOVWF  FEE
1AB0:  IORLW  00
1AB2:  BNZ   1AAA
....................    i = 0; 
1AB4:  MOVLB  1
1AB6:  CLRF   xC0
....................    car = 0; 
1AB8:  CLRF   xC1
....................    timeout_error = FALSE; 
1ABA:  MOVLB  0
1ABC:  BCF    x86.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
1ABE:  MOVLW  01
1AC0:  MOVLB  1
1AC2:  MOVWF  xD7
....................    MEM_RESPONSE = MEMORIA_NOACK; 
1AC4:  MOVLW  15
1AC6:  MOVWF  xDA
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
1AC8:  MOVLW  02
1ACA:  MOVLB  2
1ACC:  MOVWF  x92
1ACE:  MOVLB  0
1AD0:  RCALL  160A
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return(0); 
1AD2:  MOVLW  00
1AD4:  MOVWF  01
.................... } 
1AD6:  GOTO   1DF6 (RETURN)
....................  
.................... /*	====================================== 
.................... 	FUNCIONES FUNCIONES DE CONTROL Y BAJO NIVEL 
.................... 	====================================== 
.................... */ 
....................  
.................... /*==================== memoria ocupada =======================*/ 
.................... /*comprueba que no se este realizando un porceso anterior en la memoria*/ 
.................... int MEMORIA_is_busy(void){ 
....................    return ((MEM_proceso == OPEN )? 0 : 1); 
.................... }  
....................  
.................... /*==================== colocar un caracter en el bus======================*/ 
.................... void MEMORIA_putc(char c){ 
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, "\n\r>%X", c); 
*
1778:  MOVLW  0A
177A:  MOVLB  2
177C:  MOVWF  x99
177E:  MOVLB  0
1780:  RCALL  14A6
1782:  MOVLW  0D
1784:  MOVLB  2
1786:  MOVWF  x99
1788:  MOVLB  0
178A:  RCALL  14A6
178C:  MOVLW  3E
178E:  MOVLB  2
1790:  MOVWF  x99
1792:  MOVLB  0
1794:  RCALL  14A6
1796:  MOVFF  293,294
179A:  MOVLW  37
179C:  MOVLB  2
179E:  MOVWF  x95
17A0:  MOVLB  0
17A2:  RCALL  1728
.................... 	#endif 
....................    fputc(c, MEMORIA); 
17A4:  MOVLB  2
17A6:  MOVF   x93,W
17A8:  MOVLB  0
17AA:  BRA    176E
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, " e%X", rs232_errors); 
17AC:  MOVLW  20
17AE:  MOVLB  2
17B0:  MOVWF  x99
17B2:  MOVLB  0
17B4:  RCALL  14A6
17B6:  MOVLW  65
17B8:  MOVLB  2
17BA:  MOVWF  x99
17BC:  MOVLB  0
17BE:  RCALL  14A6
17C0:  MOVFF  1BE,294
17C4:  MOVLW  37
17C6:  MOVLB  2
17C8:  MOVWF  x95
17CA:  MOVLB  0
17CC:  RCALL  1728
.................... 	#endif 
....................    return; 
.................... } 
17CE:  RETLW  00
....................  
.................... /*==================== obtiene un caracter del bus======================*/ 
.................... char MEMORIA_getc(void){ 
*
183A:  MOVLB  2
183C:  CLRF   x92
183E:  MOVLW  03
1840:  MOVWF  x93
.................... 	char c = 0x00, cont = 3; 
....................    timeout_error=FALSE; 
1842:  MOVLB  0
1844:  BCF    x86.4
....................    while(!kbhit(MEMORIA) && cont > 0 && !c){ 
1846:  BTFSC  F9E.5
1848:  BRA    187A
184A:  MOVLB  2
184C:  MOVF   x93,F
184E:  BTFSS  FD8.2
1850:  BRA    1856
1852:  MOVLB  0
1854:  BRA    187A
1856:  MOVF   x92,F
1858:  BTFSC  FD8.2
185A:  BRA    1860
185C:  MOVLB  0
185E:  BRA    187A
....................    	c = fgetc(MEMORIA); 
1860:  MOVLB  0
1862:  RCALL  17F2
1864:  MOVFF  01,292
....................    	#ifdef debug_memoria 
....................    	usb_cdc_putc_fast('*'); 
1868:  MOVLW  2A
186A:  MOVLB  2
186C:  MOVWF  x99
186E:  MOVLB  0
1870:  RCALL  14A6
....................    	#endif 
....................    	cont--; 
1872:  MOVLB  2
1874:  DECF   x93,F
....................    } 
1876:  MOVLB  0
1878:  BRA    1846
....................     
....................    if(!c) c = fgetc(MEMORIA); 
187A:  MOVLB  2
187C:  MOVF   x92,F
187E:  BNZ   188A
1880:  MOVLB  0
1882:  RCALL  17F2
1884:  MOVFF  01,292
1888:  MOVLB  2
....................     
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r<%x e%x", c, rs232_errors); 
188A:  MOVLW  0A
188C:  MOVWF  x99
188E:  MOVLB  0
1890:  RCALL  14A6
1892:  MOVLW  0D
1894:  MOVLB  2
1896:  MOVWF  x99
1898:  MOVLB  0
189A:  RCALL  14A6
189C:  MOVLW  3C
189E:  MOVLB  2
18A0:  MOVWF  x99
18A2:  MOVLB  0
18A4:  RCALL  14A6
18A6:  MOVFF  292,294
18AA:  MOVLW  57
18AC:  MOVLB  2
18AE:  MOVWF  x95
18B0:  MOVLB  0
18B2:  RCALL  1728
18B4:  MOVLW  20
18B6:  MOVLB  2
18B8:  MOVWF  x99
18BA:  MOVLB  0
18BC:  RCALL  14A6
18BE:  MOVLW  65
18C0:  MOVLB  2
18C2:  MOVWF  x99
18C4:  MOVLB  0
18C6:  RCALL  14A6
18C8:  MOVFF  1BE,294
18CC:  MOVLW  57
18CE:  MOVLB  2
18D0:  MOVWF  x95
18D2:  MOVLB  0
18D4:  RCALL  1728
....................    #endif 
....................    return(c); 
18D6:  MOVLB  2
18D8:  MOVFF  292,01
.................... } 
18DC:  MOVLB  0
18DE:  RETLW  00
.................... #endif	// MEMORIA_H 
....................  
.................... #include "utilidades.c" 
.................... //#include "Nucleo.h" 
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
.................... #define MYDIM 64; 
.................... char MyArray[MYDIM]; 
.................... */ 
....................  
.................... int16 crc_1021(int16 old_crc, int8 data) 
.................... {  
....................   int16 crc; 
....................   int16 x; 
....................   x = make8(old_crc,1) ^ data;  //x = ((old_crc>>8) ^ data) & 0xff;  
....................   x ^= x>>4; 
....................   crc = (old_crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
....................   crc &= 0xffff;  
....................   return crc;  
.................... } 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng){ 
.................... 	unsigned int8 i;  
....................    int16 MyCRC; 
....................     
....................    MyCRC = 0xFFFF;  
....................    for(i=0 ; i<leng ; i++) {  
....................       MyCRC = crc_1021(MyCRC,buffer[i]);  
....................    } 
....................    return (MyCRC); 
.................... } 
....................  
.................... #ifndef SIMULACION 
.................... int1 _debug_usb(void){ 
.................... 	if(COM_sense() == USB_OK){ 
*
1B7E:  RCALL  1B5C
1B80:  DECFSZ 01,W
1B82:  BRA    1B90
....................       output_bit(INDICADOR_USB, 1); 
1B84:  BSF    F8D.1
1B86:  BCF    F96.1
....................       return (1); 
1B88:  MOVLW  01
1B8A:  MOVWF  01
1B8C:  BRA    1B9A
.................... 	}else{ 
1B8E:  BRA    1B9A
.................... 		output_bit(INDICADOR_USB, 0); 
1B90:  BCF    F8D.1
1B92:  BCF    F96.1
.................... 		return (0); 
1B94:  MOVLW  00
1B96:  MOVWF  01
1B98:  BRA    1B9A
.................... 	} 
.................... } 
1B9A:  RETLW  00
.................... #endif 
....................  
....................  
.................... #include "configuracion.c" 
.................... #ifdef CONFIGURACION_H 
....................  
.................... void iniciar_perifericos(){ 
....................      
....................     #ifdef COMUNICACION_H 
....................     myerror = COM_init(); 
*
267C:  BRA    2298
267E:  MOVFF  01,A1
....................     //printf("\n\rusb E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef MEMORIA_H 
....................     MEMORIA_reset(); 
2682:  BRA    22D2
....................    myerror = MEMORIA_init_hw(); 
2684:  BRA    231E
2686:  MOVFF  01,A1
....................    myerror = MEMORIA_init(); 
268A:  BRA    238C
268C:  MOVFF  01,A1
....................    //printf("\n\rmem E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef ANALOGO_DIGITAL_H 
....................     myerror = AD_init_adc(); 
2690:  BRA    23F2
2692:  MOVFF  01,A1
....................     #endif 
....................      
....................     #ifdef CAPTURA_FRECUENCIA_H 
....................     myerror = CP_init_ccp(); 
2696:  BRA    2414
2698:  MOVFF  01,A1
....................     #endif 
....................      
....................     #ifdef DS1307_H 
....................     ds1307_init(DS1307_OUT_ON_DISABLED_HIHG | DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
269C:  MOVLW  90
269E:  MOVLB  1
26A0:  MOVWF  xDB
26A2:  MOVLB  0
26A4:  BRA    2472
....................    //ds1307_set_date_time(0x0d, 0x01, 0x0d, 0x00, 0x0a, 0x2a, 0x00); 
....................    CONF_CANAL_ACTIVO = ds1307_read_nvram_byte(CONF_DIR_CANAl); 
26A6:  MOVLW  08
26A8:  MOVLB  1
26AA:  MOVWF  xDB
26AC:  MOVLB  0
26AE:  RCALL  25DC
26B0:  MOVFF  01,9F
....................    //CONF_CANAL_ACTIVO = 0b00000000; 
....................     #endif 
....................      
....................    data.dia = data.mes = data.anio = 0; 
26B4:  CLRF   xEA
26B6:  MOVFF  EA,E9
26BA:  MOVFF  E9,E8
....................    data.hor = data.min = data.seg = 0; 
26BE:  CLRF   xED
26C0:  MOVFF  ED,EC
26C4:  MOVFF  EC,EB
....................    data.value = data.sensor = data.no_data = 0; 
26C8:  CLRF   xEF
26CA:  MOVFF  EF,EE
26CE:  CLRF   xF3
26D0:  CLRF   xF2
26D2:  CLRF   xF1
26D4:  MOVFF  EE,F0
....................    data.crc = 0; 
26D8:  CLRF   xF5
26DA:  CLRF   xF4
....................     
.................... } 
26DC:  GOTO   26E2 (RETURN)
....................  
....................  
.................... int sensor_activo(int sensor){ 
....................     switch(sensor){ 
*
1EB2:  MOVLB  2
1EB4:  MOVF   x8D,W
1EB6:  XORLW  06
1EB8:  MOVLB  0
1EBA:  BZ    1ECA
1EBC:  XORLW  03
1EBE:  BZ    1ED4
1EC0:  XORLW  06
1EC2:  BZ    1EDE
1EC4:  XORLW  07
1EC6:  BZ    1EE8
1EC8:  BRA    1EF2
....................         case CCP_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_REV_BIT)); 
1ECA:  MOVLW  00
1ECC:  BTFSC  x9F.1
1ECE:  MOVLW  01
1ED0:  MOVWF  01
1ED2:  BRA    1EF8
....................         case CCP_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_VEL_BIT)); 
1ED4:  MOVLW  00
1ED6:  BTFSC  x9F.0
1ED8:  MOVLW  01
1EDA:  MOVWF  01
1EDC:  BRA    1EF8
....................         case AD_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_VEL_BIT)); 
1EDE:  MOVLW  00
1EE0:  BTFSC  x9F.3
1EE2:  MOVLW  01
1EE4:  MOVWF  01
1EE6:  BRA    1EF8
....................         case AD_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_REV_BIT)); 
1EE8:  MOVLW  00
1EEA:  BTFSC  x9F.4
1EEC:  MOVLW  01
1EEE:  MOVWF  01
1EF0:  BRA    1EF8
....................         default: 
....................             return (0); 
1EF2:  MOVLW  00
1EF4:  MOVWF  01
1EF6:  BRA    1EF8
....................     } 
.................... } 
1EF8:  RETLW  00
....................  
....................  
.................... void modo_configuracion(){ 
....................     //printf( cout "\n\rmodo configuracion\n\r" ); 
....................    while(!_debug_usb())continue; 
*
291C:  CALL   1B7E
2920:  MOVF   01,F
2922:  BNZ   2928
2924:  BRA    291C
2926:  BRA    291C
....................    while(_debug_usb()){ 
2928:  CALL   1B7E
292C:  MOVF   01,F
292E:  BTFSC  FD8.2
2930:  BRA    2CA2
....................             while(!(data.sensor = cin()));    //cambiar con usb 
2932:  RCALL  2738
2934:  MOVFF  01,EE
2938:  MOVF   xEE,F
293A:  BZ    2932
....................             switch(data.sensor){ 
293C:  MOVF   xEE,W
293E:  XORLW  31
2940:  BZ    2960
2942:  XORLW  03
2944:  BZ    29BE
2946:  XORLW  07
2948:  BTFSC  FD8.2
294A:  BRA    2BD8
294C:  XORLW  03
294E:  BTFSC  FD8.2
2950:  BRA    2C04
2952:  XORLW  05
2954:  BTFSC  FD8.2
2956:  BRA    2C30
2958:  XORLW  07
295A:  BTFSC  FD8.2
295C:  BRA    2C5A
295E:  BRA    2C84
....................                 case CONF_SET_FECHA: 
....................                     putc(CONF_SET_FECHA); 
2960:  MOVLW  31
2962:  MOVLB  1
2964:  MOVWF  xDB
2966:  MOVLB  0
2968:  RCALL  2776
....................                     //printf( cout "\n\rFECHA: %c", data.sensor); 
....................                     data.dia = cin(); 
296A:  RCALL  2738
296C:  MOVFF  01,E8
....................                     data.mes = cin(); 
2970:  RCALL  2738
2972:  MOVFF  01,E9
....................                     data.anio = cin(); 
2976:  RCALL  2738
2978:  MOVFF  01,EA
....................                     data.no_data = cin(); 
297C:  RCALL  2738
297E:  MOVFF  01,EF
....................                     data.hor = cin(); 
2982:  RCALL  2738
2984:  MOVFF  01,EB
....................                     data.min = cin(); 
2988:  RCALL  2738
298A:  MOVFF  01,EC
....................                     data.seg = cin(); 
298E:  RCALL  2738
2990:  MOVFF  01,ED
....................                     ds1307_set_date_time(data.dia, data.mes, data.anio, data.no_data,data.hor, data.min, data.seg); 
2994:  MOVFF  E8,1DB
2998:  MOVFF  E9,1DC
299C:  MOVFF  EA,1DD
29A0:  MOVFF  EF,1DE
29A4:  MOVFF  EB,1DF
29A8:  MOVFF  EC,1E0
29AC:  MOVFF  ED,1E1
29B0:  BRA    27B4
....................                     /*printf( cout "\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
....................                                 data.dia, data.mes, data.anio, 
....................                                 data.hor, data.min, data.seg, 
....................                                 data.sensor, data.no_data, data.value);*/ 
....................                     putc(CONF_ACK); 
29B2:  MOVLW  06
29B4:  MOVLB  1
29B6:  MOVWF  xDB
29B8:  MOVLB  0
29BA:  RCALL  2776
....................                     break; 
29BC:  BRA    2C8E
....................                 case CONF_GET_FECHA: 
....................                     putc(CONF_GET_FECHA); 
29BE:  MOVLW  32
29C0:  MOVLB  1
29C2:  MOVWF  xDB
29C4:  MOVLB  0
29C6:  RCALL  2776
....................                     ds1307_get_date(data.dia, data.mes, data.anio, data.no_data); 
....................                     ds1307_get_time(data.hor, data.min, data.seg); 
....................                     putc(data.dia); 
*
2BA2:  MOVFF  E8,1DB
2BA6:  RCALL  2776
....................                     putc(data.mes); 
2BA8:  MOVFF  E9,1DB
2BAC:  RCALL  2776
....................                     putc(data.anio); 
2BAE:  MOVFF  EA,1DB
2BB2:  RCALL  2776
....................                     putc(data.no_data); 
2BB4:  MOVFF  EF,1DB
2BB8:  RCALL  2776
....................                     putc(data.hor); 
2BBA:  MOVFF  EB,1DB
2BBE:  RCALL  2776
....................                     putc(data.min); 
2BC0:  MOVFF  EC,1DB
2BC4:  RCALL  2776
....................                     putc(data.seg); 
2BC6:  MOVFF  ED,1DB
2BCA:  RCALL  2776
....................                     putc(CONF_ACK); 
2BCC:  MOVLW  06
2BCE:  MOVLB  1
2BD0:  MOVWF  xDB
2BD2:  MOVLB  0
2BD4:  RCALL  2776
....................                     break; 
2BD6:  BRA    2C8E
....................                 case CONF_SET_DATO: 
....................                     putc(CONF_SET_DATO); 
2BD8:  MOVLW  35
2BDA:  MOVLB  1
2BDC:  MOVWF  xDB
2BDE:  MOVLB  0
2BE0:  RCALL  2776
....................                     data.sensor = cin(); //lee la direccion 
2BE2:  RCALL  2738
2BE4:  MOVFF  01,EE
....................                     data.no_data = cin(); // lee el valor 
2BE8:  RCALL  2738
2BEA:  MOVFF  01,EF
....................                     ds1307_write_nvram_byte(data.sensor, data.no_data); 
2BEE:  MOVFF  EE,1DB
2BF2:  MOVFF  EF,1DC
2BF6:  RCALL  2896
....................                     putc(CONF_ACK); 
2BF8:  MOVLW  06
2BFA:  MOVLB  1
2BFC:  MOVWF  xDB
2BFE:  MOVLB  0
2C00:  RCALL  2776
....................                     break; 
2C02:  BRA    2C8E
....................                 case CONF_GET_DATO: 
....................                     putc(CONF_GET_DATO); 
2C04:  MOVLW  36
2C06:  MOVLB  1
2C08:  MOVWF  xDB
2C0A:  MOVLB  0
2C0C:  RCALL  2776
....................                     data.sensor = cin(); //lee la direccion 
2C0E:  RCALL  2738
2C10:  MOVFF  01,EE
....................                     data.no_data = ds1307_read_nvram_byte(data.sensor); //lee el valor de la ram 
2C14:  MOVFF  EE,1DB
2C18:  RCALL  25DC
2C1A:  MOVFF  01,EF
....................                     putc(data.no_data); 
2C1E:  MOVFF  EF,1DB
2C22:  RCALL  2776
....................                     putc(CONF_ACK); 
2C24:  MOVLW  06
2C26:  MOVLB  1
2C28:  MOVWF  xDB
2C2A:  MOVLB  0
2C2C:  RCALL  2776
....................                     break; 
2C2E:  BRA    2C8E
....................                 case CONF_SET_CANAL: 
....................                     putc(CONF_SET_CANAL); 
2C30:  MOVLW  33
2C32:  MOVLB  1
2C34:  MOVWF  xDB
2C36:  MOVLB  0
2C38:  RCALL  2776
....................                     data.no_data = cin(); 
2C3A:  RCALL  2738
2C3C:  MOVFF  01,EF
....................                     ds1307_write_nvram_byte(CONF_DIR_CANAL, data.no_data); 
2C40:  MOVLW  08
2C42:  MOVLB  1
2C44:  MOVWF  xDB
2C46:  MOVFF  EF,1DC
2C4A:  MOVLB  0
2C4C:  RCALL  2896
....................                     //printf( cout "\n\rCANAL: %u", data.no_data); 
....................                     putc(CONF_ACK); 
2C4E:  MOVLW  06
2C50:  MOVLB  1
2C52:  MOVWF  xDB
2C54:  MOVLB  0
2C56:  RCALL  2776
....................                     break; 
2C58:  BRA    2C8E
....................                 case CONF_GET_CANAL: 
....................                     putc(CONF_GET_CANAL); 
2C5A:  MOVLW  34
2C5C:  MOVLB  1
2C5E:  MOVWF  xDB
2C60:  MOVLB  0
2C62:  RCALL  2776
....................                     data.no_data = ds1307_read_nvram_byte(CONF_DIR_CANAL); 
2C64:  MOVLW  08
2C66:  MOVLB  1
2C68:  MOVWF  xDB
2C6A:  MOVLB  0
2C6C:  RCALL  25DC
2C6E:  MOVFF  01,EF
....................                     putc(data.no_data); 
2C72:  MOVFF  EF,1DB
2C76:  RCALL  2776
....................                     putc(CONF_ACK); 
2C78:  MOVLW  06
2C7A:  MOVLB  1
2C7C:  MOVWF  xDB
2C7E:  MOVLB  0
2C80:  RCALL  2776
....................                     break; 
2C82:  BRA    2C8E
....................                 default: 
....................                     putc(CONF_NOACK); 
2C84:  MOVLW  15
2C86:  MOVLB  1
2C88:  MOVWF  xDB
2C8A:  MOVLB  0
2C8C:  RCALL  2776
....................             } 
....................             if(data.sensor == CONF_SALIR) {printf( cout "\n\rDesconectar...");break;} 
2C8E:  MOVF   xEE,W
2C90:  SUBLW  39
2C92:  BNZ   2CA0
2C94:  MOVLW  80
2C96:  MOVWF  FF6
2C98:  MOVLW  22
2C9A:  MOVWF  FF7
2C9C:  BRA    28F8
2C9E:  BRA    2CA2
....................     } 
2CA0:  BRA    2928
....................     return; 
.................... } 
2CA2:  GOTO   2EDC (RETURN)
....................  
.................... #endif    //CONFIGURACION_H 
....................  
....................  

Configuration Fuses:
   Word  1: CE3C   IESO FCMEN HSPLL PLL5 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
