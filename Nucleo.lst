CCS PCH C Compiler, Version 4.105, 13255               24-Sep-12 12:34

               Filename: G:\Project\pic\CCS\MMA7455l\Nucleo.lst

               ROM used: 1972 bytes (3%)
                         Largest free fragment is 63564
               RAM used: 95 (2%) at main() level
                         104 (3%) worst case
               Stack:    3 locations

*
00000:  GOTO   040E
....................  
.................... #include "Nucleo.h" 
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
....................  
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... //#include "registros.h" 
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
003E6:  CLRF   FEA
003E8:  MOVLW  5F
003EA:  MOVWF  FE9
003EC:  MOVF   FEF,W
003EE:  BZ    040C
003F0:  MOVLW  03
003F2:  MOVWF  01
003F4:  CLRF   00
003F6:  DECFSZ 00,F
003F8:  BRA    03F6
003FA:  DECFSZ 01,F
003FC:  BRA    03F4
003FE:  MOVLW  3C
00400:  MOVWF  00
00402:  DECFSZ 00,F
00404:  BRA    0402
00406:  BRA    0408
00408:  DECFSZ FEF,F
0040A:  BRA    03F0
0040C:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "accelerometro.h" 
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int x; 
....................     int y; 
....................     int z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, long *buffer); 
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD	0x55 
.................... #define MEMORIA_CMD_VER_INFO	0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD			0x40 
.................... #define MEMORIA_CMD_READ_FILE	0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK 		0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON 			0x01 
.................... #define MEMORIA_OFF 		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT	12 
.................... #define MEMORIA_NAME_TERMINATOR 0x00 
.................... #define MEMORIA_DELIMITADOR 	0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE 	0x00 
.................... #define MEMORIA_LOW_PERFORMANCE 	0x40 
.................... //#define MEMORIA_OUT_TIME	65535	//modificar para colocar tiempos mas largos 
.................... //#define MEMORIA_COMPROBAR_ARCHIVO 
....................  
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char *filename, char modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char *data, unsigned int size); 
.................... char MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char *buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... //extern CONFIG_MMA7455 CONFIG; 
.................... //extern unsigned int32 tiempo_inicial, tiempo_final; 
.................... void setup_devices(){ 
*
0023A:  MOVLW  FF
0023C:  MOVWF  5E
....................    int error = -1; 
....................    /////////////configuracion del MMA7455//////////////// 
....................    //error = init_MMA(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = AD_init_adc(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = CP_init_ccp(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = MEMORIA_init(); 
....................    ////////////////////////////////////////////////////// 
....................    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
0023E:  MOVLW  10
00240:  MOVWF  5F
00242:  BRA    0130
....................    ////////////////////////////////////////////////////// 
....................    setup_psp(PSP_DISABLED); 
00244:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
00246:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
00248:  MOVLW  80
0024A:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
0024C:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0024E:  MOVLW  00
00250:  MOVWF  FCA
00252:  MOVLW  00
00254:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_ccp1(CCP_OFF); 
....................    setup_comparator(NC_NC_NC_NC); 
00256:  MOVLW  07
00258:  MOVWF  FB4
0025A:  MOVF   F92,W
0025C:  MOVWF  F92
0025E:  MOVLW  08
00260:  MOVWF  00
00262:  DECFSZ 00,F
00264:  BRA    0262
00266:  MOVF   FB4,W
00268:  BCF    FA1.6
....................    setup_vref(FALSE); 
0026A:  CLRF   FB5
....................    return; 
.................... } 
0026C:  GOTO   0564 (RETURN)
....................  
.................... void main() 
.................... { 
*
0040E:  CLRF   FF8
00410:  BCF    FD0.7
00412:  CLRF   FEA
00414:  CLRF   FE9
00416:  BCF    FB8.3
00418:  MOVLW  40
0041A:  MOVWF  FAF
0041C:  MOVLW  A6
0041E:  MOVWF  FAC
00420:  MOVLW  90
00422:  MOVWF  FAB
00424:  BSF    F94.3
00426:  BSF    F94.4
00428:  MOVLW  18
0042A:  MOVWF  FC8
0042C:  MOVLW  28
0042E:  MOVWF  FC6
00430:  BSF    FC7.7
00432:  BCF    FC7.6
00434:  BSF    F94.3
00436:  BSF    F94.4
00438:  MOVLW  18
0043A:  MOVWF  FC8
0043C:  MOVLW  28
0043E:  MOVWF  FC6
00440:  BSF    FC7.7
00442:  BCF    FC7.6
00444:  MOVF   FC1,W
00446:  ANDLW  C0
00448:  IORLW  0F
0044A:  MOVWF  FC1
0044C:  MOVLW  07
0044E:  MOVWF  FB4
00450:  CLRF   04
00452:  CLRF   05
00454:  CLRF   06
00456:  CLRF   07
00458:  MOVLW  4C
0045A:  MOVWF  08
0045C:  MOVLW  75
0045E:  MOVWF  09
00460:  MOVLW  6E
00462:  MOVWF  0A
00464:  MOVLW  65
00466:  MOVWF  0B
00468:  MOVLW  73
0046A:  MOVWF  0C
0046C:  CLRF   0D
0046E:  CLRF   0E
00470:  CLRF   0F
00472:  CLRF   10
00474:  CLRF   11
00476:  CLRF   12
00478:  MOVLW  4D
0047A:  MOVWF  13
0047C:  MOVLW  61
0047E:  MOVWF  14
00480:  MOVLW  72
00482:  MOVWF  15
00484:  MOVLW  74
00486:  MOVWF  16
00488:  MOVLW  65
0048A:  MOVWF  17
0048C:  MOVLW  73
0048E:  MOVWF  18
00490:  CLRF   19
00492:  CLRF   1A
00494:  CLRF   1B
00496:  CLRF   1C
00498:  CLRF   1D
0049A:  MOVLW  4D
0049C:  MOVWF  1E
0049E:  MOVLW  69
004A0:  MOVWF  1F
004A2:  MOVLW  E9
004A4:  MOVWF  20
004A6:  MOVLW  72
004A8:  MOVWF  21
004AA:  MOVLW  63
004AC:  MOVWF  22
004AE:  MOVLW  6F
004B0:  MOVWF  23
004B2:  MOVLW  6C
004B4:  MOVWF  24
004B6:  MOVLW  65
004B8:  MOVWF  25
004BA:  MOVLW  73
004BC:  MOVWF  26
004BE:  CLRF   27
004C0:  CLRF   28
004C2:  MOVLW  4A
004C4:  MOVWF  29
004C6:  MOVLW  75
004C8:  MOVWF  2A
004CA:  MOVLW  65
004CC:  MOVWF  2B
004CE:  MOVLW  76
004D0:  MOVWF  2C
004D2:  MOVLW  65
004D4:  MOVWF  2D
004D6:  MOVLW  73
004D8:  MOVWF  2E
004DA:  CLRF   2F
004DC:  CLRF   30
004DE:  CLRF   31
004E0:  CLRF   32
004E2:  CLRF   33
004E4:  MOVLW  56
004E6:  MOVWF  34
004E8:  MOVLW  69
004EA:  MOVWF  35
004EC:  MOVLW  65
004EE:  MOVWF  36
004F0:  MOVLW  72
004F2:  MOVWF  37
004F4:  MOVLW  6E
004F6:  MOVWF  38
004F8:  MOVLW  65
004FA:  MOVWF  39
004FC:  MOVLW  73
004FE:  MOVWF  3A
00500:  CLRF   3B
00502:  CLRF   3C
00504:  CLRF   3D
00506:  CLRF   3E
00508:  MOVLW  53
0050A:  MOVWF  3F
0050C:  MOVLW  E1
0050E:  MOVWF  40
00510:  MOVLW  62
00512:  MOVWF  41
00514:  MOVLW  61
00516:  MOVWF  42
00518:  MOVLW  64
0051A:  MOVWF  43
0051C:  MOVLW  6F
0051E:  MOVWF  44
00520:  CLRF   45
00522:  CLRF   46
00524:  CLRF   47
00526:  CLRF   48
00528:  CLRF   49
0052A:  MOVLW  44
0052C:  MOVWF  4A
0052E:  MOVLW  6F
00530:  MOVWF  4B
00532:  MOVLW  6D
00534:  MOVWF  4C
00536:  MOVLW  69
00538:  MOVWF  4D
0053A:  MOVLW  6E
0053C:  MOVWF  4E
0053E:  MOVLW  67
00540:  MOVWF  4F
00542:  MOVLW  6F
00544:  MOVWF  50
00546:  CLRF   51
00548:  CLRF   52
0054A:  CLRF   55
0054C:  CLRF   56
0054E:  MOVLW  01
00550:  MOVWF  57
00552:  MOVWF  58
00554:  MOVLW  0C
00556:  MOVWF  59
00558:  MOVLW  01
0055A:  MOVWF  5A
0055C:  MOVWF  5B
0055E:  MOVWF  5C
00560:  CLRF   5D
....................    byte dia = 0x01, mes = 0x01, ano = 0x0C,  
....................          hora = 0x01, min = 0x01, sec = 0x01, dow = 0x00;  
....................    setup_devices(); 
00562:  BRA    023A
....................    ds1307_set_date_time(dia, mes, ano, dow, hora, min, sec); 
00564:  MOVFF  57,5E
00568:  MOVFF  58,5F
0056C:  MOVFF  59,60
00570:  MOVFF  5D,61
00574:  MOVFF  5A,62
00578:  MOVFF  5B,63
0057C:  MOVFF  5C,64
00580:  BRA    0270
....................    // TODO: USER CODE!!   
....................    while(1){ 
....................       ds1307_get_date(dia, mes, ano, dow); 
....................       printf("fecha: %u/%u/%u dow: %u \n\r",dia, mes, ano, dow); 
*
0063E:  MOVLW  04
00640:  MOVWF  FF6
00642:  MOVLW  00
00644:  MOVWF  FF7
00646:  MOVLW  07
00648:  MOVWF  5E
0064A:  RCALL  0332
0064C:  MOVFF  57,5E
00650:  MOVLW  1B
00652:  MOVWF  5F
00654:  RCALL  037A
00656:  MOVLW  2F
00658:  BTFSS  F9E.4
0065A:  BRA    0658
0065C:  MOVWF  FAD
0065E:  MOVFF  58,5E
00662:  MOVLW  1B
00664:  MOVWF  5F
00666:  RCALL  037A
00668:  MOVLW  2F
0066A:  BTFSS  F9E.4
0066C:  BRA    066A
0066E:  MOVWF  FAD
00670:  MOVFF  59,5E
00674:  MOVLW  1B
00676:  MOVWF  5F
00678:  RCALL  037A
0067A:  MOVLW  13
0067C:  MOVWF  FF6
0067E:  MOVLW  00
00680:  MOVWF  FF7
00682:  MOVLW  06
00684:  MOVWF  5E
00686:  RCALL  0332
00688:  MOVFF  5D,5E
0068C:  MOVLW  1B
0068E:  MOVWF  5F
00690:  RCALL  037A
00692:  MOVLW  20
00694:  BTFSS  F9E.4
00696:  BRA    0694
00698:  MOVWF  FAD
0069A:  MOVLW  0A
0069C:  BTFSS  F9E.4
0069E:  BRA    069C
006A0:  MOVWF  FAD
006A2:  MOVLW  0D
006A4:  BTFSS  F9E.4
006A6:  BRA    06A4
006A8:  MOVWF  FAD
....................       delay_ms(99); 
006AA:  MOVLW  63
006AC:  MOVWF  5F
006AE:  RCALL  03E6
....................       ds1307_get_time(hora, min, sec); 
....................       printf("hora: %u:%u:%u\n\r", hora, min, sec); 
*
00756:  MOVLW  20
00758:  MOVWF  FF6
0075A:  MOVLW  00
0075C:  MOVWF  FF7
0075E:  MOVLW  06
00760:  MOVWF  5E
00762:  RCALL  0332
00764:  MOVFF  5A,5E
00768:  MOVLW  1B
0076A:  MOVWF  5F
0076C:  RCALL  037A
0076E:  MOVLW  3A
00770:  BTFSS  F9E.4
00772:  BRA    0770
00774:  MOVWF  FAD
00776:  MOVFF  5B,5E
0077A:  MOVLW  1B
0077C:  MOVWF  5F
0077E:  RCALL  037A
00780:  MOVLW  3A
00782:  BTFSS  F9E.4
00784:  BRA    0782
00786:  MOVWF  FAD
00788:  MOVFF  5C,5E
0078C:  MOVLW  1B
0078E:  MOVWF  5F
00790:  RCALL  037A
00792:  MOVLW  0A
00794:  BTFSS  F9E.4
00796:  BRA    0794
00798:  MOVWF  FAD
0079A:  MOVLW  0D
0079C:  BTFSS  F9E.4
0079E:  BRA    079C
007A0:  MOVWF  FAD
....................       delay_ms(900); 
007A2:  MOVLW  04
007A4:  MOVWF  5E
007A6:  MOVLW  E1
007A8:  MOVWF  5F
007AA:  RCALL  03E6
007AC:  DECFSZ 5E,F
007AE:  BRA    07A6
....................    } 
007B0:  BRA    0582
.................... } 
....................  
....................  
.................... #include "Nucleo.h" 
.................... #ifndef NUCLEO_H 
007B2:  SLEEP 
.................... #define NUCLEO_H 
....................  
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... //#include "registros.h" 
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV21                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES CCP2C1 
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FORCE_HW, RESTART_WDT)                    //directiva de compilador par ale uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
00032:  MOVLW  08
00034:  MOVWF  01
00036:  BRA    0038
00038:  BRA    003A
0003A:  BCF    F8A.1
0003C:  BCF    F93.1
0003E:  BRA    0040
00040:  BRA    0042
00042:  NOP   
00044:  RLCF   66,F
00046:  BCF    F8A.0
00048:  BTFSC  FD8.0
0004A:  BSF    F93.0
0004C:  BTFSS  FD8.0
0004E:  BCF    F93.0
00050:  BSF    F93.1
00052:  BTFSS  F81.1
00054:  BRA    0052
00056:  DECFSZ 01,F
00058:  BRA    0036
0005A:  BRA    005C
0005C:  BRA    005E
0005E:  BCF    F8A.1
00060:  BCF    F93.1
00062:  NOP   
00064:  BSF    F93.0
00066:  BRA    0068
00068:  BRA    006A
0006A:  NOP   
0006C:  BRA    006E
0006E:  BRA    0070
00070:  NOP   
00072:  BSF    F93.1
00074:  BTFSS  F81.1
00076:  BRA    0074
00078:  CLRF   01
0007A:  BRA    007C
0007C:  BRA    007E
0007E:  NOP   
00080:  BTFSC  F81.0
00082:  BSF    01.0
00084:  BCF    F8A.1
00086:  BCF    F93.1
00088:  BCF    F8A.0
0008A:  BCF    F93.0
0008C:  RETLW  00
0008E:  MOVLW  08
00090:  MOVWF  63
00092:  MOVFF  00,64
00096:  BSF    F93.0
00098:  BRA    009A
0009A:  BRA    009C
0009C:  NOP   
0009E:  BSF    F93.1
000A0:  BTFSS  F81.1
000A2:  BRA    00A0
000A4:  BTFSC  F81.0
000A6:  BSF    FD8.0
000A8:  BTFSS  F81.0
000AA:  BCF    FD8.0
000AC:  RLCF   01,F
000AE:  BRA    00B0
000B0:  BRA    00B2
000B2:  BCF    F93.1
000B4:  BCF    F8A.1
000B6:  DECFSZ 63,F
000B8:  BRA    0096
000BA:  BSF    F93.0
000BC:  BRA    00BE
000BE:  BRA    00C0
000C0:  NOP   
000C2:  BCF    F8A.0
000C4:  MOVF   64,W
000C6:  BTFSS  FD8.2
000C8:  BCF    F93.0
000CA:  NOP   
000CC:  BSF    F93.1
000CE:  BTFSS  F81.1
000D0:  BRA    00CE
000D2:  BRA    00D4
000D4:  BRA    00D6
000D6:  BCF    F8A.1
000D8:  BCF    F93.1
000DA:  BRA    00DC
000DC:  BRA    00DE
000DE:  NOP   
000E0:  BCF    F8A.0
000E2:  BCF    F93.0
000E4:  RETLW  00
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
00130:  CLRF   60
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
00132:  BCF    FF2.6
00134:  BCF    FF2.7
00136:  BTFSC  FF2.7
00138:  BRA    0134
.................... #endif 
....................  
....................    i2c_start(); 
0013A:  BSF    F93.0
0013C:  BRA    013E
0013E:  BRA    0140
00140:  BSF    F93.1
00142:  BRA    0144
00144:  BRA    0146
00146:  NOP   
00148:  BCF    F8A.0
0014A:  BCF    F93.0
0014C:  BRA    014E
0014E:  BRA    0150
00150:  BCF    F8A.1
00152:  BCF    F93.1
....................    i2c_write(0xD0); 
00154:  MOVLW  D0
00156:  MOVWF  66
00158:  RCALL  0032
....................    i2c_write(0x00); 
0015A:  CLRF   66
0015C:  RCALL  0032
....................    i2c_start(); 
0015E:  BSF    F93.0
00160:  BRA    0162
00162:  BRA    0164
00164:  BSF    F93.1
00166:  BRA    0168
00168:  BRA    016A
0016A:  NOP   
0016C:  BTFSS  F81.1
0016E:  BRA    016C
00170:  BCF    F8A.0
00172:  BCF    F93.0
00174:  BRA    0176
00176:  BRA    0178
00178:  BCF    F8A.1
0017A:  BCF    F93.1
....................    i2c_write(0xD1); 
0017C:  MOVLW  D1
0017E:  MOVWF  66
00180:  RCALL  0032
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
00182:  CLRF   00
00184:  RCALL  008E
00186:  MOVFF  01,61
0018A:  MOVFF  01,63
0018E:  RCALL  00E6
00190:  MOVFF  01,60
....................    i2c_stop(); 
00194:  BCF    F93.0
00196:  NOP   
00198:  BSF    F93.1
0019A:  BTFSS  F81.1
0019C:  BRA    019A
0019E:  BRA    01A0
001A0:  BRA    01A2
001A2:  BRA    01A4
001A4:  NOP   
001A6:  BSF    F93.0
001A8:  BRA    01AA
001AA:  BRA    01AC
....................    seconds &= 0x7F; 
001AC:  BCF    60.7
....................  
....................    delay_us(3); 
001AE:  MOVLW  02
001B0:  MOVWF  00
001B2:  DECFSZ 00,F
001B4:  BRA    01B2
....................  
....................    i2c_start(); 
001B6:  BSF    F93.0
001B8:  BRA    01BA
001BA:  BRA    01BC
001BC:  BSF    F93.1
001BE:  BRA    01C0
001C0:  BRA    01C2
001C2:  NOP   
001C4:  BCF    F8A.0
001C6:  BCF    F93.0
001C8:  BRA    01CA
001CA:  BRA    01CC
001CC:  BCF    F8A.1
001CE:  BCF    F93.1
....................    i2c_write(0xD0); 
001D0:  MOVLW  D0
001D2:  MOVWF  66
001D4:  RCALL  0032
....................    i2c_write(0x00); 
001D6:  CLRF   66
001D8:  RCALL  0032
....................    i2c_write(ds1307_bin2bcd(seconds)); 
001DA:  MOVFF  60,65
001DE:  RCALL  010C
001E0:  MOVFF  01,61
001E4:  MOVFF  01,66
001E8:  RCALL  0032
....................    i2c_start(); 
001EA:  BSF    F93.0
001EC:  BRA    01EE
001EE:  BRA    01F0
001F0:  BSF    F93.1
001F2:  BRA    01F4
001F4:  BRA    01F6
001F6:  NOP   
001F8:  BTFSS  F81.1
001FA:  BRA    01F8
001FC:  BCF    F8A.0
001FE:  BCF    F93.0
00200:  BRA    0202
00202:  BRA    0204
00204:  BCF    F8A.1
00206:  BCF    F93.1
....................    i2c_write(0xD0); 
00208:  MOVLW  D0
0020A:  MOVWF  66
0020C:  RCALL  0032
....................    i2c_write(0x07); 
0020E:  MOVLW  07
00210:  MOVWF  66
00212:  RCALL  0032
....................    i2c_write(val); 
00214:  MOVFF  5F,66
00218:  RCALL  0032
....................    i2c_stop(); 
0021A:  BCF    F93.0
0021C:  NOP   
0021E:  BSF    F93.1
00220:  BTFSS  F81.1
00222:  BRA    0220
00224:  BRA    0226
00226:  BRA    0228
00228:  BRA    022A
0022A:  NOP   
0022C:  BSF    F93.0
0022E:  BRA    0230
00230:  BRA    0232
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
00232:  MOVLW  C0
00234:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
00236:  GOTO   0244 (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
00270:  BCF    FF2.6
00272:  BCF    FF2.7
00274:  BTFSC  FF2.7
00276:  BRA    0272
.................... #endif 
....................  
....................   sec &= 0x7F; 
00278:  BCF    64.7
....................   hr &= 0x3F; 
0027A:  MOVLW  3F
0027C:  ANDWF  62,F
....................  
....................   i2c_start(); 
0027E:  BSF    F93.0
00280:  BRA    0282
00282:  BRA    0284
00284:  BSF    F93.1
00286:  BRA    0288
00288:  BRA    028A
0028A:  NOP   
0028C:  BCF    F8A.0
0028E:  BCF    F93.0
00290:  BRA    0292
00292:  BRA    0294
00294:  BCF    F8A.1
00296:  BCF    F93.1
....................   i2c_write(0xD0); 
00298:  MOVLW  D0
0029A:  MOVWF  66
0029C:  RCALL  0032
....................   i2c_write(0x00); 
0029E:  CLRF   66
002A0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(sec)); 
002A2:  MOVFF  64,65
002A6:  RCALL  010C
002A8:  MOVFF  01,65
002AC:  MOVFF  01,66
002B0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(min)); 
002B2:  MOVFF  63,65
002B6:  RCALL  010C
002B8:  MOVFF  01,65
002BC:  MOVFF  01,66
002C0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(hr)); 
002C2:  MOVFF  62,65
002C6:  RCALL  010C
002C8:  MOVFF  01,65
002CC:  MOVFF  01,66
002D0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(dow)); 
002D2:  MOVFF  61,65
002D6:  RCALL  010C
002D8:  MOVFF  01,65
002DC:  MOVFF  01,66
002E0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(day)); 
002E2:  MOVFF  5E,65
002E6:  RCALL  010C
002E8:  MOVFF  01,65
002EC:  MOVFF  01,66
002F0:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(mth)); 
002F2:  MOVFF  5F,65
002F6:  RCALL  010C
002F8:  MOVFF  01,65
002FC:  MOVFF  01,66
00300:  RCALL  0032
....................   i2c_write(ds1307_bin2bcd(year)); 
00302:  MOVFF  60,65
00306:  RCALL  010C
00308:  MOVFF  01,65
0030C:  MOVFF  01,66
00310:  RCALL  0032
....................   i2c_stop(); 
00312:  BCF    F93.0
00314:  NOP   
00316:  BSF    F93.1
00318:  BTFSS  F81.1
0031A:  BRA    0318
0031C:  BRA    031E
0031E:  BRA    0320
00320:  BRA    0322
00322:  NOP   
00324:  BSF    F93.0
00326:  BRA    0328
00328:  BRA    032A
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0032A:  MOVLW  C0
0032C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
0032E:  GOTO   0582 (RETURN)
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
00582:  BCF    FF2.6
00584:  BCF    FF2.7
00586:  BTFSC  FF2.7
00588:  BRA    0584
.................... #endif 
....................  
....................   i2c_start(); 
0058A:  BSF    F93.0
0058C:  BRA    058E
0058E:  BRA    0590
00590:  BSF    F93.1
00592:  BRA    0594
00594:  BRA    0596
00596:  NOP   
00598:  BCF    F8A.0
0059A:  BCF    F93.0
0059C:  BRA    059E
0059E:  BRA    05A0
005A0:  BCF    F8A.1
005A2:  BCF    F93.1
....................   i2c_write(0xD0); 
005A4:  MOVLW  D0
005A6:  MOVWF  66
005A8:  RCALL  0032
....................   i2c_write(0x03); 
005AA:  MOVLW  03
005AC:  MOVWF  66
005AE:  RCALL  0032
....................   i2c_start(); 
005B0:  BSF    F93.0
005B2:  BRA    05B4
005B4:  BRA    05B6
005B6:  BSF    F93.1
005B8:  BRA    05BA
005BA:  BRA    05BC
005BC:  NOP   
005BE:  BTFSS  F81.1
005C0:  BRA    05BE
005C2:  BCF    F8A.0
005C4:  BCF    F93.0
005C6:  BRA    05C8
005C8:  BRA    05CA
005CA:  BCF    F8A.1
005CC:  BCF    F93.1
....................   i2c_write(0xD1); 
005CE:  MOVLW  D1
005D0:  MOVWF  66
005D2:  RCALL  0032
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
005D4:  MOVLW  01
005D6:  MOVWF  00
005D8:  RCALL  008E
005DA:  MOVF   01,W
005DC:  ANDLW  7F
005DE:  MOVWF  5E
005E0:  MOVWF  63
005E2:  RCALL  00E6
005E4:  MOVFF  01,5D
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
005E8:  MOVLW  01
005EA:  MOVWF  00
005EC:  RCALL  008E
005EE:  MOVF   01,W
005F0:  ANDLW  3F
005F2:  MOVWF  5E
005F4:  MOVWF  63
005F6:  RCALL  00E6
005F8:  MOVFF  01,57
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
005FC:  MOVLW  01
005FE:  MOVWF  00
00600:  RCALL  008E
00602:  MOVF   01,W
00604:  ANDLW  1F
00606:  MOVWF  5E
00608:  MOVWF  63
0060A:  RCALL  00E6
0060C:  MOVFF  01,58
....................   year = ds1307_bcd2bin(i2c_read(0)); 
00610:  CLRF   00
00612:  RCALL  008E
00614:  MOVFF  01,5E
00618:  MOVFF  01,63
0061C:  RCALL  00E6
0061E:  MOVFF  01,59
....................   i2c_stop(); 
00622:  BCF    F93.0
00624:  NOP   
00626:  BSF    F93.1
00628:  BTFSS  F81.1
0062A:  BRA    0628
0062C:  BRA    062E
0062E:  BRA    0630
00630:  BRA    0632
00632:  NOP   
00634:  BSF    F93.0
00636:  BRA    0638
00638:  BRA    063A
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0063A:  MOVLW  C0
0063C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
006B0:  BCF    FF2.6
006B2:  BCF    FF2.7
006B4:  BTFSC  FF2.7
006B6:  BRA    06B2
.................... #endif 
....................  
....................   i2c_start(); 
006B8:  BSF    F93.0
006BA:  BRA    06BC
006BC:  BRA    06BE
006BE:  BSF    F93.1
006C0:  BRA    06C2
006C2:  BRA    06C4
006C4:  NOP   
006C6:  BCF    F8A.0
006C8:  BCF    F93.0
006CA:  BRA    06CC
006CC:  BRA    06CE
006CE:  BCF    F8A.1
006D0:  BCF    F93.1
....................   i2c_write(0xD0); 
006D2:  MOVLW  D0
006D4:  MOVWF  66
006D6:  RCALL  0032
....................   i2c_write(0x00); 
006D8:  CLRF   66
006DA:  RCALL  0032
....................   i2c_start(); 
006DC:  BSF    F93.0
006DE:  BRA    06E0
006E0:  BRA    06E2
006E2:  BSF    F93.1
006E4:  BRA    06E6
006E6:  BRA    06E8
006E8:  NOP   
006EA:  BTFSS  F81.1
006EC:  BRA    06EA
006EE:  BCF    F8A.0
006F0:  BCF    F93.0
006F2:  BRA    06F4
006F4:  BRA    06F6
006F6:  BCF    F8A.1
006F8:  BCF    F93.1
....................   i2c_write(0xD1); 
006FA:  MOVLW  D1
006FC:  MOVWF  66
006FE:  RCALL  0032
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
00700:  MOVLW  01
00702:  MOVWF  00
00704:  RCALL  008E
00706:  MOVF   01,W
00708:  ANDLW  7F
0070A:  MOVWF  5E
0070C:  MOVWF  63
0070E:  RCALL  00E6
00710:  MOVFF  01,5C
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
00714:  MOVLW  01
00716:  MOVWF  00
00718:  RCALL  008E
0071A:  MOVF   01,W
0071C:  ANDLW  7F
0071E:  MOVWF  5E
00720:  MOVWF  63
00722:  RCALL  00E6
00724:  MOVFF  01,5B
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
00728:  CLRF   00
0072A:  RCALL  008E
0072C:  MOVF   01,W
0072E:  ANDLW  3F
00730:  MOVWF  5E
00732:  MOVWF  63
00734:  RCALL  00E6
00736:  MOVFF  01,5A
....................   i2c_stop(); 
0073A:  BCF    F93.0
0073C:  NOP   
0073E:  BSF    F93.1
00740:  BTFSS  F81.1
00742:  BRA    0740
00744:  BRA    0746
00746:  BRA    0748
00748:  BRA    074A
0074A:  NOP   
0074C:  BSF    F93.0
0074E:  BRA    0750
00750:  BRA    0752
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
00752:  MOVLW  C0
00754:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
0010C:  MOVFF  65,66
....................   retval = 0; 
00110:  CLRF   67
....................   while(1){ 
....................     if(temp >= 10){ 
00112:  MOVF   66,W
00114:  SUBLW  09
00116:  BC    0122
....................       temp -= 10; 
00118:  MOVLW  0A
0011A:  SUBWF  66,F
....................       retval += 0x10; 
0011C:  MOVLW  10
0011E:  ADDWF  67,F
....................     }else{ 
00120:  BRA    0128
....................       retval += temp; 
00122:  MOVF   66,W
00124:  ADDWF  67,F
....................       break; 
00126:  BRA    012A
....................     } 
....................   } 
00128:  BRA    0112
....................   return(retval); 
0012A:  MOVFF  67,01
.................... } 
0012E:  RETLW  00
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
000E6:  MOVFF  63,64
....................   temp >>= 1; 
000EA:  BCF    FD8.0
000EC:  RRCF   64,F
....................   temp &= 0x78; 
000EE:  MOVLW  78
000F0:  ANDWF  64,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
000F2:  RRCF   64,W
000F4:  MOVWF  00
000F6:  RRCF   00,F
000F8:  MOVLW  3F
000FA:  ANDWF  00,F
000FC:  MOVF   00,W
000FE:  ADDWF  64,W
00100:  MOVWF  65
00102:  MOVF   63,W
00104:  ANDLW  0F
00106:  ADDWF  65,W
00108:  MOVWF  01
.................... } 
0010A:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
