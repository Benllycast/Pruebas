CCS PCH C Compiler, Version 4.110, 5967               20-Dic-12 09:07

               Filename: C:\Documents and Settings\BENJAMIN\Escritorio\MMA7455l\Nucleo.lst

               ROM used: 6578 bytes (20%)
                         Largest free fragment is 26186
               RAM used: 181 (9%) at main() level
                         211 (10%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  GOTO   180C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   01DE
0060:  BTFSS  F9D.2
0062:  GOTO   006C
0066:  BTFSC  F9E.2
0068:  GOTO   01E6
006C:  BTFSS  FA0.0
006E:  GOTO   0078
0072:  BTFSC  FA1.0
0074:  GOTO   0260
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
*
17E2:  CLRF   FEA
17E4:  MOVLW  B5
17E6:  MOVWF  FE9
17E8:  MOVF   FEF,W
17EA:  BZ    1808
17EC:  MOVLW  07
17EE:  MOVWF  01
17F0:  CLRF   00
17F2:  DECFSZ 00,F
17F4:  BRA    17F2
17F6:  DECFSZ 01,F
17F8:  BRA    17F0
17FA:  MOVLW  C7
17FC:  MOVWF  00
17FE:  DECFSZ 00,F
1800:  BRA    17FE
1802:  NOP   
1804:  DECFSZ FEF,F
1806:  BRA    17EC
1808:  GOTO   19AE (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
*
032E:  MOVLW  08
0330:  MOVWF  01
0332:  MOVLW  07
0334:  MOVWF  00
0336:  DECFSZ 00,F
0338:  BRA    0336
033A:  BCF    F8A.1
033C:  BCF    F93.1
033E:  MOVLW  07
0340:  MOVWF  00
0342:  DECFSZ 00,F
0344:  BRA    0342
0346:  RLCF   xB8,F
0348:  BCF    F8A.0
034A:  BTFSC  FD8.0
034C:  BSF    F93.0
034E:  BTFSS  FD8.0
0350:  BCF    F93.0
0352:  BSF    F93.1
0354:  BTFSS  F81.1
0356:  BRA    0354
0358:  DECFSZ 01,F
035A:  BRA    0332
035C:  MOVLW  07
035E:  MOVWF  00
0360:  DECFSZ 00,F
0362:  BRA    0360
0364:  BCF    F8A.1
0366:  BCF    F93.1
0368:  NOP   
036A:  BSF    F93.0
036C:  MOVLW  07
036E:  MOVWF  00
0370:  DECFSZ 00,F
0372:  BRA    0370
0374:  MOVLW  07
0376:  MOVWF  00
0378:  DECFSZ 00,F
037A:  BRA    0378
037C:  BSF    F93.1
037E:  BTFSS  F81.1
0380:  BRA    037E
0382:  CLRF   01
0384:  MOVLW  07
0386:  MOVWF  00
0388:  DECFSZ 00,F
038A:  BRA    0388
038C:  BTFSC  F81.0
038E:  BSF    01.0
0390:  BCF    F8A.1
0392:  BCF    F93.1
0394:  BCF    F8A.0
0396:  BCF    F93.0
0398:  RETLW  00
039A:  MOVLW  08
039C:  MOVWF  xB9
039E:  MOVFF  00,BA
03A2:  BSF    F93.0
03A4:  MOVLW  07
03A6:  MOVWF  00
03A8:  DECFSZ 00,F
03AA:  BRA    03A8
03AC:  BSF    F93.1
03AE:  BTFSS  F81.1
03B0:  BRA    03AE
03B2:  BTFSC  F81.0
03B4:  BSF    FD8.0
03B6:  BTFSS  F81.0
03B8:  BCF    FD8.0
03BA:  RLCF   01,F
03BC:  MOVLW  07
03BE:  MOVWF  00
03C0:  DECFSZ 00,F
03C2:  BRA    03C0
03C4:  BCF    F93.1
03C6:  BCF    F8A.1
03C8:  DECFSZ xB9,F
03CA:  BRA    03A2
03CC:  BSF    F93.0
03CE:  MOVLW  07
03D0:  MOVWF  00
03D2:  DECFSZ 00,F
03D4:  BRA    03D2
03D6:  BCF    F8A.0
03D8:  MOVF   xBA,W
03DA:  BTFSS  FD8.2
03DC:  BCF    F93.0
03DE:  NOP   
03E0:  BSF    F93.1
03E2:  BTFSS  F81.1
03E4:  BRA    03E2
03E6:  MOVLW  07
03E8:  MOVWF  00
03EA:  DECFSZ 00,F
03EC:  BRA    03EA
03EE:  BCF    F8A.1
03F0:  BCF    F93.1
03F2:  MOVLW  07
03F4:  MOVWF  00
03F6:  DECFSZ 00,F
03F8:  BRA    03F6
03FA:  BCF    F8A.0
03FC:  BCF    F93.0
03FE:  RETLW  00
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_OK	0 
.................... #define USB_NO_ENUMERATED 1 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... #endif 
....................  
.................... #include "accelerometro.h" 
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int16 x; 
....................     int16 y; 
....................     int16 z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, int16 *buffer); 
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD	0x55 
.................... #define MEMORIA_CMD_VER_INFO	0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD			0x40 
.................... #define MEMORIA_CMD_READ_FILE	0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK 		0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON 			0x01 
.................... #define MEMORIA_OFF 		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT	12 
.................... #define MEMORIA_NAME_TERMINATOR 0x00 
.................... #define MEMORIA_DELIMITADOR 	0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE 	0x00 
.................... #define MEMORIA_LOW_PERFORMANCE 	0x40 
.................... //#define MEMORIA_OUT_TIME	65535	//modificar para colocar tiempos mas largos 
.................... //#define MEMORIA_COMPROBAR_ARCHIVO 
....................  
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char *filename, char modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char *data, unsigned int size); 
.................... char MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char *buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define MAX 40; 
.................... //extern CONFIG_MMA7455 CONFIG; 
.................... //extern unsigned int32 tiempo_inicial, tiempo_final; 
.................... byte hr = 0, min = 0, sec = 0, dia = 0, mes = 0, anio = 0, dow = 0; 
.................... int16 valor_16b; 
.................... int32 valor_32b; 
.................... char mensaje[40]; 
.................... enum modulos {ACC,VEL,REV,ACCM,SENP,CCP1,CCP2}; 
.................... const char mod_to_str [][*] = {"ACC","VEL","REV","ACCM","SENP","CCP1","CCP2"}; 
.................... void leer_aceleracion(void); 
.................... void leer_velocidad(void); 
.................... void leer_revoluciones(void); 
.................... void leer_accelerometro(void); 
.................... void leer_sensor_puertas(void); 
.................... void leer_ccp1(void); 
.................... void leer_ccp2(void); 
....................  
.................... void setup_devices(){ 
*
06AC:  MOVLW  FF
06AE:  MOVWF  xB4
....................    int error = -1; 
....................    /////////////configuracion del MMA7455//////////////// 
....................    //error = init_MMA(); 
....................    ////////////////////////////////////////////////////// 
....................    error = AD_init_adc(); 
06B0:  BRA    02DA
06B2:  MOVFF  01,B4
....................    ////////////////////////////////////////////////////// 
....................    error = CP_init_ccp(); 
06B6:  BRA    02F8
06B8:  MOVFF  01,B4
....................    ////////////////////////////////////////////////////// 
....................    //error = MEMORIA_init(); 
....................    ////////////////////////////////////////////////////// 
....................    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
06BC:  MOVLW  10
06BE:  MOVWF  xB5
06C0:  BRA    044C
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    //error = COM_init(); 
....................    ////////////////////////////////////////////////////// 
....................    setup_psp(PSP_DISABLED); 
06C2:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
06C4:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
06C6:  MOVLW  80
06C8:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
06CA:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
06CC:  MOVLW  00
06CE:  MOVWF  FCA
06D0:  MOVLW  00
06D2:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_ccp1(CCP_OFF); 
....................    setup_comparator(NC_NC_NC_NC); 
06D4:  MOVLW  07
06D6:  MOVWF  FB4
06D8:  MOVF   F92,W
06DA:  MOVWF  F92
06DC:  MOVLW  13
06DE:  MOVWF  00
06E0:  DECFSZ 00,F
06E2:  BRA    06E0
06E4:  BRA    06E6
06E6:  MOVF   FB4,W
06E8:  BCF    FA1.6
....................    setup_vref(FALSE); 
06EA:  CLRF   FB5
....................    printf("usb error =%d\n\r", error); 
06EC:  MOVLW  24
06EE:  MOVWF  FF6
06F0:  MOVLW  01
06F2:  MOVWF  FF7
06F4:  MOVLW  0B
06F6:  MOVWF  xB5
06F8:  BRA    0590
06FA:  MOVFF  B4,B5
06FE:  MOVLW  1F
0700:  MOVWF  xB6
0702:  BRA    05DA
0704:  MOVLW  0A
0706:  BTFSS  F9E.4
0708:  BRA    0706
070A:  MOVWF  FAD
070C:  MOVLW  0D
070E:  BTFSS  F9E.4
0710:  BRA    070E
0712:  MOVWF  FAD
....................    return; 
.................... } 
0714:  GOTO   1994 (RETURN)
....................  
.................... void main() 
.................... { 
*
180C:  CLRF   FF8
180E:  BCF    FD0.7
1810:  BSF    07.7
1812:  CLRF   FEA
1814:  CLRF   FE9
1816:  BSF    FB8.3
1818:  MOVLW  70
181A:  MOVWF  FAF
181C:  MOVLW  02
181E:  MOVWF  FB0
1820:  MOVLW  A6
1822:  MOVWF  FAC
1824:  MOVLW  90
1826:  MOVWF  FAB
1828:  CLRF   1B
182A:  CLRF   1C
182C:  CLRF   1D
182E:  CLRF   1E
1830:  CLRF   1F
1832:  CLRF   20
1834:  CLRF   21
1836:  CLRF   51
1838:  CLRF   50
183A:  BSF    FB8.3
183C:  MOVLW  70
183E:  MOVWF  FAF
1840:  MOVLW  02
1842:  MOVWF  FB0
1844:  MOVLW  A6
1846:  MOVWF  FAC
1848:  MOVLW  90
184A:  MOVWF  FAB
184C:  CLRF   xA2
184E:  CLRF   xA1
1850:  BSF    FB8.3
1852:  MOVLW  70
1854:  MOVWF  FAF
1856:  MOVLW  02
1858:  MOVWF  FB0
185A:  MOVLW  A6
185C:  MOVWF  FAC
185E:  MOVLW  90
1860:  MOVWF  FAB
1862:  MOVLW  CD
1864:  MOVWF  xA7
1866:  MOVLW  05
1868:  MOVWF  xA8
186A:  MOVWF  xA9
186C:  MOVLW  FF
186E:  MOVWF  xAA
1870:  CLRF   xAB
1872:  CLRF   xAF
1874:  CLRF   xAE
1876:  CLRF   xAD
1878:  CLRF   xAC
187A:  CLRF   xB3
187C:  CLRF   xB2
187E:  CLRF   xB1
1880:  CLRF   xB0
1882:  MOVF   FC1,W
1884:  ANDLW  C0
1886:  IORLW  0F
1888:  MOVWF  FC1
188A:  MOVLW  07
188C:  MOVWF  FB4
188E:  CLRF   19
1890:  CLRF   1A
1892:  CLRF   52
1894:  CLRF   53
1896:  MOVLW  4C
1898:  MOVWF  54
189A:  MOVLW  75
189C:  MOVWF  55
189E:  MOVLW  6E
18A0:  MOVWF  56
18A2:  MOVLW  65
18A4:  MOVWF  57
18A6:  MOVLW  73
18A8:  MOVWF  58
18AA:  CLRF   59
18AC:  CLRF   5A
18AE:  CLRF   5B
18B0:  CLRF   5C
18B2:  CLRF   5D
18B4:  CLRF   5E
18B6:  MOVLW  4D
18B8:  MOVWF  5F
18BA:  MOVLW  61
18BC:  MOVWF  x60
18BE:  MOVLW  72
18C0:  MOVWF  x61
18C2:  MOVLW  74
18C4:  MOVWF  x62
18C6:  MOVLW  65
18C8:  MOVWF  x63
18CA:  MOVLW  73
18CC:  MOVWF  x64
18CE:  CLRF   x65
18D0:  CLRF   x66
18D2:  CLRF   x67
18D4:  CLRF   x68
18D6:  CLRF   x69
18D8:  MOVLW  4D
18DA:  MOVWF  x6A
18DC:  MOVLW  69
18DE:  MOVWF  x6B
18E0:  MOVLW  E9
18E2:  MOVWF  x6C
18E4:  MOVLW  72
18E6:  MOVWF  x6D
18E8:  MOVLW  63
18EA:  MOVWF  x6E
18EC:  MOVLW  6F
18EE:  MOVWF  x6F
18F0:  MOVLW  6C
18F2:  MOVWF  x70
18F4:  MOVLW  65
18F6:  MOVWF  x71
18F8:  MOVLW  73
18FA:  MOVWF  x72
18FC:  CLRF   x73
18FE:  CLRF   x74
1900:  MOVLW  4A
1902:  MOVWF  x75
1904:  MOVLW  75
1906:  MOVWF  x76
1908:  MOVLW  65
190A:  MOVWF  x77
190C:  MOVLW  76
190E:  MOVWF  x78
1910:  MOVLW  65
1912:  MOVWF  x79
1914:  MOVLW  73
1916:  MOVWF  x7A
1918:  CLRF   x7B
191A:  CLRF   x7C
191C:  CLRF   x7D
191E:  CLRF   x7E
1920:  CLRF   x7F
1922:  MOVLW  56
1924:  MOVWF  x80
1926:  MOVLW  69
1928:  MOVWF  x81
192A:  MOVLW  65
192C:  MOVWF  x82
192E:  MOVLW  72
1930:  MOVWF  x83
1932:  MOVLW  6E
1934:  MOVWF  x84
1936:  MOVLW  65
1938:  MOVWF  x85
193A:  MOVLW  73
193C:  MOVWF  x86
193E:  CLRF   x87
1940:  CLRF   x88
1942:  CLRF   x89
1944:  CLRF   x8A
1946:  MOVLW  53
1948:  MOVWF  x8B
194A:  MOVLW  E1
194C:  MOVWF  x8C
194E:  MOVLW  62
1950:  MOVWF  x8D
1952:  MOVLW  61
1954:  MOVWF  x8E
1956:  MOVLW  64
1958:  MOVWF  x8F
195A:  MOVLW  6F
195C:  MOVWF  x90
195E:  CLRF   x91
1960:  CLRF   x92
1962:  CLRF   x93
1964:  CLRF   x94
1966:  CLRF   x95
1968:  MOVLW  44
196A:  MOVWF  x96
196C:  MOVLW  6F
196E:  MOVWF  x97
1970:  MOVLW  6D
1972:  MOVWF  x98
1974:  MOVLW  69
1976:  MOVWF  x99
1978:  MOVLW  6E
197A:  MOVWF  x9A
197C:  MOVLW  67
197E:  MOVWF  x9B
1980:  MOVLW  6F
1982:  MOVWF  x9C
1984:  CLRF   x9D
1986:  CLRF   x9E
1988:  CLRF   xA3
198A:  CLRF   xA4
198C:  CLRF   xA5
198E:  CLRF   xA6
....................    //char* mensaje = "hola mundo\n\r"; 
....................    //int16 value = 0; 
....................     
....................    setup_devices(); 
1990:  GOTO   06AC
....................    //ds1307_set_date_time(0x0c, 0x0a, 0x0c, 0x01, 0x0a, 0x28, 0x00); 
....................    while(1){ 
....................       /* 
....................       if(COM_sense() != USB_NO_ATTACHED){ 
....................          COM_send(mensaje, strlen(mensaje)); 
....................          printf("%s", mensaje); 
....................       }else 
....................          printf("esperando a conectar....\n\r"); 
....................       */ 
....................       leer_aceleracion(); 
1994:  GOTO   0914
....................       leer_velocidad(); 
1998:  GOTO   0B7E
....................       leer_revoluciones(); 
199C:  GOTO   0E0E
....................       leer_ccp1(); 
19A0:  BRA    126E
....................       leer_ccp2(); 
19A2:  BRA    1528
....................       delay_ms(500); 
19A4:  MOVLW  02
19A6:  MOVWF  xB4
19A8:  MOVLW  FA
19AA:  MOVWF  xB5
19AC:  BRA    17E2
19AE:  DECFSZ xB4,F
19B0:  BRA    19A8
....................    } 
19B2:  BRA    1994
.................... } 
....................  
....................  
.................... void leer_aceleracion(void){ 
....................    ds1307_get_time(hr, min, sec); 
19B4:  SLEEP 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_ACCELERACION , &valor_16b); 
*
0AAE:  MOVLW  01
0AB0:  MOVWF  xB4
0AB2:  CLRF   xB6
0AB4:  MOVLW  22
0AB6:  MOVWF  xB5
0AB8:  RCALL  0718
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%s val:%Ld",dia, mes, anio, hr, min, sec, mod_to_str[ACC], valor_16b); 
0ABA:  CLRF   51
0ABC:  MOVLW  28
0ABE:  MOVWF  50
0AC0:  MOVFF  1E,B4
0AC4:  MOVLW  1B
0AC6:  MOVWF  xB5
0AC8:  RCALL  0780
0ACA:  MOVLW  2F
0ACC:  MOVWF  xC2
0ACE:  RCALL  0764
0AD0:  MOVFF  1F,B4
0AD4:  MOVLW  1B
0AD6:  MOVWF  xB5
0AD8:  RCALL  0780
0ADA:  MOVLW  2F
0ADC:  MOVWF  xC2
0ADE:  RCALL  0764
0AE0:  MOVFF  20,B4
0AE4:  MOVLW  1B
0AE6:  MOVWF  xB5
0AE8:  RCALL  0780
0AEA:  MOVLW  20
0AEC:  MOVWF  xC2
0AEE:  RCALL  0764
0AF0:  MOVFF  1B,B4
0AF4:  MOVLW  1B
0AF6:  MOVWF  xB5
0AF8:  RCALL  0780
0AFA:  MOVLW  3A
0AFC:  MOVWF  xC2
0AFE:  RCALL  0764
0B00:  MOVFF  1C,B4
0B04:  MOVLW  1B
0B06:  MOVWF  xB5
0B08:  RCALL  0780
0B0A:  MOVLW  3A
0B0C:  MOVWF  xC2
0B0E:  RCALL  0764
0B10:  MOVFF  1D,B4
0B14:  MOVLW  1B
0B16:  MOVWF  xB5
0B18:  RCALL  0780
0B1A:  MOVLW  45
0B1C:  MOVWF  FF6
0B1E:  MOVLW  01
0B20:  MOVWF  FF7
0B22:  MOVLW  05
0B24:  MOVWF  xB6
0B26:  RCALL  07E6
0B28:  CLRF   xB5
0B2A:  CLRF   xB4
0B2C:  MOVFF  B5,FF7
0B30:  MOVF   xB4,W
0B32:  CALL   00C6
0B36:  IORLW  00
0B38:  BZ    0B46
0B3A:  INCF   xB4,F
0B3C:  BTFSC  FD8.2
0B3E:  INCF   xB5,F
0B40:  MOVWF  xC2
0B42:  RCALL  0764
0B44:  BRA    0B2C
0B46:  MOVLW  4C
0B48:  MOVWF  FF6
0B4A:  MOVLW  01
0B4C:  MOVWF  FF7
0B4E:  MOVLW  05
0B50:  MOVWF  xB6
0B52:  RCALL  07E6
0B54:  MOVLW  10
0B56:  MOVWF  FE9
0B58:  MOVFF  23,B7
0B5C:  MOVFF  22,B6
0B60:  RCALL  0804
....................    printf("%s\n\r", mensaje); 
0B62:  CLRF   FEA
0B64:  MOVLW  28
0B66:  MOVWF  FE9
0B68:  RCALL  08EE
0B6A:  MOVLW  0A
0B6C:  BTFSS  F9E.4
0B6E:  BRA    0B6C
0B70:  MOVWF  FAD
0B72:  MOVLW  0D
0B74:  BTFSS  F9E.4
0B76:  BRA    0B74
0B78:  MOVWF  FAD
....................    return; 
.................... } 
0B7A:  GOTO   1998 (RETURN)
....................  
.................... void leer_velocidad(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_VELOCIDAD , &valor_16b); 
*
0D3E:  CLRF   xB4
0D40:  CLRF   xB6
0D42:  MOVLW  22
0D44:  MOVWF  xB5
0D46:  RCALL  0718
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%s val:%Ld",dia, mes, anio, hr, min, sec, mod_to_str[VEL], valor_16b); 
0D48:  CLRF   51
0D4A:  MOVLW  28
0D4C:  MOVWF  50
0D4E:  MOVFF  1E,B4
0D52:  MOVLW  1B
0D54:  MOVWF  xB5
0D56:  RCALL  0780
0D58:  MOVLW  2F
0D5A:  MOVWF  xC2
0D5C:  RCALL  0764
0D5E:  MOVFF  1F,B4
0D62:  MOVLW  1B
0D64:  MOVWF  xB5
0D66:  RCALL  0780
0D68:  MOVLW  2F
0D6A:  MOVWF  xC2
0D6C:  RCALL  0764
0D6E:  MOVFF  20,B4
0D72:  MOVLW  1B
0D74:  MOVWF  xB5
0D76:  RCALL  0780
0D78:  MOVLW  20
0D7A:  MOVWF  xC2
0D7C:  RCALL  0764
0D7E:  MOVFF  1B,B4
0D82:  MOVLW  1B
0D84:  MOVWF  xB5
0D86:  RCALL  0780
0D88:  MOVLW  3A
0D8A:  MOVWF  xC2
0D8C:  RCALL  0764
0D8E:  MOVFF  1C,B4
0D92:  MOVLW  1B
0D94:  MOVWF  xB5
0D96:  RCALL  0780
0D98:  MOVLW  3A
0D9A:  MOVWF  xC2
0D9C:  RCALL  0764
0D9E:  MOVFF  1D,B4
0DA2:  MOVLW  1B
0DA4:  MOVWF  xB5
0DA6:  RCALL  0780
0DA8:  MOVLW  67
0DAA:  MOVWF  FF6
0DAC:  MOVLW  01
0DAE:  MOVWF  FF7
0DB0:  MOVLW  05
0DB2:  MOVWF  xB6
0DB4:  RCALL  07E6
0DB6:  MOVLW  01
0DB8:  MOVWF  xB5
0DBA:  CLRF   xB4
0DBC:  MOVFF  B5,FF7
0DC0:  MOVF   xB4,W
0DC2:  CALL   00C6
0DC6:  IORLW  00
0DC8:  BZ    0DD6
0DCA:  INCF   xB4,F
0DCC:  BTFSC  FD8.2
0DCE:  INCF   xB5,F
0DD0:  MOVWF  xC2
0DD2:  RCALL  0764
0DD4:  BRA    0DBC
0DD6:  MOVLW  6E
0DD8:  MOVWF  FF6
0DDA:  MOVLW  01
0DDC:  MOVWF  FF7
0DDE:  MOVLW  05
0DE0:  MOVWF  xB6
0DE2:  RCALL  07E6
0DE4:  MOVLW  10
0DE6:  MOVWF  FE9
0DE8:  MOVFF  23,B7
0DEC:  MOVFF  22,B6
0DF0:  RCALL  0804
....................    printf("%s\n\r", mensaje); 
0DF2:  CLRF   FEA
0DF4:  MOVLW  28
0DF6:  MOVWF  FE9
0DF8:  RCALL  08EE
0DFA:  MOVLW  0A
0DFC:  BTFSS  F9E.4
0DFE:  BRA    0DFC
0E00:  MOVWF  FAD
0E02:  MOVLW  0D
0E04:  BTFSS  F9E.4
0E06:  BRA    0E04
0E08:  MOVWF  FAD
....................    return; 
.................... } 
0E0A:  GOTO   199C (RETURN)
....................  
.................... void leer_revoluciones(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    AD_leer_canal(CANAL_REVOLUCIONES , &valor_16b); 
*
0FD0:  MOVLW  02
0FD2:  MOVWF  xB4
0FD4:  CLRF   xB6
0FD6:  MOVLW  22
0FD8:  MOVWF  xB5
0FDA:  CALL   0718
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%s val:%Ld",dia, mes, anio, hr, min, sec, mod_to_str[REV], valor_16b); 
0FDE:  CLRF   51
0FE0:  MOVLW  28
0FE2:  MOVWF  50
0FE4:  MOVFF  1E,B4
0FE8:  MOVLW  1B
0FEA:  MOVWF  xB5
0FEC:  CALL   0780
0FF0:  MOVLW  2F
0FF2:  MOVWF  xC2
0FF4:  CALL   0764
0FF8:  MOVFF  1F,B4
0FFC:  MOVLW  1B
0FFE:  MOVWF  xB5
1000:  CALL   0780
1004:  MOVLW  2F
1006:  MOVWF  xC2
1008:  CALL   0764
100C:  MOVFF  20,B4
1010:  MOVLW  1B
1012:  MOVWF  xB5
1014:  CALL   0780
1018:  MOVLW  20
101A:  MOVWF  xC2
101C:  CALL   0764
1020:  MOVFF  1B,B4
1024:  MOVLW  1B
1026:  MOVWF  xB5
1028:  CALL   0780
102C:  MOVLW  3A
102E:  MOVWF  xC2
1030:  CALL   0764
1034:  MOVFF  1C,B4
1038:  MOVLW  1B
103A:  MOVWF  xB5
103C:  CALL   0780
1040:  MOVLW  3A
1042:  MOVWF  xC2
1044:  CALL   0764
1048:  MOVFF  1D,B4
104C:  MOVLW  1B
104E:  MOVWF  xB5
1050:  CALL   0780
1054:  MOVLW  89
1056:  MOVWF  FF6
1058:  MOVLW  01
105A:  MOVWF  FF7
105C:  MOVLW  05
105E:  MOVWF  xB6
1060:  CALL   07E6
1064:  MOVLW  02
1066:  MOVWF  xB5
1068:  CLRF   xB4
106A:  MOVFF  B5,FF7
106E:  MOVF   xB4,W
1070:  CALL   00C6
1074:  IORLW  00
1076:  BZ    1086
1078:  INCF   xB4,F
107A:  BTFSC  FD8.2
107C:  INCF   xB5,F
107E:  MOVWF  xC2
1080:  CALL   0764
1084:  BRA    106A
1086:  MOVLW  90
1088:  MOVWF  FF6
108A:  MOVLW  01
108C:  MOVWF  FF7
108E:  MOVLW  05
1090:  MOVWF  xB6
1092:  CALL   07E6
1096:  MOVLW  10
1098:  MOVWF  FE9
109A:  MOVFF  23,B7
109E:  MOVFF  22,B6
10A2:  CALL   0804
....................    printf("%s\n\r", mensaje); 
10A6:  CLRF   FEA
10A8:  MOVLW  28
10AA:  MOVWF  FE9
10AC:  RCALL  08EE
10AE:  MOVLW  0A
10B0:  BTFSS  F9E.4
10B2:  BRA    10B0
10B4:  MOVWF  FAD
10B6:  MOVLW  0D
10B8:  BTFSS  F9E.4
10BA:  BRA    10B8
10BC:  MOVWF  FAD
....................    return; 
.................... } 
10BE:  GOTO   19A0 (RETURN)
....................  
.................... void leer_accelerometro(void){} 
.................... void leer_sensor_puertas(void){} 
....................  
.................... void leer_ccp1(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    CP_leer_ccp(CANAL_1 , &valor_32b); 
*
1430:  MOVLW  01
1432:  MOVWF  xB4
1434:  CLRF   xB6
1436:  MOVLW  24
1438:  MOVWF  xB5
143A:  RCALL  10C2
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%s val:%Lu",dia, mes, anio, hr, min, sec, mod_to_str[CCP1], valor_32b); 
143C:  CLRF   51
143E:  MOVLW  28
1440:  MOVWF  50
1442:  MOVFF  1E,B4
1446:  MOVLW  1B
1448:  MOVWF  xB5
144A:  CALL   0780
144E:  MOVLW  2F
1450:  MOVWF  xC2
1452:  CALL   0764
1456:  MOVFF  1F,B4
145A:  MOVLW  1B
145C:  MOVWF  xB5
145E:  CALL   0780
1462:  MOVLW  2F
1464:  MOVWF  xC2
1466:  CALL   0764
146A:  MOVFF  20,B4
146E:  MOVLW  1B
1470:  MOVWF  xB5
1472:  CALL   0780
1476:  MOVLW  20
1478:  MOVWF  xC2
147A:  CALL   0764
147E:  MOVFF  1B,B4
1482:  MOVLW  1B
1484:  MOVWF  xB5
1486:  CALL   0780
148A:  MOVLW  3A
148C:  MOVWF  xC2
148E:  CALL   0764
1492:  MOVFF  1C,B4
1496:  MOVLW  1B
1498:  MOVWF  xB5
149A:  CALL   0780
149E:  MOVLW  3A
14A0:  MOVWF  xC2
14A2:  CALL   0764
14A6:  MOVFF  1D,B4
14AA:  MOVLW  1B
14AC:  MOVWF  xB5
14AE:  CALL   0780
14B2:  MOVLW  AB
14B4:  MOVWF  FF6
14B6:  MOVLW  01
14B8:  MOVWF  FF7
14BA:  MOVLW  05
14BC:  MOVWF  xB6
14BE:  CALL   07E6
14C2:  MOVLW  05
14C4:  MOVWF  xB5
14C6:  CLRF   xB4
14C8:  MOVFF  B5,FF7
14CC:  MOVF   xB4,W
14CE:  CALL   00C6
14D2:  IORLW  00
14D4:  BZ    14E4
14D6:  INCF   xB4,F
14D8:  BTFSC  FD8.2
14DA:  INCF   xB5,F
14DC:  MOVWF  xC2
14DE:  CALL   0764
14E2:  BRA    14C8
14E4:  MOVLW  B2
14E6:  MOVWF  FF6
14E8:  MOVLW  01
14EA:  MOVWF  FF7
14EC:  MOVLW  05
14EE:  MOVWF  xB6
14F0:  CALL   07E6
14F4:  MOVLW  41
14F6:  MOVWF  FE9
14F8:  MOVFF  27,B9
14FC:  MOVFF  26,B8
1500:  MOVFF  25,B7
1504:  MOVFF  24,B6
1508:  RCALL  11C8
....................    printf("%s\n\r", mensaje); 
150A:  CLRF   FEA
150C:  MOVLW  28
150E:  MOVWF  FE9
1510:  CALL   08EE
1514:  MOVLW  0A
1516:  BTFSS  F9E.4
1518:  BRA    1516
151A:  MOVWF  FAD
151C:  MOVLW  0D
151E:  BTFSS  F9E.4
1520:  BRA    151E
1522:  MOVWF  FAD
.................... } 
1524:  GOTO   19A2 (RETURN)
....................  
.................... void leer_ccp2(void){ 
....................    ds1307_get_time(hr, min, sec); 
....................    ds1307_get_date(dia, mes, anio, dow); 
....................    CP_leer_ccp(CANAL_1 , &valor_32b); 
*
16EA:  MOVLW  01
16EC:  MOVWF  xB4
16EE:  CLRF   xB6
16F0:  MOVLW  24
16F2:  MOVWF  xB5
16F4:  RCALL  10C2
....................    sprintf(mensaje,"%u/%u/%u %u:%u:%u mod:%s val:%Lu",dia, mes, anio, hr, min, sec, mod_to_str[CCP2], valor_32b); 
16F6:  CLRF   51
16F8:  MOVLW  28
16FA:  MOVWF  50
16FC:  MOVFF  1E,B4
1700:  MOVLW  1B
1702:  MOVWF  xB5
1704:  CALL   0780
1708:  MOVLW  2F
170A:  MOVWF  xC2
170C:  CALL   0764
1710:  MOVFF  1F,B4
1714:  MOVLW  1B
1716:  MOVWF  xB5
1718:  CALL   0780
171C:  MOVLW  2F
171E:  MOVWF  xC2
1720:  CALL   0764
1724:  MOVFF  20,B4
1728:  MOVLW  1B
172A:  MOVWF  xB5
172C:  CALL   0780
1730:  MOVLW  20
1732:  MOVWF  xC2
1734:  CALL   0764
1738:  MOVFF  1B,B4
173C:  MOVLW  1B
173E:  MOVWF  xB5
1740:  CALL   0780
1744:  MOVLW  3A
1746:  MOVWF  xC2
1748:  CALL   0764
174C:  MOVFF  1C,B4
1750:  MOVLW  1B
1752:  MOVWF  xB5
1754:  CALL   0780
1758:  MOVLW  3A
175A:  MOVWF  xC2
175C:  CALL   0764
1760:  MOVFF  1D,B4
1764:  MOVLW  1B
1766:  MOVWF  xB5
1768:  CALL   0780
176C:  MOVLW  CD
176E:  MOVWF  FF6
1770:  MOVLW  01
1772:  MOVWF  FF7
1774:  MOVLW  05
1776:  MOVWF  xB6
1778:  CALL   07E6
177C:  MOVLW  06
177E:  MOVWF  xB5
1780:  CLRF   xB4
1782:  MOVFF  B5,FF7
1786:  MOVF   xB4,W
1788:  CALL   00C6
178C:  IORLW  00
178E:  BZ    179E
1790:  INCF   xB4,F
1792:  BTFSC  FD8.2
1794:  INCF   xB5,F
1796:  MOVWF  xC2
1798:  CALL   0764
179C:  BRA    1782
179E:  MOVLW  D4
17A0:  MOVWF  FF6
17A2:  MOVLW  01
17A4:  MOVWF  FF7
17A6:  MOVLW  05
17A8:  MOVWF  xB6
17AA:  CALL   07E6
17AE:  MOVLW  41
17B0:  MOVWF  FE9
17B2:  MOVFF  27,B9
17B6:  MOVFF  26,B8
17BA:  MOVFF  25,B7
17BE:  MOVFF  24,B6
17C2:  RCALL  11C8
....................    printf("%s\n\r", mensaje); 
17C4:  CLRF   FEA
17C6:  MOVLW  28
17C8:  MOVWF  FE9
17CA:  CALL   08EE
17CE:  MOVLW  0A
17D0:  BTFSS  F9E.4
17D2:  BRA    17D0
17D4:  MOVWF  FAD
17D6:  MOVLW  0D
17D8:  BTFSS  F9E.4
17DA:  BRA    17D8
17DC:  MOVWF  FAD
.................... } 
17DE:  GOTO   19A4 (RETURN)
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
044C:  CLRF   xB6
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
044E:  BCF    FF2.6
0450:  BCF    FF2.7
0452:  BTFSC  FF2.7
0454:  BRA    0450
.................... #endif 
....................  
....................    i2c_start(); 
0456:  BSF    F93.0
0458:  MOVLW  07
045A:  MOVWF  00
045C:  DECFSZ 00,F
045E:  BRA    045C
0460:  BSF    F93.1
0462:  MOVLW  07
0464:  MOVWF  00
0466:  DECFSZ 00,F
0468:  BRA    0466
046A:  BCF    F8A.0
046C:  BCF    F93.0
046E:  MOVLW  07
0470:  MOVWF  00
0472:  DECFSZ 00,F
0474:  BRA    0472
0476:  BCF    F8A.1
0478:  BCF    F93.1
....................    i2c_write(0xD0); 
047A:  MOVLW  D0
047C:  MOVWF  xB8
047E:  RCALL  032E
....................    i2c_write(0x00); 
0480:  CLRF   xB8
0482:  RCALL  032E
....................    i2c_start(); 
0484:  BSF    F93.0
0486:  MOVLW  07
0488:  MOVWF  00
048A:  DECFSZ 00,F
048C:  BRA    048A
048E:  BSF    F93.1
0490:  MOVLW  07
0492:  MOVWF  00
0494:  DECFSZ 00,F
0496:  BRA    0494
0498:  BTFSS  F81.1
049A:  BRA    0498
049C:  BCF    F8A.0
049E:  BCF    F93.0
04A0:  MOVLW  07
04A2:  MOVWF  00
04A4:  DECFSZ 00,F
04A6:  BRA    04A4
04A8:  BCF    F8A.1
04AA:  BCF    F93.1
....................    i2c_write(0xD1); 
04AC:  MOVLW  D1
04AE:  MOVWF  xB8
04B0:  RCALL  032E
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
04B2:  CLRF   00
04B4:  RCALL  039A
04B6:  MOVFF  01,B7
04BA:  MOVFF  01,B9
04BE:  RCALL  0400
04C0:  MOVFF  01,B6
....................    i2c_stop(); 
04C4:  BCF    F93.0
04C6:  NOP   
04C8:  BSF    F93.1
04CA:  BTFSS  F81.1
04CC:  BRA    04CA
04CE:  MOVLW  07
04D0:  MOVWF  00
04D2:  DECFSZ 00,F
04D4:  BRA    04D2
04D6:  BRA    04D8
04D8:  NOP   
04DA:  BSF    F93.0
04DC:  MOVLW  07
04DE:  MOVWF  00
04E0:  DECFSZ 00,F
04E2:  BRA    04E0
....................    seconds &= 0x7F; 
04E4:  BCF    xB6.7
....................  
....................    delay_us(3); 
04E6:  MOVLW  05
04E8:  MOVWF  00
04EA:  DECFSZ 00,F
04EC:  BRA    04EA
04EE:  BRA    04F0
....................  
....................    i2c_start(); 
04F0:  BSF    F93.0
04F2:  MOVLW  07
04F4:  MOVWF  00
04F6:  DECFSZ 00,F
04F8:  BRA    04F6
04FA:  BSF    F93.1
04FC:  MOVLW  07
04FE:  MOVWF  00
0500:  DECFSZ 00,F
0502:  BRA    0500
0504:  BCF    F8A.0
0506:  BCF    F93.0
0508:  MOVLW  07
050A:  MOVWF  00
050C:  DECFSZ 00,F
050E:  BRA    050C
0510:  BCF    F8A.1
0512:  BCF    F93.1
....................    i2c_write(0xD0); 
0514:  MOVLW  D0
0516:  MOVWF  xB8
0518:  RCALL  032E
....................    i2c_write(0x00); 
051A:  CLRF   xB8
051C:  RCALL  032E
....................    i2c_write(ds1307_bin2bcd(seconds)); 
051E:  MOVFF  B6,B7
0522:  BRA    0426
0524:  MOVFF  01,B7
0528:  MOVFF  01,B8
052C:  RCALL  032E
....................    i2c_start(); 
052E:  BSF    F93.0
0530:  MOVLW  07
0532:  MOVWF  00
0534:  DECFSZ 00,F
0536:  BRA    0534
0538:  BSF    F93.1
053A:  MOVLW  07
053C:  MOVWF  00
053E:  DECFSZ 00,F
0540:  BRA    053E
0542:  BTFSS  F81.1
0544:  BRA    0542
0546:  BCF    F8A.0
0548:  BCF    F93.0
054A:  MOVLW  07
054C:  MOVWF  00
054E:  DECFSZ 00,F
0550:  BRA    054E
0552:  BCF    F8A.1
0554:  BCF    F93.1
....................    i2c_write(0xD0); 
0556:  MOVLW  D0
0558:  MOVWF  xB8
055A:  RCALL  032E
....................    i2c_write(0x07); 
055C:  MOVLW  07
055E:  MOVWF  xB8
0560:  RCALL  032E
....................    i2c_write(val); 
0562:  MOVFF  B5,B8
0566:  RCALL  032E
....................    i2c_stop(); 
0568:  BCF    F93.0
056A:  NOP   
056C:  BSF    F93.1
056E:  BTFSS  F81.1
0570:  BRA    056E
0572:  MOVLW  07
0574:  MOVWF  00
0576:  DECFSZ 00,F
0578:  BRA    0576
057A:  BRA    057C
057C:  NOP   
057E:  BSF    F93.0
0580:  MOVLW  07
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0588:  MOVLW  C0
058A:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
058C:  GOTO   06C2 (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
09D6:  BCF    FF2.6
09D8:  BCF    FF2.7
09DA:  BTFSC  FF2.7
09DC:  BRA    09D8
*
0C50:  BCF    FF2.6
0C52:  BCF    FF2.7
0C54:  BTFSC  FF2.7
0C56:  BRA    0C52
*
0EE2:  BCF    FF2.6
0EE4:  BCF    FF2.7
0EE6:  BTFSC  FF2.7
0EE8:  BRA    0EE4
*
1342:  BCF    FF2.6
1344:  BCF    FF2.7
1346:  BTFSC  FF2.7
1348:  BRA    1344
*
15FC:  BCF    FF2.6
15FE:  BCF    FF2.7
1600:  BTFSC  FF2.7
1602:  BRA    15FE
.................... #endif 
....................  
....................   i2c_start(); 
*
09DE:  BSF    F93.0
09E0:  MOVLW  07
09E2:  MOVWF  00
09E4:  DECFSZ 00,F
09E6:  BRA    09E4
09E8:  BSF    F93.1
09EA:  MOVLW  07
09EC:  MOVWF  00
09EE:  DECFSZ 00,F
09F0:  BRA    09EE
09F2:  BCF    F8A.0
09F4:  BCF    F93.0
09F6:  MOVLW  07
09F8:  MOVWF  00
09FA:  DECFSZ 00,F
09FC:  BRA    09FA
09FE:  BCF    F8A.1
0A00:  BCF    F93.1
*
0C58:  BSF    F93.0
0C5A:  MOVLW  07
0C5C:  MOVWF  00
0C5E:  DECFSZ 00,F
0C60:  BRA    0C5E
0C62:  BSF    F93.1
0C64:  MOVLW  07
0C66:  MOVWF  00
0C68:  DECFSZ 00,F
0C6A:  BRA    0C68
0C6C:  BCF    F8A.0
0C6E:  BCF    F93.0
0C70:  MOVLW  07
0C72:  MOVWF  00
0C74:  DECFSZ 00,F
0C76:  BRA    0C74
0C78:  BCF    F8A.1
0C7A:  BCF    F93.1
*
0EEA:  BSF    F93.0
0EEC:  MOVLW  07
0EEE:  MOVWF  00
0EF0:  DECFSZ 00,F
0EF2:  BRA    0EF0
0EF4:  BSF    F93.1
0EF6:  MOVLW  07
0EF8:  MOVWF  00
0EFA:  DECFSZ 00,F
0EFC:  BRA    0EFA
0EFE:  BCF    F8A.0
0F00:  BCF    F93.0
0F02:  MOVLW  07
0F04:  MOVWF  00
0F06:  DECFSZ 00,F
0F08:  BRA    0F06
0F0A:  BCF    F8A.1
0F0C:  BCF    F93.1
*
134A:  BSF    F93.0
134C:  MOVLW  07
134E:  MOVWF  00
1350:  DECFSZ 00,F
1352:  BRA    1350
1354:  BSF    F93.1
1356:  MOVLW  07
1358:  MOVWF  00
135A:  DECFSZ 00,F
135C:  BRA    135A
135E:  BCF    F8A.0
1360:  BCF    F93.0
1362:  MOVLW  07
1364:  MOVWF  00
1366:  DECFSZ 00,F
1368:  BRA    1366
136A:  BCF    F8A.1
136C:  BCF    F93.1
*
1604:  BSF    F93.0
1606:  MOVLW  07
1608:  MOVWF  00
160A:  DECFSZ 00,F
160C:  BRA    160A
160E:  BSF    F93.1
1610:  MOVLW  07
1612:  MOVWF  00
1614:  DECFSZ 00,F
1616:  BRA    1614
1618:  BCF    F8A.0
161A:  BCF    F93.0
161C:  MOVLW  07
161E:  MOVWF  00
1620:  DECFSZ 00,F
1622:  BRA    1620
1624:  BCF    F8A.1
1626:  BCF    F93.1
....................   i2c_write(0xD0); 
*
0A02:  MOVLW  D0
0A04:  MOVWF  xB8
0A06:  RCALL  032E
*
0C7C:  MOVLW  D0
0C7E:  MOVWF  xB8
0C80:  CALL   032E
*
0F0E:  MOVLW  D0
0F10:  MOVWF  xB8
0F12:  CALL   032E
*
136E:  MOVLW  D0
1370:  MOVWF  xB8
1372:  CALL   032E
*
1628:  MOVLW  D0
162A:  MOVWF  xB8
162C:  CALL   032E
....................   i2c_write(0x03); 
*
0A08:  MOVLW  03
0A0A:  MOVWF  xB8
0A0C:  RCALL  032E
*
0C84:  MOVLW  03
0C86:  MOVWF  xB8
0C88:  CALL   032E
*
0F16:  MOVLW  03
0F18:  MOVWF  xB8
0F1A:  CALL   032E
*
1376:  MOVLW  03
1378:  MOVWF  xB8
137A:  CALL   032E
*
1630:  MOVLW  03
1632:  MOVWF  xB8
1634:  CALL   032E
....................   i2c_start(); 
*
0A0E:  BSF    F93.0
0A10:  MOVLW  07
0A12:  MOVWF  00
0A14:  DECFSZ 00,F
0A16:  BRA    0A14
0A18:  BSF    F93.1
0A1A:  MOVLW  07
0A1C:  MOVWF  00
0A1E:  DECFSZ 00,F
0A20:  BRA    0A1E
0A22:  BTFSS  F81.1
0A24:  BRA    0A22
0A26:  BCF    F8A.0
0A28:  BCF    F93.0
0A2A:  MOVLW  07
0A2C:  MOVWF  00
0A2E:  DECFSZ 00,F
0A30:  BRA    0A2E
0A32:  BCF    F8A.1
0A34:  BCF    F93.1
*
0C8C:  BSF    F93.0
0C8E:  MOVLW  07
0C90:  MOVWF  00
0C92:  DECFSZ 00,F
0C94:  BRA    0C92
0C96:  BSF    F93.1
0C98:  MOVLW  07
0C9A:  MOVWF  00
0C9C:  DECFSZ 00,F
0C9E:  BRA    0C9C
0CA0:  BTFSS  F81.1
0CA2:  BRA    0CA0
0CA4:  BCF    F8A.0
0CA6:  BCF    F93.0
0CA8:  MOVLW  07
0CAA:  MOVWF  00
0CAC:  DECFSZ 00,F
0CAE:  BRA    0CAC
0CB0:  BCF    F8A.1
0CB2:  BCF    F93.1
*
0F1E:  BSF    F93.0
0F20:  MOVLW  07
0F22:  MOVWF  00
0F24:  DECFSZ 00,F
0F26:  BRA    0F24
0F28:  BSF    F93.1
0F2A:  MOVLW  07
0F2C:  MOVWF  00
0F2E:  DECFSZ 00,F
0F30:  BRA    0F2E
0F32:  BTFSS  F81.1
0F34:  BRA    0F32
0F36:  BCF    F8A.0
0F38:  BCF    F93.0
0F3A:  MOVLW  07
0F3C:  MOVWF  00
0F3E:  DECFSZ 00,F
0F40:  BRA    0F3E
0F42:  BCF    F8A.1
0F44:  BCF    F93.1
*
137E:  BSF    F93.0
1380:  MOVLW  07
1382:  MOVWF  00
1384:  DECFSZ 00,F
1386:  BRA    1384
1388:  BSF    F93.1
138A:  MOVLW  07
138C:  MOVWF  00
138E:  DECFSZ 00,F
1390:  BRA    138E
1392:  BTFSS  F81.1
1394:  BRA    1392
1396:  BCF    F8A.0
1398:  BCF    F93.0
139A:  MOVLW  07
139C:  MOVWF  00
139E:  DECFSZ 00,F
13A0:  BRA    139E
13A2:  BCF    F8A.1
13A4:  BCF    F93.1
*
1638:  BSF    F93.0
163A:  MOVLW  07
163C:  MOVWF  00
163E:  DECFSZ 00,F
1640:  BRA    163E
1642:  BSF    F93.1
1644:  MOVLW  07
1646:  MOVWF  00
1648:  DECFSZ 00,F
164A:  BRA    1648
164C:  BTFSS  F81.1
164E:  BRA    164C
1650:  BCF    F8A.0
1652:  BCF    F93.0
1654:  MOVLW  07
1656:  MOVWF  00
1658:  DECFSZ 00,F
165A:  BRA    1658
165C:  BCF    F8A.1
165E:  BCF    F93.1
....................   i2c_write(0xD1); 
*
0A36:  MOVLW  D1
0A38:  MOVWF  xB8
0A3A:  RCALL  032E
*
0CB4:  MOVLW  D1
0CB6:  MOVWF  xB8
0CB8:  CALL   032E
*
0F46:  MOVLW  D1
0F48:  MOVWF  xB8
0F4A:  CALL   032E
*
13A6:  MOVLW  D1
13A8:  MOVWF  xB8
13AA:  CALL   032E
*
1660:  MOVLW  D1
1662:  MOVWF  xB8
1664:  CALL   032E
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
0A3C:  MOVLW  01
0A3E:  MOVWF  00
0A40:  RCALL  039A
0A42:  MOVF   01,W
0A44:  ANDLW  7F
0A46:  MOVWF  xB4
0A48:  MOVWF  xB9
0A4A:  RCALL  0400
0A4C:  MOVFF  01,21
*
0CBC:  MOVLW  01
0CBE:  MOVWF  00
0CC0:  CALL   039A
0CC4:  MOVF   01,W
0CC6:  ANDLW  7F
0CC8:  MOVWF  xB4
0CCA:  MOVWF  xB9
0CCC:  CALL   0400
0CD0:  MOVFF  01,21
*
0F4E:  MOVLW  01
0F50:  MOVWF  00
0F52:  CALL   039A
0F56:  MOVF   01,W
0F58:  ANDLW  7F
0F5A:  MOVWF  xB4
0F5C:  MOVWF  xB9
0F5E:  CALL   0400
0F62:  MOVFF  01,21
*
13AE:  MOVLW  01
13B0:  MOVWF  00
13B2:  CALL   039A
13B6:  MOVF   01,W
13B8:  ANDLW  7F
13BA:  MOVWF  xB4
13BC:  MOVWF  xB9
13BE:  CALL   0400
13C2:  MOVFF  01,21
*
1668:  MOVLW  01
166A:  MOVWF  00
166C:  CALL   039A
1670:  MOVF   01,W
1672:  ANDLW  7F
1674:  MOVWF  xB4
1676:  MOVWF  xB9
1678:  CALL   0400
167C:  MOVFF  01,21
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
0A50:  MOVLW  01
0A52:  MOVWF  00
0A54:  RCALL  039A
0A56:  MOVF   01,W
0A58:  ANDLW  3F
0A5A:  MOVWF  xB4
0A5C:  MOVWF  xB9
0A5E:  RCALL  0400
0A60:  MOVFF  01,1E
*
0CD4:  MOVLW  01
0CD6:  MOVWF  00
0CD8:  CALL   039A
0CDC:  MOVF   01,W
0CDE:  ANDLW  3F
0CE0:  MOVWF  xB4
0CE2:  MOVWF  xB9
0CE4:  CALL   0400
0CE8:  MOVFF  01,1E
*
0F66:  MOVLW  01
0F68:  MOVWF  00
0F6A:  CALL   039A
0F6E:  MOVF   01,W
0F70:  ANDLW  3F
0F72:  MOVWF  xB4
0F74:  MOVWF  xB9
0F76:  CALL   0400
0F7A:  MOVFF  01,1E
*
13C6:  MOVLW  01
13C8:  MOVWF  00
13CA:  CALL   039A
13CE:  MOVF   01,W
13D0:  ANDLW  3F
13D2:  MOVWF  xB4
13D4:  MOVWF  xB9
13D6:  CALL   0400
13DA:  MOVFF  01,1E
*
1680:  MOVLW  01
1682:  MOVWF  00
1684:  CALL   039A
1688:  MOVF   01,W
168A:  ANDLW  3F
168C:  MOVWF  xB4
168E:  MOVWF  xB9
1690:  CALL   0400
1694:  MOVFF  01,1E
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
0A64:  MOVLW  01
0A66:  MOVWF  00
0A68:  RCALL  039A
0A6A:  MOVF   01,W
0A6C:  ANDLW  1F
0A6E:  MOVWF  xB4
0A70:  MOVWF  xB9
0A72:  RCALL  0400
0A74:  MOVFF  01,1F
*
0CEC:  MOVLW  01
0CEE:  MOVWF  00
0CF0:  CALL   039A
0CF4:  MOVF   01,W
0CF6:  ANDLW  1F
0CF8:  MOVWF  xB4
0CFA:  MOVWF  xB9
0CFC:  CALL   0400
0D00:  MOVFF  01,1F
*
0F7E:  MOVLW  01
0F80:  MOVWF  00
0F82:  CALL   039A
0F86:  MOVF   01,W
0F88:  ANDLW  1F
0F8A:  MOVWF  xB4
0F8C:  MOVWF  xB9
0F8E:  CALL   0400
0F92:  MOVFF  01,1F
*
13DE:  MOVLW  01
13E0:  MOVWF  00
13E2:  CALL   039A
13E6:  MOVF   01,W
13E8:  ANDLW  1F
13EA:  MOVWF  xB4
13EC:  MOVWF  xB9
13EE:  CALL   0400
13F2:  MOVFF  01,1F
*
1698:  MOVLW  01
169A:  MOVWF  00
169C:  CALL   039A
16A0:  MOVF   01,W
16A2:  ANDLW  1F
16A4:  MOVWF  xB4
16A6:  MOVWF  xB9
16A8:  CALL   0400
16AC:  MOVFF  01,1F
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
0A78:  CLRF   00
0A7A:  RCALL  039A
0A7C:  MOVFF  01,B4
0A80:  MOVFF  01,B9
0A84:  RCALL  0400
0A86:  MOVFF  01,20
*
0D04:  CLRF   00
0D06:  CALL   039A
0D0A:  MOVFF  01,B4
0D0E:  MOVFF  01,B9
0D12:  CALL   0400
0D16:  MOVFF  01,20
*
0F96:  CLRF   00
0F98:  CALL   039A
0F9C:  MOVFF  01,B4
0FA0:  MOVFF  01,B9
0FA4:  CALL   0400
0FA8:  MOVFF  01,20
*
13F6:  CLRF   00
13F8:  CALL   039A
13FC:  MOVFF  01,B4
1400:  MOVFF  01,B9
1404:  CALL   0400
1408:  MOVFF  01,20
*
16B0:  CLRF   00
16B2:  CALL   039A
16B6:  MOVFF  01,B4
16BA:  MOVFF  01,B9
16BE:  CALL   0400
16C2:  MOVFF  01,20
....................   i2c_stop(); 
*
0A8A:  BCF    F93.0
0A8C:  NOP   
0A8E:  BSF    F93.1
0A90:  BTFSS  F81.1
0A92:  BRA    0A90
0A94:  MOVLW  07
0A96:  MOVWF  00
0A98:  DECFSZ 00,F
0A9A:  BRA    0A98
0A9C:  BRA    0A9E
0A9E:  NOP   
0AA0:  BSF    F93.0
0AA2:  MOVLW  07
0AA4:  MOVWF  00
0AA6:  DECFSZ 00,F
0AA8:  BRA    0AA6
*
0D1A:  BCF    F93.0
0D1C:  NOP   
0D1E:  BSF    F93.1
0D20:  BTFSS  F81.1
0D22:  BRA    0D20
0D24:  MOVLW  07
0D26:  MOVWF  00
0D28:  DECFSZ 00,F
0D2A:  BRA    0D28
0D2C:  BRA    0D2E
0D2E:  NOP   
0D30:  BSF    F93.0
0D32:  MOVLW  07
0D34:  MOVWF  00
0D36:  DECFSZ 00,F
0D38:  BRA    0D36
*
0FAC:  BCF    F93.0
0FAE:  NOP   
0FB0:  BSF    F93.1
0FB2:  BTFSS  F81.1
0FB4:  BRA    0FB2
0FB6:  MOVLW  07
0FB8:  MOVWF  00
0FBA:  DECFSZ 00,F
0FBC:  BRA    0FBA
0FBE:  BRA    0FC0
0FC0:  NOP   
0FC2:  BSF    F93.0
0FC4:  MOVLW  07
0FC6:  MOVWF  00
0FC8:  DECFSZ 00,F
0FCA:  BRA    0FC8
*
140C:  BCF    F93.0
140E:  NOP   
1410:  BSF    F93.1
1412:  BTFSS  F81.1
1414:  BRA    1412
1416:  MOVLW  07
1418:  MOVWF  00
141A:  DECFSZ 00,F
141C:  BRA    141A
141E:  BRA    1420
1420:  NOP   
1422:  BSF    F93.0
1424:  MOVLW  07
1426:  MOVWF  00
1428:  DECFSZ 00,F
142A:  BRA    1428
*
16C6:  BCF    F93.0
16C8:  NOP   
16CA:  BSF    F93.1
16CC:  BTFSS  F81.1
16CE:  BRA    16CC
16D0:  MOVLW  07
16D2:  MOVWF  00
16D4:  DECFSZ 00,F
16D6:  BRA    16D4
16D8:  BRA    16DA
16DA:  NOP   
16DC:  BSF    F93.0
16DE:  MOVLW  07
16E0:  MOVWF  00
16E2:  DECFSZ 00,F
16E4:  BRA    16E2
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
0AAA:  MOVLW  C0
0AAC:  IORWF  FF2,F
*
0D3A:  MOVLW  C0
0D3C:  IORWF  FF2,F
*
0FCC:  MOVLW  C0
0FCE:  IORWF  FF2,F
*
142C:  MOVLW  C0
142E:  IORWF  FF2,F
*
16E6:  MOVLW  C0
16E8:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0914:  BCF    FF2.6
0916:  BCF    FF2.7
0918:  BTFSC  FF2.7
091A:  BRA    0916
*
0B7E:  BCF    FF2.6
0B80:  BCF    FF2.7
0B82:  BTFSC  FF2.7
0B84:  BRA    0B80
*
0E0E:  BCF    FF2.6
0E10:  BCF    FF2.7
0E12:  BTFSC  FF2.7
0E14:  BRA    0E10
*
126E:  BCF    FF2.6
1270:  BCF    FF2.7
1272:  BTFSC  FF2.7
1274:  BRA    1270
*
1528:  BCF    FF2.6
152A:  BCF    FF2.7
152C:  BTFSC  FF2.7
152E:  BRA    152A
.................... #endif 
....................  
....................   i2c_start(); 
*
091C:  BSF    F93.0
091E:  MOVLW  07
0920:  MOVWF  00
0922:  DECFSZ 00,F
0924:  BRA    0922
0926:  BSF    F93.1
0928:  MOVLW  07
092A:  MOVWF  00
092C:  DECFSZ 00,F
092E:  BRA    092C
0930:  BCF    F8A.0
0932:  BCF    F93.0
0934:  MOVLW  07
0936:  MOVWF  00
0938:  DECFSZ 00,F
093A:  BRA    0938
093C:  BCF    F8A.1
093E:  BCF    F93.1
*
0B86:  BSF    F93.0
0B88:  MOVLW  07
0B8A:  MOVWF  00
0B8C:  DECFSZ 00,F
0B8E:  BRA    0B8C
0B90:  BSF    F93.1
0B92:  MOVLW  07
0B94:  MOVWF  00
0B96:  DECFSZ 00,F
0B98:  BRA    0B96
0B9A:  BCF    F8A.0
0B9C:  BCF    F93.0
0B9E:  MOVLW  07
0BA0:  MOVWF  00
0BA2:  DECFSZ 00,F
0BA4:  BRA    0BA2
0BA6:  BCF    F8A.1
0BA8:  BCF    F93.1
*
0E16:  BSF    F93.0
0E18:  MOVLW  07
0E1A:  MOVWF  00
0E1C:  DECFSZ 00,F
0E1E:  BRA    0E1C
0E20:  BSF    F93.1
0E22:  MOVLW  07
0E24:  MOVWF  00
0E26:  DECFSZ 00,F
0E28:  BRA    0E26
0E2A:  BCF    F8A.0
0E2C:  BCF    F93.0
0E2E:  MOVLW  07
0E30:  MOVWF  00
0E32:  DECFSZ 00,F
0E34:  BRA    0E32
0E36:  BCF    F8A.1
0E38:  BCF    F93.1
*
1276:  BSF    F93.0
1278:  MOVLW  07
127A:  MOVWF  00
127C:  DECFSZ 00,F
127E:  BRA    127C
1280:  BSF    F93.1
1282:  MOVLW  07
1284:  MOVWF  00
1286:  DECFSZ 00,F
1288:  BRA    1286
128A:  BCF    F8A.0
128C:  BCF    F93.0
128E:  MOVLW  07
1290:  MOVWF  00
1292:  DECFSZ 00,F
1294:  BRA    1292
1296:  BCF    F8A.1
1298:  BCF    F93.1
*
1530:  BSF    F93.0
1532:  MOVLW  07
1534:  MOVWF  00
1536:  DECFSZ 00,F
1538:  BRA    1536
153A:  BSF    F93.1
153C:  MOVLW  07
153E:  MOVWF  00
1540:  DECFSZ 00,F
1542:  BRA    1540
1544:  BCF    F8A.0
1546:  BCF    F93.0
1548:  MOVLW  07
154A:  MOVWF  00
154C:  DECFSZ 00,F
154E:  BRA    154C
1550:  BCF    F8A.1
1552:  BCF    F93.1
....................   i2c_write(0xD0); 
*
0940:  MOVLW  D0
0942:  MOVWF  xB8
0944:  RCALL  032E
*
0BAA:  MOVLW  D0
0BAC:  MOVWF  xB8
0BAE:  CALL   032E
*
0E3A:  MOVLW  D0
0E3C:  MOVWF  xB8
0E3E:  CALL   032E
*
129A:  MOVLW  D0
129C:  MOVWF  xB8
129E:  CALL   032E
*
1554:  MOVLW  D0
1556:  MOVWF  xB8
1558:  CALL   032E
....................   i2c_write(0x00); 
*
0946:  CLRF   xB8
0948:  RCALL  032E
*
0BB2:  CLRF   xB8
0BB4:  CALL   032E
*
0E42:  CLRF   xB8
0E44:  CALL   032E
*
12A2:  CLRF   xB8
12A4:  CALL   032E
*
155C:  CLRF   xB8
155E:  CALL   032E
....................   i2c_start(); 
*
094A:  BSF    F93.0
094C:  MOVLW  07
094E:  MOVWF  00
0950:  DECFSZ 00,F
0952:  BRA    0950
0954:  BSF    F93.1
0956:  MOVLW  07
0958:  MOVWF  00
095A:  DECFSZ 00,F
095C:  BRA    095A
095E:  BTFSS  F81.1
0960:  BRA    095E
0962:  BCF    F8A.0
0964:  BCF    F93.0
0966:  MOVLW  07
0968:  MOVWF  00
096A:  DECFSZ 00,F
096C:  BRA    096A
096E:  BCF    F8A.1
0970:  BCF    F93.1
*
0BB8:  BSF    F93.0
0BBA:  MOVLW  07
0BBC:  MOVWF  00
0BBE:  DECFSZ 00,F
0BC0:  BRA    0BBE
0BC2:  BSF    F93.1
0BC4:  MOVLW  07
0BC6:  MOVWF  00
0BC8:  DECFSZ 00,F
0BCA:  BRA    0BC8
0BCC:  BTFSS  F81.1
0BCE:  BRA    0BCC
0BD0:  BCF    F8A.0
0BD2:  BCF    F93.0
0BD4:  MOVLW  07
0BD6:  MOVWF  00
0BD8:  DECFSZ 00,F
0BDA:  BRA    0BD8
0BDC:  BCF    F8A.1
0BDE:  BCF    F93.1
*
0E48:  BSF    F93.0
0E4A:  MOVLW  07
0E4C:  MOVWF  00
0E4E:  DECFSZ 00,F
0E50:  BRA    0E4E
0E52:  BSF    F93.1
0E54:  MOVLW  07
0E56:  MOVWF  00
0E58:  DECFSZ 00,F
0E5A:  BRA    0E58
0E5C:  BTFSS  F81.1
0E5E:  BRA    0E5C
0E60:  BCF    F8A.0
0E62:  BCF    F93.0
0E64:  MOVLW  07
0E66:  MOVWF  00
0E68:  DECFSZ 00,F
0E6A:  BRA    0E68
0E6C:  BCF    F8A.1
0E6E:  BCF    F93.1
*
12A8:  BSF    F93.0
12AA:  MOVLW  07
12AC:  MOVWF  00
12AE:  DECFSZ 00,F
12B0:  BRA    12AE
12B2:  BSF    F93.1
12B4:  MOVLW  07
12B6:  MOVWF  00
12B8:  DECFSZ 00,F
12BA:  BRA    12B8
12BC:  BTFSS  F81.1
12BE:  BRA    12BC
12C0:  BCF    F8A.0
12C2:  BCF    F93.0
12C4:  MOVLW  07
12C6:  MOVWF  00
12C8:  DECFSZ 00,F
12CA:  BRA    12C8
12CC:  BCF    F8A.1
12CE:  BCF    F93.1
*
1562:  BSF    F93.0
1564:  MOVLW  07
1566:  MOVWF  00
1568:  DECFSZ 00,F
156A:  BRA    1568
156C:  BSF    F93.1
156E:  MOVLW  07
1570:  MOVWF  00
1572:  DECFSZ 00,F
1574:  BRA    1572
1576:  BTFSS  F81.1
1578:  BRA    1576
157A:  BCF    F8A.0
157C:  BCF    F93.0
157E:  MOVLW  07
1580:  MOVWF  00
1582:  DECFSZ 00,F
1584:  BRA    1582
1586:  BCF    F8A.1
1588:  BCF    F93.1
....................   i2c_write(0xD1); 
*
0972:  MOVLW  D1
0974:  MOVWF  xB8
0976:  RCALL  032E
*
0BE0:  MOVLW  D1
0BE2:  MOVWF  xB8
0BE4:  CALL   032E
*
0E70:  MOVLW  D1
0E72:  MOVWF  xB8
0E74:  CALL   032E
*
12D0:  MOVLW  D1
12D2:  MOVWF  xB8
12D4:  CALL   032E
*
158A:  MOVLW  D1
158C:  MOVWF  xB8
158E:  CALL   032E
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
0978:  MOVLW  01
097A:  MOVWF  00
097C:  RCALL  039A
097E:  MOVF   01,W
0980:  ANDLW  7F
0982:  MOVWF  xB4
0984:  MOVWF  xB9
0986:  RCALL  0400
0988:  MOVFF  01,1D
*
0BE8:  MOVLW  01
0BEA:  MOVWF  00
0BEC:  CALL   039A
0BF0:  MOVF   01,W
0BF2:  ANDLW  7F
0BF4:  MOVWF  xB4
0BF6:  MOVWF  xB9
0BF8:  RCALL  0400
0BFA:  MOVFF  01,1D
*
0E78:  MOVLW  01
0E7A:  MOVWF  00
0E7C:  CALL   039A
0E80:  MOVF   01,W
0E82:  ANDLW  7F
0E84:  MOVWF  xB4
0E86:  MOVWF  xB9
0E88:  CALL   0400
0E8C:  MOVFF  01,1D
*
12D8:  MOVLW  01
12DA:  MOVWF  00
12DC:  CALL   039A
12E0:  MOVF   01,W
12E2:  ANDLW  7F
12E4:  MOVWF  xB4
12E6:  MOVWF  xB9
12E8:  CALL   0400
12EC:  MOVFF  01,1D
*
1592:  MOVLW  01
1594:  MOVWF  00
1596:  CALL   039A
159A:  MOVF   01,W
159C:  ANDLW  7F
159E:  MOVWF  xB4
15A0:  MOVWF  xB9
15A2:  CALL   0400
15A6:  MOVFF  01,1D
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
098C:  MOVLW  01
098E:  MOVWF  00
0990:  RCALL  039A
0992:  MOVF   01,W
0994:  ANDLW  7F
0996:  MOVWF  xB4
0998:  MOVWF  xB9
099A:  RCALL  0400
099C:  MOVFF  01,1C
*
0BFE:  MOVLW  01
0C00:  MOVWF  00
0C02:  CALL   039A
0C06:  MOVF   01,W
0C08:  ANDLW  7F
0C0A:  MOVWF  xB4
0C0C:  MOVWF  xB9
0C0E:  CALL   0400
0C12:  MOVFF  01,1C
*
0E90:  MOVLW  01
0E92:  MOVWF  00
0E94:  CALL   039A
0E98:  MOVF   01,W
0E9A:  ANDLW  7F
0E9C:  MOVWF  xB4
0E9E:  MOVWF  xB9
0EA0:  CALL   0400
0EA4:  MOVFF  01,1C
*
12F0:  MOVLW  01
12F2:  MOVWF  00
12F4:  CALL   039A
12F8:  MOVF   01,W
12FA:  ANDLW  7F
12FC:  MOVWF  xB4
12FE:  MOVWF  xB9
1300:  CALL   0400
1304:  MOVFF  01,1C
*
15AA:  MOVLW  01
15AC:  MOVWF  00
15AE:  CALL   039A
15B2:  MOVF   01,W
15B4:  ANDLW  7F
15B6:  MOVWF  xB4
15B8:  MOVWF  xB9
15BA:  CALL   0400
15BE:  MOVFF  01,1C
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
09A0:  CLRF   00
09A2:  RCALL  039A
09A4:  MOVF   01,W
09A6:  ANDLW  3F
09A8:  MOVWF  xB4
09AA:  MOVWF  xB9
09AC:  RCALL  0400
09AE:  MOVFF  01,1B
*
0C16:  CLRF   00
0C18:  CALL   039A
0C1C:  MOVF   01,W
0C1E:  ANDLW  3F
0C20:  MOVWF  xB4
0C22:  MOVWF  xB9
0C24:  CALL   0400
0C28:  MOVFF  01,1B
*
0EA8:  CLRF   00
0EAA:  CALL   039A
0EAE:  MOVF   01,W
0EB0:  ANDLW  3F
0EB2:  MOVWF  xB4
0EB4:  MOVWF  xB9
0EB6:  CALL   0400
0EBA:  MOVFF  01,1B
*
1308:  CLRF   00
130A:  CALL   039A
130E:  MOVF   01,W
1310:  ANDLW  3F
1312:  MOVWF  xB4
1314:  MOVWF  xB9
1316:  CALL   0400
131A:  MOVFF  01,1B
*
15C2:  CLRF   00
15C4:  CALL   039A
15C8:  MOVF   01,W
15CA:  ANDLW  3F
15CC:  MOVWF  xB4
15CE:  MOVWF  xB9
15D0:  CALL   0400
15D4:  MOVFF  01,1B
....................   i2c_stop(); 
*
09B2:  BCF    F93.0
09B4:  NOP   
09B6:  BSF    F93.1
09B8:  BTFSS  F81.1
09BA:  BRA    09B8
09BC:  MOVLW  07
09BE:  MOVWF  00
09C0:  DECFSZ 00,F
09C2:  BRA    09C0
09C4:  BRA    09C6
09C6:  NOP   
09C8:  BSF    F93.0
09CA:  MOVLW  07
09CC:  MOVWF  00
09CE:  DECFSZ 00,F
09D0:  BRA    09CE
*
0C2C:  BCF    F93.0
0C2E:  NOP   
0C30:  BSF    F93.1
0C32:  BTFSS  F81.1
0C34:  BRA    0C32
0C36:  MOVLW  07
0C38:  MOVWF  00
0C3A:  DECFSZ 00,F
0C3C:  BRA    0C3A
0C3E:  BRA    0C40
0C40:  NOP   
0C42:  BSF    F93.0
0C44:  MOVLW  07
0C46:  MOVWF  00
0C48:  DECFSZ 00,F
0C4A:  BRA    0C48
*
0EBE:  BCF    F93.0
0EC0:  NOP   
0EC2:  BSF    F93.1
0EC4:  BTFSS  F81.1
0EC6:  BRA    0EC4
0EC8:  MOVLW  07
0ECA:  MOVWF  00
0ECC:  DECFSZ 00,F
0ECE:  BRA    0ECC
0ED0:  BRA    0ED2
0ED2:  NOP   
0ED4:  BSF    F93.0
0ED6:  MOVLW  07
0ED8:  MOVWF  00
0EDA:  DECFSZ 00,F
0EDC:  BRA    0EDA
*
131E:  BCF    F93.0
1320:  NOP   
1322:  BSF    F93.1
1324:  BTFSS  F81.1
1326:  BRA    1324
1328:  MOVLW  07
132A:  MOVWF  00
132C:  DECFSZ 00,F
132E:  BRA    132C
1330:  BRA    1332
1332:  NOP   
1334:  BSF    F93.0
1336:  MOVLW  07
1338:  MOVWF  00
133A:  DECFSZ 00,F
133C:  BRA    133A
*
15D8:  BCF    F93.0
15DA:  NOP   
15DC:  BSF    F93.1
15DE:  BTFSS  F81.1
15E0:  BRA    15DE
15E2:  MOVLW  07
15E4:  MOVWF  00
15E6:  DECFSZ 00,F
15E8:  BRA    15E6
15EA:  BRA    15EC
15EC:  NOP   
15EE:  BSF    F93.0
15F0:  MOVLW  07
15F2:  MOVWF  00
15F4:  DECFSZ 00,F
15F6:  BRA    15F4
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
09D2:  MOVLW  C0
09D4:  IORWF  FF2,F
*
0C4C:  MOVLW  C0
0C4E:  IORWF  FF2,F
*
0EDE:  MOVLW  C0
0EE0:  IORWF  FF2,F
*
133E:  MOVLW  C0
1340:  IORWF  FF2,F
*
15F8:  MOVLW  C0
15FA:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
0426:  MOVFF  B7,B8
....................   retval = 0; 
042A:  CLRF   xB9
....................   while(1){ 
....................     if(temp >= 10){ 
042C:  MOVF   xB8,W
042E:  SUBLW  09
0430:  BC    043C
....................       temp -= 10; 
0432:  MOVLW  0A
0434:  SUBWF  xB8,F
....................       retval += 0x10; 
0436:  MOVLW  10
0438:  ADDWF  xB9,F
....................     }else{ 
043A:  BRA    0442
....................       retval += temp; 
043C:  MOVF   xB8,W
043E:  ADDWF  xB9,F
....................       break; 
0440:  BRA    0444
....................     } 
....................   } 
0442:  BRA    042C
....................   return(retval); 
0444:  MOVFF  B9,01
.................... } 
0448:  GOTO   0524 (RETURN)
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
0400:  MOVFF  B9,BA
....................   temp >>= 1; 
0404:  BCF    FD8.0
0406:  RRCF   xBA,F
....................   temp &= 0x78; 
0408:  MOVLW  78
040A:  ANDWF  xBA,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
040C:  RRCF   xBA,W
040E:  MOVWF  00
0410:  RRCF   00,F
0412:  MOVLW  3F
0414:  ANDWF  00,F
0416:  MOVF   00,W
0418:  ADDWF  xBA,W
041A:  MOVWF  xBB
041C:  MOVF   xB9,W
041E:  ANDLW  0F
0420:  ADDWF  xBB,W
0422:  MOVWF  01
.................... } 
0424:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, int16 *buffer); 
.................... #endif 
....................  
....................  
.................... #define ADC_TAD_MUL_2      0x08 
.................... #define ADC_INPUT_PORT	0x07 
.................... int AD_init_adc(){ 
.................... 	setup_adc_ports(AN0_TO_AN2); 
*
02DA:  MOVF   FC1,W
02DC:  ANDLW  C0
02DE:  IORLW  0C
02E0:  MOVWF  FC1
....................  
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #endif 
.................... */	 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
02E2:  BCF    FC0.0
02E4:  BSF    FC0.1
02E6:  BCF    FC0.2
02E8:  BSF    FC0.7
02EA:  BSF    FC2.0
.................... 	set_tris_a(ADC_INPUT_PORT);		//RB0 a RB1 entradas 
02EC:  MOVLW  07
02EE:  MOVWF  F92
.................... 	return 0; 
02F0:  MOVLW  00
02F2:  MOVWF  01
.................... } 
02F4:  GOTO   06B2 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
0718:  RLCF   xB4,W
071A:  MOVWF  00
071C:  RLCF   00,F
071E:  MOVLW  FC
0720:  ANDWF  00,F
0722:  MOVF   FC2,W
0724:  ANDLW  C3
0726:  IORWF  00,W
0728:  MOVWF  FC2
.................... 	delay_us(10); 
072A:  MOVLW  13
072C:  MOVWF  00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  BRA    0734
.................... 	read_adc(ADC_START_ONLY); 
0734:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
0736:  BCF    xB7.0
0738:  BTFSS  FC2.1
073A:  BSF    xB7.0
.................... 	}while(!done); 
073C:  BTFSS  xB7.0
073E:  BRA    0736
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
0740:  MOVFF  B6,03
0744:  MOVFF  B5,FE9
0748:  MOVFF  B6,FEA
074C:  BTFSC  FC2.1
074E:  BRA    074C
0750:  MOVFF  FC3,FEF
0754:  MOVFF  FC4,FEC
.................... 	delay_us(1); 
0758:  BRA    075A
075A:  BRA    075C
075C:  BRA    075E
.................... 	return 0; 
075E:  MOVLW  00
0760:  MOVWF  01
.................... } 
0762:  RETLW  00
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include "PIC18F4550.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCON { 
....................    unsigned int HLVDL:4; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IRVST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCON; 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBC 
....................  
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct ECCP1DEL { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DEL; 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... struct ECCP1AS { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1AS; 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int USBIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int USBIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int USBIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int SPPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int SPPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int SPPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :2; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int :7; 
....................    unsigned int RDPU:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... struct UEP15 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP15; 
.................... #byte UEP15 = 0xF7F 
....................  
.................... struct UEP14 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP14; 
.................... #byte UEP14 = 0xF7E 
....................  
.................... struct UEP13 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP13; 
.................... #byte UEP13 = 0xF7D 
....................  
.................... struct UEP12 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP12; 
.................... #byte UEP12 = 0xF7C 
....................  
.................... struct UEP11 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP11; 
.................... #byte UEP11 = 0xF7B 
....................  
.................... struct UEP10 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP10; 
.................... #byte UEP10 = 0xF7A 
....................  
.................... struct UEP9 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP9; 
.................... #byte UEP9 = 0xF79 
....................  
.................... struct UEP8 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP8; 
.................... #byte UEP8 = 0xF78 
....................  
.................... struct UEP7 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP7; 
.................... #byte UEP7 = 0xF77 
....................  
.................... struct UEP6 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP6; 
.................... #byte UEP6 = 0xF76 
....................  
.................... struct UEP5 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP5; 
.................... #byte UEP5 = 0xF75 
....................  
.................... struct UEP4 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP4; 
.................... #byte UEP4 = 0xF74 
....................  
.................... struct UEP3 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP3; 
.................... #byte UEP3 = 0xF73 
....................  
.................... struct UEP2 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP2; 
.................... #byte UEP2 = 0xF72 
....................  
.................... struct UEP1 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP1; 
.................... #byte UEP1 = 0xF71 
....................  
.................... struct UEP0 { 
....................    unsigned int EPSTALL:1; 
....................    unsigned int EPINEN:1; 
....................    unsigned int EPOUTEN:1; 
....................    unsigned int EPCONDIS:1; 
....................    unsigned int EPHSHK:1; 
.................... } UEP0; 
.................... #byte UEP0 = 0xF70 
....................  
.................... struct UCFG { 
....................    unsigned int PPB:2; 
....................    unsigned int FSEN:1; 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UPUEN:1; 
....................    unsigned int :1; 
....................    unsigned int UOEMON:1; 
....................    unsigned int UTEYE:1; 
.................... } UCFG; 
.................... #byte UCFG = 0xF6F 
....................  
.................... struct UADDR { 
....................    unsigned int ADDR:7; 
.................... } UADDR; 
.................... #byte UADDR = 0xF6E 
....................  
.................... struct UCON { 
....................    unsigned int :1; 
....................    unsigned int SUSPND:1; 
....................    unsigned int RESUME:1; 
....................    unsigned int USBEN:1; 
....................    unsigned int PKTDIS:1; 
....................    unsigned int SE:1; 
....................    unsigned int PPBRST:1; 
.................... } UCON; 
.................... #byte UCON = 0xF6D 
....................  
.................... struct USTAT { 
....................    unsigned int :1; 
....................    unsigned int PPBI:1; 
....................    unsigned int DIR:1; 
....................    unsigned int ENDP:4; 
.................... } USTAT; 
.................... #byte USTAT = 0xF6C 
....................  
.................... struct UEIE { 
....................    unsigned int PIDEE:1; 
....................    unsigned int CRC5EE:1; 
....................    unsigned int CRC16EE:1; 
....................    unsigned int DFN8EE:1; 
....................    unsigned int BTOEE:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEE:1; 
.................... } UEIE; 
.................... #byte UEIE = 0xF6B 
....................  
.................... struct UEIR { 
....................    unsigned int PIDEF:1; 
....................    unsigned int CRC5EF:1; 
....................    unsigned int CRC16EF:1; 
....................    unsigned int DFN8EF:1; 
....................    unsigned int BTOEF:1; 
....................    unsigned int :2; 
....................    unsigned int BTSEF:1; 
.................... } UEIR; 
.................... #byte UEIR = 0xF6A 
....................  
.................... struct UIE { 
....................    unsigned int URSTIE:1; 
....................    unsigned int UERRIE:1; 
....................    unsigned int ACTIVIE:1; 
....................    unsigned int TRNIE:1; 
....................    unsigned int IDLEIE:1; 
....................    unsigned int STALLIE:1; 
....................    unsigned int SOFIE:1; 
.................... } UIE; 
.................... #byte UIE = 0xF69 
....................  
.................... struct UIR { 
....................    unsigned int URSTIF:1; 
....................    unsigned int UERRIF:1; 
....................    unsigned int ACTIVIF:1; 
....................    unsigned int TRNIF:1; 
....................    unsigned int IDLEIF:1; 
....................    unsigned int STALLIF:1; 
....................    unsigned int SOFIF:1; 
.................... } UIR; 
.................... #byte UIR = 0xF68 
....................  
.................... struct UFRMH { 
....................    unsigned int FRM:3; 
.................... } UFRMH; 
.................... #byte UFRMH = 0xF67 
....................  
.................... #byte UFRML = 0xF66 
....................  
.................... struct SPPCON { 
....................    unsigned int SPPEN:1; 
....................    unsigned int SPPOWN:1; 
.................... } SPPCON; 
.................... #byte SPPCON = 0xF65 
....................  
.................... struct SPPEPS { 
....................    unsigned int ADDR:4; 
....................    unsigned int SPPBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int WRSPP:1; 
....................    unsigned int RDSPP:1; 
.................... } SPPEPS; 
.................... #byte SPPEPS = 0xF64 
....................  
.................... struct SPPCFG { 
....................    unsigned int WS:4; 
....................    unsigned int CLK1EN:1; 
....................    unsigned int CSEN:1; 
....................    unsigned int CLKCFG:2; 
.................... } SPPCFG; 
.................... #byte SPPCFG = 0xF63 
....................  
.................... #byte SPPDATA = 0xF62 
....................  
.................... #endif 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #define PIN_SDA PIN_B0 
.................... #define PIN_SCL PIN_B1 
.................... #use i2c(master, sda= PIN_SDA, scl=PIN_SCL/*, FORCE_HW, RESTART_WDT*/)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#include <stdlib.h> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #endif 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_1|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
01DE:  INCF   xAB,F
.................... } 
....................  
01E0:  BCF    FA1.1
01E2:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
01E6:  MOVF   xAA,W
01E8:  SUBLW  FF
01EA:  BNZ   01FC
....................    	setup_ccp1(CCP_CAPTURE_FE); 
01EC:  BSF    F94.2
01EE:  CLRF   FBD
01F0:  MOVLW  04
01F2:  MOVWF  FBD
01F4:  CLRF   FB7
01F6:  CLRF   FB6
....................    	Q_CCP = 0; 
01F8:  CLRF   xAA
....................    }else if(Q_CCP == 0){ 
01FA:  BRA    025A
01FC:  MOVF   xAA,F
01FE:  BNZ   0224
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
0200:  CLRF   01
0202:  CLRF   xCF
0204:  CLRF   xD0
0206:  MOVF   FBE,W
0208:  ADDWF  xCF,W
020A:  MOVWF  xB0
020C:  MOVF   FBF,W
020E:  ADDWFC xD0,W
0210:  MOVWF  xB1
0212:  MOVLW  00
0214:  ADDWFC xAB,W
0216:  MOVWF  xB2
0218:  MOVLW  00
021A:  ADDWFC 01,W
021C:  MOVWF  xB3
....................    	Q_CCP = 1; 
021E:  MOVLW  01
0220:  MOVWF  xAA
....................    }else if(Q_CCP == 1){ 
0222:  BRA    025A
0224:  DECFSZ xAA,W
0226:  BRA    025A
....................    	tiempo_inicial = tiempo_final; 
0228:  MOVFF  B3,AF
022C:  MOVFF  B2,AE
0230:  MOVFF  B1,AD
0234:  MOVFF  B0,AC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
0238:  CLRF   01
023A:  CLRF   xCF
023C:  CLRF   xD0
023E:  MOVF   FBE,W
0240:  ADDWF  xCF,W
0242:  MOVWF  xB0
0244:  MOVF   FBF,W
0246:  ADDWFC xD0,W
0248:  MOVWF  xB1
024A:  MOVLW  00
024C:  ADDWFC xAB,W
024E:  MOVWF  xB2
0250:  MOVLW  00
0252:  ADDWFC 01,W
0254:  MOVWF  xB3
....................    	Q_CCP = 2; 
0256:  MOVLW  02
0258:  MOVWF  xAA
....................    } 
.................... } 
....................  
025A:  BCF    F9E.2
025C:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
0260:  MOVF   xAA,W
0262:  SUBLW  FF
0264:  BNZ   0276
....................    	setup_ccp1(CCP_CAPTURE_FE); 
0266:  BSF    F94.2
0268:  CLRF   FBD
026A:  MOVLW  04
026C:  MOVWF  FBD
026E:  CLRF   FB7
0270:  CLRF   FB6
....................    	Q_CCP = 0; 
0272:  CLRF   xAA
....................    }else if(Q_CCP == 0){ 
0274:  BRA    02D4
0276:  MOVF   xAA,F
0278:  BNZ   029E
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
027A:  CLRF   01
027C:  CLRF   xCF
027E:  CLRF   xD0
0280:  MOVF   FBB,W
0282:  ADDWF  xCF,W
0284:  MOVWF  xB0
0286:  MOVF   FBC,W
0288:  ADDWFC xD0,W
028A:  MOVWF  xB1
028C:  MOVLW  00
028E:  ADDWFC xAB,W
0290:  MOVWF  xB2
0292:  MOVLW  00
0294:  ADDWFC 01,W
0296:  MOVWF  xB3
....................    	Q_CCP = 1; 
0298:  MOVLW  01
029A:  MOVWF  xAA
....................    }else if(Q_CCP == 1){ 
029C:  BRA    02D4
029E:  DECFSZ xAA,W
02A0:  BRA    02D4
....................    	tiempo_inicial = tiempo_final; 
02A2:  MOVFF  B3,AF
02A6:  MOVFF  B2,AE
02AA:  MOVFF  B1,AD
02AE:  MOVFF  B0,AC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
02B2:  CLRF   01
02B4:  CLRF   xCF
02B6:  CLRF   xD0
02B8:  MOVF   FBB,W
02BA:  ADDWF  xCF,W
02BC:  MOVWF  xB0
02BE:  MOVF   FBC,W
02C0:  ADDWFC xD0,W
02C2:  MOVWF  xB1
02C4:  MOVLW  00
02C6:  ADDWFC xAB,W
02C8:  MOVWF  xB2
02CA:  MOVLW  00
02CC:  ADDWFC 01,W
02CE:  MOVWF  xB3
....................    	Q_CCP = 2; 
02D0:  MOVLW  02
02D2:  MOVWF  xAA
....................    } 
.................... } 
....................  
02D4:  BCF    FA1.0
02D6:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
*
02F8:  MOVFF  A7,FB1
....................    T3CON.TMR3ON = 0; 
02FC:  BCF    FB1.0
....................    set_timer3(0); 
02FE:  CLRF   FB3
0300:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
0302:  MOVF   xA8,W
0304:  ANDLW  08
0306:  BTFSC  FD8.2
0308:  BCF    F82.2
030A:  CLRF   FBD
030C:  MOVFF  A8,FBD
0310:  CLRF   FB7
0312:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
0314:  MOVF   xA9,W
0316:  ANDLW  08
0318:  BTFSC  FD8.2
031A:  BCF    F82.1
031C:  CLRF   FBA
031E:  MOVFF  A9,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1  ;                        
0322:  BSF    F94.2
0324:  BSF    F94.1
....................    return 0; 
0326:  MOVLW  00
0328:  MOVWF  01
.................... } 
032A:  GOTO   06B8 (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    //int32 resultado = 0; 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
*
10C2:  MOVLW  C0
10C4:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
10C6:  BSF    FA0.1
....................    set_timer3(0);      					//se reset timer  a 0 
10C8:  CLRF   FB3
10CA:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
10CC:  BSF    FB1.0
....................    /*if(canal == CANAL_1){ 
....................       enable_interrupts(INT_CCP1);   //si es el canal 1 se habilita la interrupcion del modulo CCP1 
....................    }else if(canal == CANAL_2){ 
....................       enable_interrupts(INT_CCP2);   //si es el canal 2 se habilita la interrupcion del modulo CCP2 
....................    }else{return (1);}*/ 
....................    (canal == CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
10CE:  DECFSZ xB4,W
10D0:  BRA    10D6
10D2:  BSF    F9D.2
10D4:  BRA    10D8
10D6:  BSF    FA0.0
....................    while(Q_CCP != 2){;}             //espera a que se carguen los valores de los tiempos 
10D8:  MOVF   xAA,W
10DA:  SUBLW  02
10DC:  BZ    10E0
10DE:  BRA    10D8
....................    disable_interrupts(INT_CCP1); 
10E0:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
10E2:  BCF    FA0.0
....................    setup_ccp2(MODO_CCP1); 
10E4:  MOVF   xA8,W
10E6:  ANDLW  08
10E8:  BTFSC  FD8.2
10EA:  BCF    F82.1
10EC:  CLRF   FBA
10EE:  MOVFF  A8,FBA
....................    setup_ccp2(MODO_CCP2); 
10F2:  MOVF   xA9,W
10F4:  ANDLW  08
10F6:  BTFSC  FD8.2
10F8:  BCF    F82.1
10FA:  CLRF   FBA
10FC:  MOVFF  A9,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
1100:  MOVLW  FF
1102:  MOVWF  xAA
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
1104:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
1106:  CLRF   xAB
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
1108:  MOVFF  B5,FE9
110C:  MOVFF  B6,FEA
1110:  MOVF   xAC,W
1112:  SUBWF  xB0,W
1114:  MOVWF  00
1116:  MOVF   xAD,W
1118:  SUBWFB xB1,W
111A:  MOVWF  01
111C:  MOVF   xAE,W
111E:  SUBWFB xB2,W
1120:  MOVWF  02
1122:  MOVF   xAF,W
1124:  SUBWFB xB3,W
1126:  MOVFF  00,FEF
112A:  MOVFF  01,FEC
112E:  MOVFF  02,FEC
1132:  MOVWF  FEC
....................    return (0); 
1134:  MOVLW  00
1136:  MOVWF  01
.................... } 
1138:  RETLW  00

Configuration Fuses:
   Word  1: CE3F   IESO FCMEN HSPLL PLL12 CPUDIV4 USBDIV
   Word  2: 0E39   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 00A1   STVREN NODEBUG NOLVP NOXINST ICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
