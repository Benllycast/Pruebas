CCS PCH C Compiler, Version 4.104, 5967               04-sep-14 14:20

               Filename: D:\Proyecto\Pruebas\Nucleo.lst

               ROM used: 12756 bytes (39%)
                         Largest free fragment is 20012
               RAM used: 643 (31%) at main() level
                         876 (43%) worst case
               Stack:    20 worst case (10 in main + 10 for interrupts)

*
0000:  GOTO   2D30
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FA0.1
004A:  GOTO   0054
004E:  BTFSC  FA1.1
0050:  GOTO   2182
0054:  BTFSS  F9D.2
0056:  GOTO   0060
005A:  BTFSC  F9E.2
005C:  GOTO   218A
0060:  BTFSS  FA0.0
0062:  GOTO   006C
0066:  BTFSC  FA1.0
0068:  GOTO   222E
006C:  BTFSS  FA0.5
006E:  GOTO   0078
0072:  BTFSC  FA1.5
0074:  GOTO   1076
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "Nucleo.h" 
.................... /*=========================Configuracion del Hardware========================== 
....................  
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentandolo a 96Mhz-> div:2 a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU 
....................  
.................... ==============================================================================*/ 
....................  
.................... /*=================== FILE HEADER ===================================*/ 
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... //#include "PIC18F4550.h" 
.................... #device adc=10 
.................... //#define SIMULACION 1   // comentar esto si se prueba en forma real 
....................  
.................... /*====================fuses de configuracion del dispositivo==================*/ 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN,NOPBADEN,CCP2C1 
.................... /* 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.1V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage programing, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5                     //(PLL prescaler) PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3                  //postscaler PLL div by 4 (whit pll enable)                      
.................... #FUSES USBDIV                  //enable USBDIV, USB clock source come from PLL divide by 2 
.................... #FUSES VREGEN                  //internal regulator USB enable 
.................... #FUSES ICPRT                   
.................... #FUSES CCP2C1                  //CPP input/output multiplexed whit RC1 
....................  
....................  
.................... /*============================ DEFINICIONES DE PINES =========================*/ 
.................... #define PIN_SDA   PIN_B0 
.................... #define PIN_SCL   PIN_B1 
....................  
.................... //#define PIN_XMIT   PIN_C6 
.................... //#define PIN_RCV   PIN_C7 
....................  
.................... #define PIN_XMIT   PIN_D0 
.................... #define PIN_RCV   PIN_D1 
....................  
....................     
.................... #define PIN_LOG   PIN_D2 
....................  
.................... #define SPI_SS      PIN_D7 
.................... #define SPI_MISO   PIN_D6 
.................... #define SPI_MOSI   PIN_D5 
.................... #define SPI_SCL   PIN_D4 
....................  
.................... #define CONFIG_PORT_C   0x83      //v1 
.................... #define CONFIG_PORT_D   0x4E      //v2 
....................  
....................  
.................... /*=================== CONFIGURACION DEL RELOJ DE TRABAJO =====================*/ 
.................... #use delay(clock=16000000)   //cambiar el valor del clock si se cambia la frecuencia de la CPU 
*
1850:  MOVLW  04
1852:  MOVLB  2
1854:  SUBWF  x94,F
1856:  BNC   186C
1858:  MOVLW  02
185A:  MOVWF  FEA
185C:  MOVLW  94
185E:  MOVWF  FE9
1860:  MOVF   FEF,W
1862:  BZ    186C
1864:  BRA    1868
1866:  NOP   
1868:  DECFSZ FEF,F
186A:  BRA    1866
186C:  MOVLB  0
186E:  GOTO   1888 (RETURN)
*
232C:  MOVLW  01
232E:  MOVWF  FEA
2330:  MOVLW  D3
2332:  MOVWF  FE9
2334:  MOVF   FEF,W
2336:  BZ    2354
2338:  MOVLW  05
233A:  MOVWF  01
233C:  CLRF   00
233E:  DECFSZ 00,F
2340:  BRA    233E
2342:  DECFSZ 01,F
2344:  BRA    233C
2346:  MOVLW  2E
2348:  MOVWF  00
234A:  DECFSZ 00,F
234C:  BRA    234A
234E:  BRA    2350
2350:  DECFSZ FEF,F
2352:  BRA    2338
2354:  RETLW  00
....................  
.................... /*=================== CONFIGURACION LIBRERIAS DE COMUNICACION ================*/ 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
.................... //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#use i2c(master, sda=PIN_B0, scl=PIN_B1) 
.................... //#use fixed_io(b_outputs=PIN_B0, PIN_B1) 
.................... //#use i2c(master, FORCE_HW) 
.................... /*=================== LIBRERIAS ESTANDAR PARA EL MANEJO DE DATOS =============*/ 
....................  
.................... #endif   //ifndef NUCLEO_H 
....................  
.................... #define use_rtos 
.................... #ifdef use_rtos 
....................    #use RTOS(timer=0, minor_cycle=50ms, statistics) 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
16B0:  MOVFF  290,295
16B4:  MOVFF  28F,294
16B8:  MOVLB  2
16BA:  MOVF   x93,F
16BC:  BZ    1706
16BE:  MOVFF  292,03
16C2:  MOVFF  291,FE9
16C6:  MOVFF  292,FEA
16CA:  MOVF   FEF,F
16CC:  BZ    1706
....................      *s++ = *s2++; 
16CE:  MOVFF  295,03
16D2:  MOVF   x94,W
16D4:  INCF   x94,F
16D6:  BTFSC  FD8.2
16D8:  INCF   x95,F
16DA:  MOVWF  x96
16DC:  MOVFF  03,297
16E0:  MOVFF  292,03
16E4:  MOVF   x91,W
16E6:  INCF   x91,F
16E8:  BTFSC  FD8.2
16EA:  INCF   x92,F
16EC:  MOVWF  FE9
16EE:  MOVFF  03,FEA
16F2:  MOVFF  FEF,298
16F6:  MOVFF  297,FEA
16FA:  MOVFF  296,FE9
16FE:  MOVFF  298,FEF
1702:  DECF   x93,F
1704:  BRA    16BA
....................   for (; n > 0; n--) 
1706:  MOVF   x93,F
1708:  BZ    1722
....................      *s++ = '\0'; 
170A:  MOVFF  295,03
170E:  MOVF   x94,W
1710:  INCF   x94,F
1712:  BTFSC  FD8.2
1714:  INCF   x95,F
1716:  MOVWF  FE9
1718:  MOVFF  03,FEA
171C:  CLRF   FEF
171E:  DECF   x93,F
1720:  BRA    1706
....................  
....................   return(s1); 
1722:  MOVFF  28F,01
1726:  MOVFF  290,02
.................... } 
172A:  MOVLB  0
172C:  GOTO   178C (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
14C2:  MOVFF  290,292
14C6:  MOVFF  28F,291
14CA:  MOVFF  292,03
14CE:  MOVLB  2
14D0:  MOVFF  291,FE9
14D4:  MOVFF  292,FEA
14D8:  MOVF   FEF,F
14DA:  BZ    14E8
14DC:  INCF   x91,F
14DE:  BTFSC  FD8.2
14E0:  INCF   x92,F
14E2:  MOVLB  0
14E4:  BRA    14CA
14E6:  MOVLB  2
....................    return(sc - s); 
14E8:  MOVF   x8F,W
14EA:  SUBWF  x91,W
14EC:  MOVWF  00
14EE:  MOVF   x90,W
14F0:  SUBWFB x92,W
14F2:  MOVWF  03
14F4:  MOVFF  00,01
.................... } 
14F8:  MOVLB  0
14FA:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// Two examples are provided:                                        //// 
.................... ////      ex_usb_serial.c                                              //// 
.................... ////      ex_usb_serial2.c                                             //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /*============================================================================ 
.................... CDC USB descriptor propio para el manejo de datos por usb 
....................  
....................  
....................  
....................  
....................  
.................... ============================================================================*/ 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x000B 
.................... #define  USB_CONFIG_VID       0x04D8 
.................... #define  USB_CONFIG_BUS_POWER 0x64   		//100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #define USB_HID_DEVICE  FALSE 
.................... #define USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................     
....................    /*	 
....................    ////////////////////////////////////////// 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................    /////////////////////////////////////////// 
....................    */ 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
....................          0x0B,0x00, //product id   ==10,11 
....................          0x00,0x01, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //#if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          40, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          '_',0, 
....................          'C',0, 
....................          'o',0, 
....................          'n',0, 
....................          't',0, 
....................          'r',0, 
....................          'o',0, 
....................          'l',0, 
....................          '_',0, 
....................          'D',0, 
....................          'e',0, 
....................          'v',0, 
....................          'i',0, 
....................          'c',0, 
....................          'e',0, 
....................          's',0 
....................  
.................... }; 
.................... //#endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0BEE:  CLRF   03
0BF0:  MOVLB  2
0BF2:  MOVF   xB9,W
0BF4:  ADDLW  70
0BF6:  MOVWF  FE9
0BF8:  MOVLW  0F
0BFA:  ADDWFC 03,W
0BFC:  MOVWF  FEA
0BFE:  MOVF   FEF,F
0C00:  BZ    0C26
0C02:  MOVF   xB9,W
0C04:  MULLW  08
0C06:  MOVF   FF3,W
0C08:  CLRF   xBB
0C0A:  MOVWF  xBA
0C0C:  MOVLW  04
0C0E:  ADDWF  xBA,F
0C10:  MOVLW  00
0C12:  ADDWFC xBB,F
0C14:  MOVFF  2BA,FE9
0C18:  MOVLW  04
0C1A:  ADDWF  xBB,W
0C1C:  MOVWF  FEA
0C1E:  MOVFF  FEF,2BA
0C22:  BTFSS  xBA.7
0C24:  BRA    0C2A
0C26:  MOVLW  00
0C28:  BRA    0C2C
0C2A:  MOVLW  01
0C2C:  MOVWF  01
.................... } 
0C2E:  MOVLB  0
0C30:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
1B88:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1B8A:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1B8C:  MOVLW  08
1B8E:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
1B90:  MOVF   F94,W
1B92:  IORLW  30
1B94:  MOVLB  2
1B96:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1B98:  CLRF   28
1B9A:  CLRF   16
1B9C:  BTFSC  FF2.7
1B9E:  BSF    16.7
1BA0:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
1BA2:  MOVLB  0
1BA4:  CALL   03DC
1BA8:  BTFSC  16.7
1BAA:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
1BAC:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
1B66:  CLRF   16
1B68:  BTFSC  FF2.7
1B6A:  BSF    16.7
1B6C:  BCF    FF2.7
....................    usb_token_reset(); 
1B6E:  CALL   03DC
1B72:  BTFSC  16.7
1B74:  BSF    FF2.7
....................    UCON = 0; 
1B76:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1B78:  MOVLW  14
1B7A:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
1B7C:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1B7E:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1B80:  MOVLW  01
1B82:  MOVWF  28
.................... } 
1B84:  GOTO   1BBA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
2316:  RCALL  1B88
.................... } 
2318:  GOTO   2324 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
*
1BAE:  BSF    F95.3
1BB0:  BTFSS  F83.3
1BB2:  BRA    1BBC
....................    { 
....................       if (UCON_USBEN==0)  
1BB4:  BTFSC  F6D.3
1BB6:  BRA    1BBA
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1BB8:  BRA    1B66
....................       } 
....................    } 
....................    else  
1BBA:  BRA    1BC2
....................    { 
....................       if (UCON_USBEN==1)   
1BBC:  BTFSS  F6D.3
1BBE:  BRA    1BC2
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
1BC0:  RCALL  1B88
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1BC2:  DECFSZ 28,W
1BC4:  BRA    1BDC
1BC6:  BTFSC  F6D.5
1BC8:  BRA    1BDC
....................    { 
....................       UIR=0; 
1BCA:  CLRF   F68
....................       UIE=0; 
1BCC:  CLRF   F69
....................       enable_interrupts(INT_USB); 
1BCE:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1BD0:  MOVLW  C0
1BD2:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1BD4:  MOVLW  11
1BD6:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1BD8:  MOVLW  02
1BDA:  MOVWF  28
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1BDC:  GOTO   1BEA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0C32:  MOVFF  2B4,2B9
0C36:  RCALL  0BEE
0C38:  MOVF   01,F
0C3A:  BZ    0D04
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0C3C:  MOVLB  2
0C3E:  MOVF   xB4,W
0C40:  MULLW  08
0C42:  MOVF   FF3,W
0C44:  CLRF   xBA
0C46:  MOVWF  xB9
0C48:  MOVLW  04
0C4A:  ADDWF  xB9,F
0C4C:  MOVLW  00
0C4E:  ADDWFC xBA,F
0C50:  MOVLW  01
0C52:  ADDWF  xB9,W
0C54:  MOVWF  01
0C56:  MOVLW  00
0C58:  ADDWFC xBA,W
0C5A:  MOVWF  03
0C5C:  MOVFF  01,FE9
0C60:  MOVLW  04
0C62:  ADDWF  03,W
0C64:  MOVWF  FEA
0C66:  MOVFF  2B5,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0C6A:  MOVF   xB7,W
0C6C:  SUBLW  02
0C6E:  BNZ   0C9E
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0C70:  MOVF   xB4,W
0C72:  MULLW  08
0C74:  MOVF   FF3,W
0C76:  CLRF   xBA
0C78:  MOVWF  xB9
0C7A:  MOVLW  04
0C7C:  ADDWF  xB9,F
0C7E:  MOVLW  00
0C80:  ADDWFC xBA,F
0C82:  MOVFF  2B9,FE9
0C86:  MOVLW  04
0C88:  ADDWF  xBA,W
0C8A:  MOVWF  FEA
0C8C:  MOVFF  FEF,2B8
....................          if (bit_test(i,6)) 
0C90:  BTFSS  xB8.6
0C92:  BRA    0C98
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0C94:  CLRF   xB7
....................          else 
0C96:  BRA    0C9C
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0C98:  MOVLW  01
0C9A:  MOVWF  xB7
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0C9C:  BRA    0CC4
0C9E:  MOVF   xB7,W
0CA0:  SUBLW  04
0CA2:  BNZ   0CC4
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0CA4:  MOVF   xB4,W
0CA6:  MULLW  08
0CA8:  MOVF   FF3,W
0CAA:  CLRF   xBA
0CAC:  MOVWF  FE9
0CAE:  MOVLW  04
0CB0:  ADDWF  xBA,W
0CB2:  MOVWF  FEA
0CB4:  MOVFF  FEF,2B8
....................          if (bit_test(i,6)) 
0CB8:  BTFSS  xB8.6
0CBA:  BRA    0CC2
....................             tgl = USB_DTS_DATA1; 
0CBC:  MOVLW  01
0CBE:  MOVWF  xB7
....................          else 
0CC0:  BRA    0CC4
....................             tgl = USB_DTS_DATA0; 
0CC2:  CLRF   xB7
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0CC4:  DECFSZ xB7,W
0CC6:  BRA    0CCE
....................          i=0xC8;  //DATA1, UOWN 
0CC8:  MOVLW  C8
0CCA:  MOVWF  xB8
....................       else //if (tgl == USB_DTS_DATA0)  
0CCC:  BRA    0CD2
....................          i=0x88; //DATA0, UOWN 
0CCE:  MOVLW  88
0CD0:  MOVWF  xB8
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0CD2:  BTFSC  xB6.0
0CD4:  BSF    xB8.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0CD6:  BTFSC  xB6.1
0CD8:  BSF    xB8.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0CDA:  MOVF   xB4,W
0CDC:  MULLW  08
0CDE:  MOVF   FF3,W
0CE0:  CLRF   xBA
0CE2:  MOVWF  xB9
0CE4:  MOVLW  04
0CE6:  ADDWF  xB9,F
0CE8:  MOVLW  00
0CEA:  ADDWFC xBA,F
0CEC:  MOVFF  2B9,FE9
0CF0:  MOVLW  04
0CF2:  ADDWF  xBA,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  2B8,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0CFA:  MOVLW  01
0CFC:  MOVWF  01
0CFE:  BRA    0D0A
....................    } 
....................    else  
0D00:  BRA    0D02
0D02:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0D04:  MOVLW  00
0D06:  MOVWF  01
0D08:  MOVLB  2
.................... } 
0D0A:  MOVLB  0
0D0C:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
0E0C:  MOVFF  2AC,2B9
0E10:  RCALL  0BEE
0E12:  MOVF   01,F
0E14:  BZ    0E98
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0E16:  MOVLB  2
0E18:  MOVF   xAC,W
0E1A:  MULLW  08
0E1C:  MOVF   FF3,W
0E1E:  CLRF   xB5
0E20:  MOVWF  xB4
0E22:  MOVLW  04
0E24:  ADDWF  xB4,F
0E26:  MOVLW  00
0E28:  ADDWFC xB5,F
0E2A:  MOVLW  02
0E2C:  ADDWF  xB4,W
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  ADDWFC xB5,W
0E34:  MOVWF  03
0E36:  MOVFF  01,FE9
0E3A:  MOVLW  04
0E3C:  ADDWF  03,W
0E3E:  MOVWF  FEA
0E40:  MOVFF  FEC,03
0E44:  MOVF   FED,F
0E46:  MOVFF  FEF,2B2
0E4A:  MOVFF  03,2B3
....................       memcpy(buff_add, ptr, len);      
0E4E:  MOVFF  2B3,FEA
0E52:  MOVFF  2B2,FE9
0E56:  MOVFF  2AE,FE2
0E5A:  MOVFF  2AD,FE1
0E5E:  MOVFF  2B0,02
0E62:  MOVFF  2AF,01
0E66:  MOVF   01,F
0E68:  BZ    0E6E
0E6A:  INCF   02,F
0E6C:  BRA    0E72
0E6E:  MOVF   02,F
0E70:  BZ    0E7E
0E72:  MOVFF  FE6,FEE
0E76:  DECFSZ 01,F
0E78:  BRA    0E72
0E7A:  DECFSZ 02,F
0E7C:  BRA    0E72
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
0E7E:  MOVFF  2AC,2B4
0E82:  MOVFF  2B0,2B6
0E86:  MOVFF  2AF,2B5
0E8A:  MOVFF  2B1,2B7
0E8E:  MOVLB  0
0E90:  RCALL  0C32
0E92:  MOVF   01,W
0E94:  BRA    0E9C
....................    } 
....................    else  
0E96:  BRA    0E98
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0E98:  MOVLW  00
0E9A:  MOVWF  01
.................... } 
0E9C:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0B24:  MOVLB  2
0B26:  MOVF   xAB,W
0B28:  MULLW  08
0B2A:  MOVF   FF3,W
0B2C:  CLRF   xB1
0B2E:  MOVWF  FE9
0B30:  MOVLW  04
0B32:  ADDWF  xB1,W
0B34:  MOVWF  FEA
0B36:  MOVFF  FEF,2AD
....................    if (tgl == USB_DTS_TOGGLE)  
0B3A:  MOVF   xAC,W
0B3C:  SUBLW  02
0B3E:  BNZ   0B4C
....................    { 
....................       if (bit_test(i,6)) 
0B40:  BTFSS  xAD.6
0B42:  BRA    0B48
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0B44:  CLRF   xAC
....................       else 
0B46:  BRA    0B4C
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0B48:  MOVLW  01
0B4A:  MOVWF  xAC
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0B4C:  MOVF   xAC,W
0B4E:  SUBLW  03
0B50:  BNZ   0B78
....................    { 
....................       i = 0x84; 
0B52:  MOVLW  84
0B54:  MOVWF  xAD
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0B56:  MOVF   xAB,W
0B58:  MULLW  08
0B5A:  MOVF   FF3,W
0B5C:  CLRF   xB1
0B5E:  MOVWF  xB0
0B60:  MOVLW  04
0B62:  ADDWF  xB0,F
0B64:  MOVLW  00
0B66:  ADDWFC xB1,F
0B68:  MOVFF  2B0,FE9
0B6C:  MOVLW  04
0B6E:  ADDWF  xB1,W
0B70:  MOVWF  FEA
0B72:  MOVLW  84
0B74:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0B76:  BRA    0B86
0B78:  DECFSZ xAC,W
0B7A:  BRA    0B82
....................       i = 0xC8;  //DATA1, UOWN 
0B7C:  MOVLW  C8
0B7E:  MOVWF  xAD
....................    else //if (tgl == USB_DTS_DATA0)  
0B80:  BRA    0B86
....................       i = 0x88; //DATA0, UOWN 
0B82:  MOVLW  88
0B84:  MOVWF  xAD
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0B86:  BCF    FD8.0
0B88:  RLCF   xAB,W
0B8A:  CLRF   03
0B8C:  MOVFF  FF2,2B0
0B90:  BCF    FF2.7
0B92:  MOVLB  0
0B94:  CALL   012A
0B98:  TBLRD*+
0B9A:  MOVFF  FF5,03
0B9E:  MOVLB  2
0BA0:  BTFSC  xB0.7
0BA2:  BSF    FF2.7
0BA4:  MOVWF  xAE
0BA6:  MOVFF  03,2AF
....................    EP_BDxCNT_O(endpoint) = len; 
0BAA:  MOVF   xAB,W
0BAC:  MULLW  08
0BAE:  MOVF   FF3,W
0BB0:  CLRF   xB1
0BB2:  MOVWF  xB0
0BB4:  MOVLW  01
0BB6:  ADDWF  xB0,W
0BB8:  MOVWF  01
0BBA:  MOVLW  00
0BBC:  ADDWFC xB1,W
0BBE:  MOVWF  03
0BC0:  MOVFF  01,FE9
0BC4:  MOVLW  04
0BC6:  ADDWF  03,W
0BC8:  MOVWF  FEA
0BCA:  MOVFF  2AE,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0BCE:  BTFSC  xAF.0
0BD0:  BSF    xAD.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0BD2:  BTFSC  xAF.1
0BD4:  BSF    xAD.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0BD6:  MOVF   xAB,W
0BD8:  MULLW  08
0BDA:  MOVF   FF3,W
0BDC:  CLRF   xB1
0BDE:  MOVWF  FE9
0BE0:  MOVLW  04
0BE2:  ADDWF  xB1,W
0BE4:  MOVWF  FEA
0BE6:  MOVFF  2AD,FEF
.................... } 
0BEA:  MOVLB  0
0BEC:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
0D7E:  MOVLB  2
0D80:  MOVF   xAC,W
0D82:  MULLW  08
0D84:  MOVF   FF3,W
0D86:  CLRF   xAE
0D88:  MOVWF  xAD
0D8A:  MOVLW  01
0D8C:  ADDWF  xAD,W
0D8E:  MOVWF  01
0D90:  MOVLW  00
0D92:  ADDWFC xAE,W
0D94:  MOVWF  03
0D96:  MOVFF  01,FE9
0D9A:  MOVLW  04
0D9C:  ADDWF  03,W
0D9E:  MOVWF  FEA
0DA0:  CLRF   03
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
.................... } 
0DAA:  MOVLB  0
0DAC:  GOTO   0DBE (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
092C:  MOVLB  2
092E:  BCF    xAC.0
0930:  BTFSC  xAB.7
0932:  BSF    xAC.0
....................    endpoint &= 0x7F; 
0934:  BCF    xAB.7
....................     
....................    if (direction)  
0936:  BTFSS  xAC.0
0938:  BRA    095C
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
093A:  MOVF   xAB,W
093C:  MULLW  08
093E:  MOVF   FF3,W
0940:  CLRF   xAE
0942:  MOVWF  xAD
0944:  MOVLW  04
0946:  ADDWF  xAD,F
0948:  MOVLW  00
094A:  ADDWFC xAE,F
094C:  MOVFF  2AD,FE9
0950:  MOVLW  04
0952:  ADDWF  xAE,W
0954:  MOVWF  FEA
0956:  MOVLW  84
0958:  MOVWF  FEF
....................    } 
....................    else  
095A:  BRA    0970
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
095C:  MOVF   xAB,W
095E:  MULLW  08
0960:  MOVF   FF3,W
0962:  CLRF   xAE
0964:  MOVWF  FE9
0966:  MOVLW  04
0968:  ADDWF  xAE,W
096A:  MOVWF  FEA
096C:  MOVLW  84
096E:  MOVWF  FEF
....................    } 
.................... } 
0970:  MOVLB  0
0972:  GOTO   0A04 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08E4:  MOVLB  2
08E6:  BCF    xAC.0
08E8:  BTFSC  xAB.7
08EA:  BSF    xAC.0
....................    endpoint &= 0x7F; 
08EC:  BCF    xAB.7
....................     
....................    if (direction)  
08EE:  BTFSS  xAC.0
08F0:  BRA    0914
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
08F2:  MOVF   xAB,W
08F4:  MULLW  08
08F6:  MOVF   FF3,W
08F8:  CLRF   xAE
08FA:  MOVWF  xAD
08FC:  MOVLW  04
08FE:  ADDWF  xAD,F
0900:  MOVLW  00
0902:  ADDWFC xAE,F
0904:  MOVFF  2AD,FE9
0908:  MOVLW  04
090A:  ADDWF  xAE,W
090C:  MOVWF  FEA
090E:  MOVLW  88
0910:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
0912:  BRA    0926
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0914:  MOVF   xAB,W
0916:  MULLW  08
0918:  MOVF   FF3,W
091A:  CLRF   xAE
091C:  MOVWF  FE9
091E:  MOVLW  04
0920:  ADDWF  xAE,W
0922:  MOVWF  FEA
0924:  CLRF   FEF
....................    } 
.................... } 
0926:  MOVLB  0
0928:  GOTO   09F4 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0976:  MOVLB  2
0978:  BCF    xAC.0
097A:  BTFSC  xAB.7
097C:  BSF    xAC.0
....................    endpoint &= 0x7F; 
097E:  BCF    xAB.7
....................     
....................    if (direction)  
0980:  BTFSS  xAC.0
0982:  BRA    09A6
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0984:  MOVF   xAB,W
0986:  MULLW  08
0988:  MOVF   FF3,W
098A:  CLRF   xAF
098C:  MOVWF  xAE
098E:  MOVLW  04
0990:  ADDWF  xAE,F
0992:  MOVLW  00
0994:  ADDWFC xAF,F
0996:  MOVFF  2AE,FE9
099A:  MOVLW  04
099C:  ADDWF  xAF,W
099E:  MOVWF  FEA
09A0:  MOVFF  FEF,2AD
....................    } 
....................    else  
09A4:  BRA    09BA
....................    { 
....................       st=EP_BDxST_O(endpoint); 
09A6:  MOVF   xAB,W
09A8:  MULLW  08
09AA:  MOVF   FF3,W
09AC:  CLRF   xAF
09AE:  MOVWF  FE9
09B0:  MOVLW  04
09B2:  ADDWF  xAF,W
09B4:  MOVWF  FEA
09B6:  MOVFF  FEF,2AD
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
09BA:  BTFSS  xAD.7
09BC:  BRA    09C2
09BE:  BTFSC  xAD.2
09C0:  BRA    09C6
09C2:  MOVLW  00
09C4:  BRA    09C8
09C6:  MOVLW  01
09C8:  MOVWF  01
.................... } 
09CA:  MOVLB  0
09CC:  GOTO   0A1C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
0DE4:  MOVFF  2AC,F6E
....................     
....................    if (address)  
0DE8:  MOVLB  2
0DEA:  MOVF   xAC,F
0DEC:  BZ    0DF4
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0DEE:  MOVLW  04
0DF0:  MOVWF  28
....................    } 
....................    else  
0DF2:  BRA    0DF8
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0DF4:  MOVLW  02
0DF6:  MOVWF  28
....................    } 
.................... } 
0DF8:  MOVLB  0
0DFA:  GOTO   0E08 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
05B0:  MOVLB  2
05B2:  MOVF   xAB,F
05B4:  BNZ   05C2
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
05B6:  MOVLW  04
05B8:  MOVWF  28
....................       usb_disable_endpoints(); 
05BA:  MOVLB  0
05BC:  RCALL  039C
....................    } 
....................    else  
05BE:  BRA    077C
05C0:  MOVLB  2
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
05C2:  MOVLW  05
05C4:  MOVWF  28
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
05C6:  MOVLW  04
05C8:  MOVWF  xAE
05CA:  MOVLW  28
05CC:  MOVWF  xAD
....................       for (en=1; en<USB_NUM_UEP; en++)  
05CE:  MOVLW  01
05D0:  MOVWF  xAC
05D2:  MOVF   xAC,W
05D4:  SUBLW  0F
05D6:  BTFSS  FD8.0
05D8:  BRA    077C
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
05DA:  MOVFF  2AC,2B4
05DE:  MOVLB  0
05E0:  RCALL  0348
....................          new_uep = 0; 
05E2:  MOVLB  2
05E4:  CLRF   xAF
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
05E6:  CLRF   03
05E8:  MOVF   xAC,W
05EA:  MOVFF  FF2,2B3
05EE:  BCF    FF2.7
05F0:  MOVLB  0
05F2:  RCALL  00DA
05F4:  MOVLB  2
05F6:  BTFSC  xB3.7
05F8:  BSF    FF2.7
05FA:  SUBLW  FF
05FC:  BZ    06B4
....................          { 
....................             new_uep = 0x04; 
05FE:  MOVLW  04
0600:  MOVWF  xAF
....................             len = usb_ep_rx_size[en]; 
0602:  BCF    FD8.0
0604:  RLCF   xAC,W
0606:  CLRF   03
0608:  MOVFF  FF2,2B3
060C:  BCF    FF2.7
060E:  MOVLB  0
0610:  RCALL  012A
0612:  TBLRD*+
0614:  MOVFF  FF5,03
0618:  MOVLB  2
061A:  BTFSC  xB3.7
061C:  BSF    FF2.7
061E:  MOVWF  xB0
0620:  MOVFF  03,2B1
....................             EP_BDxCNT_O(en) = len; 
0624:  MOVF   xAC,W
0626:  MULLW  08
0628:  MOVF   FF3,W
062A:  CLRF   xB4
062C:  MOVWF  xB3
062E:  MOVLW  01
0630:  ADDWF  xB3,W
0632:  MOVWF  01
0634:  MOVLW  00
0636:  ADDWFC xB4,W
0638:  MOVWF  03
063A:  MOVFF  01,FE9
063E:  MOVLW  04
0640:  ADDWF  03,W
0642:  MOVWF  FEA
0644:  MOVFF  2B0,FEF
....................             EP_BDxADR_O(en) = addy; 
0648:  MOVF   xAC,W
064A:  MULLW  08
064C:  MOVF   FF3,W
064E:  CLRF   xB4
0650:  MOVWF  xB3
0652:  MOVLW  02
0654:  ADDWF  xB3,W
0656:  MOVWF  01
0658:  MOVLW  00
065A:  ADDWFC xB4,W
065C:  MOVWF  03
065E:  MOVFF  01,FE9
0662:  MOVLW  04
0664:  ADDWF  03,W
0666:  MOVWF  FEA
0668:  MOVFF  2AE,FEC
066C:  MOVF   FED,F
066E:  MOVFF  2AD,FEF
....................             addy += usb_ep_rx_size[en]; 
0672:  BCF    FD8.0
0674:  RLCF   xAC,W
0676:  CLRF   03
0678:  MOVFF  FF2,2B3
067C:  BCF    FF2.7
067E:  MOVLB  0
0680:  RCALL  012A
0682:  TBLRD*+
0684:  MOVFF  FF5,03
0688:  MOVLB  2
068A:  BTFSC  xB3.7
068C:  BSF    FF2.7
068E:  ADDWF  xAD,F
0690:  MOVF   03,W
0692:  ADDWFC xAE,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0694:  MOVLW  88
0696:  MOVWF  xB2
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0698:  BTFSC  xB1.0
069A:  BSF    xB2.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
069C:  BTFSC  xB1.1
069E:  BSF    xB2.1
....................             EP_BDxST_O(en) = i; 
06A0:  MOVF   xAC,W
06A2:  MULLW  08
06A4:  MOVF   FF3,W
06A6:  CLRF   xB4
06A8:  MOVWF  FE9
06AA:  MOVLW  04
06AC:  ADDWF  xB4,W
06AE:  MOVWF  FEA
06B0:  MOVFF  2B2,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
06B4:  CLRF   03
06B6:  MOVF   xAC,W
06B8:  MOVFF  FF2,2B3
06BC:  BCF    FF2.7
06BE:  MOVLB  0
06C0:  RCALL  00BA
06C2:  MOVLB  2
06C4:  BTFSC  xB3.7
06C6:  BSF    FF2.7
06C8:  SUBLW  FF
06CA:  BZ    0742
....................          { 
....................             new_uep |= 0x02; 
06CC:  BSF    xAF.1
....................             EP_BDxADR_I(en) = addy; 
06CE:  MOVF   xAC,W
06D0:  MULLW  08
06D2:  MOVF   FF3,W
06D4:  CLRF   xB4
06D6:  MOVWF  xB3
06D8:  MOVLW  04
06DA:  ADDWF  xB3,F
06DC:  MOVLW  00
06DE:  ADDWFC xB4,F
06E0:  MOVLW  02
06E2:  ADDWF  xB3,W
06E4:  MOVWF  01
06E6:  MOVLW  00
06E8:  ADDWFC xB4,W
06EA:  MOVWF  03
06EC:  MOVFF  01,FE9
06F0:  MOVLW  04
06F2:  ADDWF  03,W
06F4:  MOVWF  FEA
06F6:  MOVFF  2AE,FEC
06FA:  MOVF   FED,F
06FC:  MOVFF  2AD,FEF
....................             addy += usb_ep_tx_size[en]; 
0700:  BCF    FD8.0
0702:  RLCF   xAC,W
0704:  CLRF   03
0706:  MOVFF  FF2,2B3
070A:  BCF    FF2.7
070C:  MOVLB  0
070E:  RCALL  00FA
0710:  TBLRD*+
0712:  MOVFF  FF5,03
0716:  MOVLB  2
0718:  BTFSC  xB3.7
071A:  BSF    FF2.7
071C:  ADDWF  xAD,F
071E:  MOVF   03,W
0720:  ADDWFC xAE,F
....................             EP_BDxST_I(en) = 0x40; 
0722:  MOVF   xAC,W
0724:  MULLW  08
0726:  MOVF   FF3,W
0728:  CLRF   xB4
072A:  MOVWF  xB3
072C:  MOVLW  04
072E:  ADDWF  xB3,F
0730:  MOVLW  00
0732:  ADDWFC xB4,F
0734:  MOVFF  2B3,FE9
0738:  MOVLW  04
073A:  ADDWF  xB4,W
073C:  MOVWF  FEA
073E:  MOVLW  40
0740:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
0742:  MOVF   xAF,W
0744:  SUBLW  06
0746:  BNZ   074C
0748:  MOVLW  0E
074A:  MOVWF  xAF
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
074C:  CLRF   03
074E:  MOVF   xAC,W
0750:  MOVFF  FF2,2B3
0754:  BCF    FF2.7
0756:  MOVLB  0
0758:  RCALL  00BA
075A:  MOVLB  2
075C:  BTFSC  xB3.7
075E:  BSF    FF2.7
0760:  SUBLW  01
0762:  BTFSS  FD8.2
0764:  BSF    xAF.4
....................           
....................          UEP(en) = new_uep; 
0766:  CLRF   03
0768:  MOVF   xAC,W
076A:  ADDLW  70
076C:  MOVWF  FE9
076E:  MOVLW  0F
0770:  ADDWFC 03,W
0772:  MOVWF  FEA
0774:  MOVFF  2AF,FEF
....................       } 
0778:  INCF   xAC,F
077A:  BRA    05D2
077C:  MOVLB  0
....................    } 
.................... } 
077E:  GOTO   0826 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0348:  CLRF   03
034A:  MOVLB  2
034C:  MOVF   xB4,W
034E:  ADDLW  70
0350:  MOVWF  FE9
0352:  MOVLW  0F
0354:  ADDWFC 03,W
0356:  MOVWF  FEA
0358:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
035A:  MOVFF  2B4,2B5
035E:  MOVLB  0
0360:  RCALL  02E4
0362:  MOVF   01,F
0364:  BZ    0398
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
0366:  MOVLB  2
0368:  MOVF   xB4,W
036A:  MULLW  08
036C:  MOVF   FF3,W
036E:  CLRF   xB6
0370:  MOVWF  FE9
0372:  MOVLW  04
0374:  ADDWF  xB6,W
0376:  MOVWF  FEA
0378:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
037A:  MOVF   xB4,W
037C:  MULLW  08
037E:  MOVF   FF3,W
0380:  CLRF   xB6
0382:  MOVWF  xB5
0384:  MOVLW  04
0386:  ADDWF  xB5,F
0388:  MOVLW  00
038A:  ADDWFC xB6,F
038C:  MOVFF  2B5,FE9
0390:  MOVLW  04
0392:  ADDWF  xB6,W
0394:  MOVWF  FEA
0396:  CLRF   FEF
0398:  MOVLB  0
....................    } 
.................... } 
039A:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
039C:  MOVLW  01
039E:  MOVLB  2
03A0:  MOVWF  xB3
03A2:  MOVF   xB3,W
03A4:  SUBLW  0F
03A6:  BNC   03B6
....................       usb_disable_endpoint(i); 
03A8:  MOVFF  2B3,2B4
03AC:  MOVLB  0
03AE:  RCALL  0348
03B0:  MOVLB  2
03B2:  INCF   xB3,F
03B4:  BRA    03A2
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
03B6:  MOVLB  0
03B8:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
1076:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
1078:  MOVF   28,F
107A:  BNZ   107E
107C:  BRA    10FA
....................    if (UIR)  
107E:  MOVF   F68,F
1080:  BZ    10FA
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
1082:  BTFSS  F68.2
1084:  BRA    108E
1086:  BTFSS  F69.2
1088:  BRA    108E
108A:  GOTO   029E
....................  
....................       if (UCON_SUSPND) return; 
108E:  BTFSS  F6D.1
1090:  BRA    1094
1092:  BRA    10FA
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
1094:  BTFSS  F68.5
1096:  BRA    10A0
1098:  BTFSS  F69.5
109A:  BRA    10A0
109C:  GOTO   02CE
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
10A0:  BTFSS  F68.1
10A2:  BRA    10AC
10A4:  BTFSS  F69.1
10A6:  BRA    10AC
10A8:  GOTO   02DC
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
10AC:  BTFSS  F68.0
10AE:  BRA    10B8
10B0:  BTFSS  F69.0
10B2:  BRA    10B8
10B4:  GOTO   0408
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
10B8:  BTFSS  F68.4
10BA:  BRA    10C4
10BC:  BTFSS  F69.4
10BE:  BRA    10C4
10C0:  GOTO   0432
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
10C4:  BTFSS  F68.6
10C6:  BRA    10D0
10C8:  BTFSS  F69.6
10CA:  BRA    10D0
10CC:  GOTO   043C
....................  
....................       TRNAttempts = 0; 
10D0:  MOVLB  2
10D2:  CLRF   xA8
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
10D4:  BTFSS  F68.3
10D6:  BRA    10EC
10D8:  BTFSS  F69.3
10DA:  BRA    10EC
....................          { 
....................             USTATCopy = U1STAT; 
10DC:  MOVFF  F6C,27
....................             usb_clear_trn(); 
10E0:  MOVLB  0
10E2:  CALL   0004
....................             usb_isr_tok_dne(); 
10E6:  BRA    0EFC
....................          } 
....................          else 
10E8:  BRA    10EE
10EA:  MOVLB  2
....................             break; 
10EC:  BRA    10F8
....................       } while (TRNAttempts++ < 4); 
10EE:  MOVLB  2
10F0:  MOVF   xA8,W
10F2:  INCF   xA8,F
10F4:  SUBLW  03
10F6:  BC    10D4
10F8:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
10FA:  GOTO   0078
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
043C:  BCF    F68.6
.................... } 
043E:  GOTO   10D0 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
0408:  CLRF   F6A
....................    UIR = 0; 
040A:  CLRF   F68
....................    UEIE = 0x9F; 
040C:  MOVLW  9F
040E:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0410:  MOVLW  3D
0412:  MOVWF  F69
....................  
....................    UADDR = 0; 
0414:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
0416:  RCALL  039C
....................     
....................    usb_token_reset(); 
0418:  RCALL  03DC
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
041A:  MOVLW  16
041C:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
041E:  BTFSS  F68.3
0420:  BRA    0426
....................       usb_clear_trn(); 
0422:  RCALL  0004
....................    } 
0424:  BRA    041E
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0426:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
0428:  RCALL  02AE
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
042A:  MOVLW  03
042C:  MOVWF  28
.................... } 
042E:  GOTO   10B8 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
02AE:  MOVLW  08
02B0:  MOVLB  4
02B2:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
02B4:  MOVLW  04
02B6:  MOVWF  x03
02B8:  MOVLW  18
02BA:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
02BC:  MOVLW  88
02BE:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
02C0:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
02C2:  MOVLW  04
02C4:  MOVWF  x07
02C6:  MOVLW  20
02C8:  MOVWF  x06
.................... } 
02CA:  MOVLB  0
02CC:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
02DC:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
02DE:  BCF    F68.1
.................... } 
02E0:  GOTO   10AC (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0432:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0434:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0436:  BSF    F6D.1
.................... } 
0438:  GOTO   10C4 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
029E:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
02A0:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
02A2:  BTFSS  F68.2
02A4:  BRA    02AA
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
02A6:  BCF    F68.2
....................    } 
02A8:  BRA    02A2
.................... } 
02AA:  GOTO   108E (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
02CE:  BTFSS  F70.0
02D0:  BRA    02D6
....................    { 
....................       usb_init_ep0_setup(); 
02D2:  RCALL  02AE
....................       bit_clear(UEP(0), 0); 
02D4:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
02D6:  BCF    F68.5
.................... } 
02D8:  GOTO   10A0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0442:  MOVFF  2AE,29
0446:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
0A3A:  MOVLW  FE
0A3C:  MOVWF  29
0A3E:  RETLW  00
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
0448:  MOVLW  FF
044A:  MOVWF  29
044C:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0EFC:  RRCF   27,W
0EFE:  MOVLB  2
0F00:  MOVWF  xA9
0F02:  RRCF   xA9,F
0F04:  RRCF   xA9,F
0F06:  MOVLW  1F
0F08:  ANDWF  xA9,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0F0A:  MOVF   27,F
0F0C:  BNZ   0FAC
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0F0E:  MOVLB  4
0F10:  MOVF   x00,W
0F12:  ANDLW  3C
0F14:  MOVLB  2
0F16:  MOVWF  xAA
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0F18:  MOVLW  43
0F1A:  MOVLB  4
0F1C:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0F1E:  MOVLB  2
0F20:  MOVF   xAA,W
0F22:  SUBLW  34
0F24:  BNZ   0F70
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0F26:  MOVLB  4
0F28:  MOVF   x04,W
0F2A:  ANDLW  80
0F2C:  BZ    0F30
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0F2E:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0F30:  MOVLB  0
0F32:  BRA    0AF0
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0F34:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0F36:  INCFSZ 29,W
0F38:  BRA    0F48
....................             usb_flush_out(0, USB_DTS_STALL); 
0F3A:  MOVLB  2
0F3C:  CLRF   xAB
0F3E:  MOVLW  03
0F40:  MOVWF  xAC
0F42:  MOVLB  0
0F44:  RCALL  0B24
....................          else  
0F46:  BRA    0F6C
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0F48:  MOVLB  2
0F4A:  CLRF   xAB
0F4C:  MOVLW  02
0F4E:  MOVWF  xAC
0F50:  MOVLB  0
0F52:  RCALL  0B24
....................             if (__setup_0_tx_size != 0xFE) 
0F54:  MOVF   29,W
0F56:  SUBLW  FE
0F58:  BZ    0F6C
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0F5A:  MOVLB  2
0F5C:  CLRF   xB4
0F5E:  CLRF   xB6
0F60:  MOVFF  29,2B5
0F64:  MOVLW  04
0F66:  MOVWF  xB7
0F68:  MOVLB  0
0F6A:  RCALL  0C32
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
0F6C:  BRA    0FA8
0F6E:  MOVLB  2
0F70:  MOVF   xAA,W
0F72:  SUBLW  04
0F74:  BNZ   0FAA
....................       { 
....................          usb_isr_tok_out_dne(0); 
0F76:  CLRF   xAB
0F78:  MOVLB  0
0F7A:  RCALL  0DC6
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0F7C:  MOVLB  2
0F7E:  CLRF   xAB
0F80:  MOVLW  02
0F82:  MOVWF  xAC
0F84:  MOVLB  0
0F86:  RCALL  0B24
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0F88:  MOVF   29,W
0F8A:  SUBLW  FE
0F8C:  BZ    0FA6
0F8E:  INCFSZ 29,W
0F90:  BRA    0F94
0F92:  BRA    0FA6
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0F94:  MOVLB  2
0F96:  CLRF   xB4
0F98:  CLRF   xB6
0F9A:  MOVFF  29,2B5
0F9E:  MOVLW  01
0FA0:  MOVWF  xB7
0FA2:  MOVLB  0
0FA4:  RCALL  0C32
....................          } 
....................       } 
....................       else 
0FA6:  BRA    0FA8
0FA8:  MOVLB  2
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
0FAA:  BRA    1070
0FAC:  MOVF   27,W
0FAE:  SUBLW  04
0FB0:  BNZ   0FE2
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
0FB2:  MOVLW  43
0FB4:  MOVLB  4
0FB6:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
0FB8:  MOVLW  FF
0FBA:  MOVWF  29
....................       usb_isr_tok_in_dne(0); 
0FBC:  MOVLB  2
0FBE:  CLRF   xAB
0FC0:  MOVLB  0
0FC2:  RCALL  0ECA
....................       if (__setup_0_tx_size!=0xFF) 
0FC4:  INCFSZ 29,W
0FC6:  BRA    0FCA
0FC8:  BRA    0FDE
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0FCA:  MOVLB  2
0FCC:  CLRF   xB4
0FCE:  CLRF   xB6
0FD0:  MOVFF  29,2B5
0FD4:  MOVLW  02
0FD6:  MOVWF  xB7
0FD8:  MOVLB  0
0FDA:  RCALL  0C32
....................       else 
0FDC:  BRA    0FDE
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
0FDE:  BRA    106E
0FE0:  MOVLB  2
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0FE2:  BTFSC  27.2
0FE4:  BRA    1020
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
0FE6:  MOVF   xA9,W
0FE8:  MULLW  08
0FEA:  MOVF   FF3,W
0FEC:  CLRF   xAC
0FEE:  MOVWF  01
0FF0:  MOVLW  04
0FF2:  ADDWF  xAC,W
0FF4:  MOVWF  03
0FF6:  MOVF   xA9,W
0FF8:  MULLW  08
0FFA:  MOVF   FF3,W
0FFC:  CLRF   xAE
0FFE:  MOVWF  FE9
1000:  MOVLW  04
1002:  ADDWF  xAE,W
1004:  MOVWF  FEA
1006:  MOVF   FEF,W
1008:  ANDLW  43
100A:  MOVFF  03,FEA
100E:  MOVFF  01,FE9
1012:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
1014:  MOVFF  2A9,2AB
1018:  MOVLB  0
101A:  RCALL  0DC6
....................       } 
....................       else  
101C:  BRA    106E
101E:  MOVLB  2
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
1020:  MOVF   xA9,W
1022:  MULLW  08
1024:  MOVF   FF3,W
1026:  CLRF   xAC
1028:  MOVWF  xAB
102A:  MOVLW  04
102C:  ADDWF  xAB,F
102E:  MOVLW  00
1030:  ADDWFC xAC,F
1032:  MOVFF  2AB,01
1036:  MOVLW  04
1038:  ADDWF  xAC,W
103A:  MOVWF  03
103C:  MOVF   xA9,W
103E:  MULLW  08
1040:  MOVF   FF3,W
1042:  CLRF   xAE
1044:  MOVWF  xAD
1046:  MOVLW  04
1048:  ADDWF  xAD,F
104A:  MOVLW  00
104C:  ADDWFC xAE,F
104E:  MOVFF  2AD,FE9
1052:  MOVLW  04
1054:  ADDWF  xAE,W
1056:  MOVWF  FEA
1058:  MOVF   FEF,W
105A:  ANDLW  43
105C:  MOVFF  03,FEA
1060:  MOVFF  2AB,FE9
1064:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
1066:  MOVFF  2A9,2AB
106A:  MOVLB  0
106C:  RCALL  0ECA
106E:  MOVLB  2
....................       } 
....................    } 
.................... } 
1070:  MOVLB  0
1072:  GOTO   10E8 (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1BE0:  MOVF   21,W
1BE2:  MOVWF  01
.................... } 
1BE4:  GOTO   1BF2 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
03DC:  MOVLB  2
03DE:  CLRF   xA9
03E0:  MOVF   xA9,W
03E2:  SUBLW  01
03E4:  BNC   03FA
....................       USB_Interface[i] = 0;   //reset each interface to default 
03E6:  CLRF   03
03E8:  MOVF   xA9,W
03EA:  ADDLW  2D
03EC:  MOVWF  FE9
03EE:  MOVLW  00
03F0:  ADDWFC 03,W
03F2:  MOVWF  FEA
03F4:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
03F6:  INCF   xA9,F
03F8:  BRA    03E0
....................    usb_cdc_init(); 
03FA:  MOVLB  0
03FC:  RCALL  03BA
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
03FE:  CLRF   21
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0400:  MOVLW  01
0402:  MOVWF  22
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0404:  CLRF   20
.................... } 
0406:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
02E4:  MOVLB  2
02E6:  BCF    xB6.0
02E8:  BTFSC  xB5.7
02EA:  BSF    xB6.0
....................     
....................    endpoint &= 0x7F; 
02EC:  BCF    xB5.7
....................     
....................    if (endpoint > 16) 
02EE:  MOVF   xB5,W
02F0:  SUBLW  10
02F2:  BC    02FA
....................       return(FALSE); 
02F4:  MOVLW  00
02F6:  MOVWF  01
02F8:  BRA    0344
....................     
....................    if (direction) { //IN 
02FA:  BTFSS  xB6.0
02FC:  BRA    0322
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
02FE:  CLRF   03
0300:  MOVF   xB5,W
0302:  MOVFF  FF2,2B7
0306:  BCF    FF2.7
0308:  MOVLB  0
030A:  RCALL  00BA
030C:  MOVLB  2
030E:  BTFSC  xB7.7
0310:  BSF    FF2.7
0312:  SUBLW  FF
0314:  BNZ   031A
0316:  MOVLW  00
0318:  BRA    031C
031A:  MOVLW  01
031C:  MOVWF  01
031E:  BRA    0344
....................    } 
....................    else {   //OUT 
0320:  BRA    0344
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
0322:  CLRF   03
0324:  MOVF   xB5,W
0326:  MOVFF  FF2,2B7
032A:  BCF    FF2.7
032C:  MOVLB  0
032E:  RCALL  00DA
0330:  MOVLB  2
0332:  BTFSC  xB7.7
0334:  BSF    FF2.7
0336:  SUBLW  FF
0338:  BNZ   033E
033A:  MOVLW  00
033C:  BRA    0340
033E:  MOVLW  01
0340:  MOVWF  01
0342:  BRA    0344
....................    } 
.................... } 
0344:  MOVLB  0
0346:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
0ECA:  MOVLB  2
0ECC:  MOVF   xAB,F
0ECE:  BNZ   0EEC
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0ED0:  DECFSZ 20,W
0ED2:  BRA    0EDE
0ED4:  MOVLB  0
0ED6:  CALL   044E
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0EDA:  BRA    0EE8
0EDC:  MOVLB  2
0EDE:  MOVF   20,W
0EE0:  SUBLW  02
0EE2:  BNZ   0EEA
0EE4:  MOVLB  0
0EE6:  BRA    0DFE
0EE8:  MOVLB  2
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0EEA:  BRA    0EF8
0EEC:  MOVF   xAB,W
0EEE:  SUBLW  02
0EF0:  BNZ   0EF8
....................       usb_isr_tok_in_cdc_data_dne(); 
0EF2:  MOVLB  0
0EF4:  BRA    0EC0
0EF6:  MOVLB  2
....................   } 
....................   #endif 
.................... } 
0EF8:  MOVLB  0
0EFA:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0DC6:  MOVLB  2
0DC8:  MOVF   xAB,F
0DCA:  BNZ   0DD4
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0DCC:  MOVLB  0
0DCE:  BRA    0D0E
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0DD0:  BRA    0DDE
0DD2:  MOVLB  2
0DD4:  MOVF   xAB,W
0DD6:  SUBLW  02
0DD8:  BNZ   0DE0
....................       usb_isr_tok_out_cdc_data_dne(); 
0DDA:  MOVLB  0
0DDC:  BRA    0DB0
0DDE:  MOVLB  2
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0DE0:  MOVLB  0
0DE2:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0AF0:  CLRF   20
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0AF2:  MOVLB  4
0AF4:  MOVF   x18,W
0AF6:  ANDLW  7F
0AF8:  XORLW  00
0AFA:  MOVLB  0
0AFC:  BZ    0B0C
0AFE:  XORLW  01
0B00:  BZ    0B10
0B02:  XORLW  03
0B04:  BZ    0B14
0B06:  XORLW  23
0B08:  BZ    0B18
0B0A:  BRA    0B1C
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0B0C:  BRA    0782
....................          break; 
0B0E:  BRA    0B20
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0B10:  BRA    083A
....................          break; 
0B12:  BRA    0B20
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0B14:  BRA    09D0
....................          break; 
0B16:  BRA    0B20
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
0B18:  BRA    0A40
....................          break; 
0B1A:  BRA    0B20
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0B1C:  RCALL  0448
....................          break; 
0B1E:  BRA    0B20
....................    } 
.................... } 
0B20:  GOTO   0F34 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0782:  MOVLB  4
0784:  MOVF   x19,W
0786:  XORLW  00
0788:  MOVLB  0
078A:  BZ    07A6
078C:  XORLW  01
078E:  BZ    07BA
0790:  XORLW  02
0792:  BZ    07D4
0794:  XORLW  06
0796:  BZ    07EC
0798:  XORLW  03
079A:  BZ    07FE
079C:  XORLW  0E
079E:  BZ    0802
07A0:  XORLW  01
07A2:  BZ    0812
07A4:  BRA    0832
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
07A6:  MOVFF  22,420
....................             usb_ep0_tx_buffer[1]=0; 
07AA:  MOVLB  4
07AC:  CLRF   x21
....................             usb_request_send_response(2); 
07AE:  MOVLW  02
07B0:  MOVLB  2
07B2:  MOVWF  xAE
07B4:  MOVLB  0
07B6:  RCALL  0442
....................             break; 
07B8:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
07BA:  MOVLB  4
07BC:  DECFSZ x1A,W
07BE:  BRA    07CE
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
07C0:  MOVLW  01
07C2:  ANDWF  22,F
....................                usb_put_0len_0(); 
07C4:  MOVLB  2
07C6:  CLRF   xAE
07C8:  MOVLB  0
07CA:  RCALL  0442
....................             } 
....................             else 
07CC:  BRA    07D2
....................                usb_request_stall(); 
07CE:  MOVLB  0
07D0:  RCALL  0448
....................             break; 
07D2:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
07D4:  MOVLB  4
07D6:  DECFSZ x1A,W
07D8:  BRA    07E6
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
07DA:  BSF    22.1
....................                usb_put_0len_0(); 
07DC:  MOVLB  2
07DE:  CLRF   xAE
07E0:  MOVLB  0
07E2:  RCALL  0442
....................             } 
....................             else 
07E4:  BRA    07EA
....................                usb_request_stall(); 
07E6:  MOVLB  0
07E8:  RCALL  0448
....................             break; 
07EA:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
07EC:  MOVLW  02
07EE:  MOVWF  20
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
07F0:  MOVFF  41A,2A
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
07F4:  MOVLB  2
07F6:  CLRF   xAE
07F8:  MOVLB  0
07FA:  RCALL  0442
....................             break; 
07FC:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
07FE:  BRA    04E8
....................             break; 
0800:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
0802:  MOVFF  21,420
....................             usb_request_send_response(1); 
0806:  MOVLW  01
0808:  MOVLB  2
080A:  MOVWF  xAE
080C:  MOVLB  0
080E:  RCALL  0442
....................             break; 
0810:  BRA    0836
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0812:  MOVLB  4
0814:  MOVF   x1A,W
0816:  SUBLW  01
0818:  BNC   082E
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
081A:  MOVFF  41A,21
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
081E:  MOVFF  41A,2AB
0822:  MOVLB  0
0824:  BRA    05B0
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
0826:  MOVLB  2
0828:  CLRF   xAE
082A:  MOVLB  0
082C:  RCALL  0442
....................             } 
....................             break; 
082E:  MOVLB  0
0830:  BRA    0836
....................  
....................       default: 
....................             usb_request_stall(); 
0832:  RCALL  0448
....................             break; 
0834:  BRA    0836
....................    } 
.................... } 
0836:  GOTO   0B20 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
083A:  MOVFF  21,2AB
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
083E:  MOVLB  4
0840:  MOVF   x19,W
0842:  XORLW  00
0844:  MOVLB  0
0846:  BZ    0852
0848:  XORLW  0A
084A:  BZ    0864
084C:  XORLW  01
084E:  BZ    08B2
0850:  BRA    08DC
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
0852:  MOVLB  4
0854:  CLRF   x20
....................             usb_ep0_tx_buffer[1]=0; 
0856:  CLRF   x21
....................             usb_request_send_response(2); 
0858:  MOVLW  02
085A:  MOVLB  2
085C:  MOVWF  xAE
085E:  MOVLB  0
0860:  RCALL  0442
....................             break; 
0862:  BRA    08E0
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0864:  MOVLB  2
0866:  MOVF   xAB,F
0868:  BZ    08AC
086A:  MOVLW  01
086C:  SUBWF  xAB,W
086E:  CLRF   03
0870:  MOVFF  FF2,2AC
0874:  BCF    FF2.7
0876:  MOVLB  0
0878:  RCALL  01C0
087A:  MOVLB  2
087C:  BTFSC  xAC.7
087E:  BSF    FF2.7
0880:  MOVWF  01
0882:  MOVLB  4
0884:  SUBWF  x1C,W
0886:  BTFSS  FD8.0
0888:  BRA    088E
088A:  MOVLB  2
088C:  BRA    08AC
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
088E:  CLRF   03
0890:  MOVF   x1C,W
0892:  ADDLW  2D
0894:  MOVWF  FE9
0896:  MOVLW  00
0898:  ADDWFC 03,W
089A:  MOVWF  FEA
089C:  MOVFF  FEF,420
....................                usb_request_send_response(1);; //send byte back 
08A0:  MOVLW  01
08A2:  MOVLB  2
08A4:  MOVWF  xAE
08A6:  MOVLB  0
08A8:  RCALL  0442
....................             } 
....................             else 
08AA:  BRA    08B0
....................                usb_request_stall(); 
08AC:  MOVLB  0
08AE:  RCALL  0448
....................             break; 
08B0:  BRA    08E0
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
08B2:  MOVLB  2
08B4:  MOVF   xAB,F
08B6:  BZ    08D6
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
08B8:  CLRF   03
08BA:  MOVLB  4
08BC:  MOVF   x1C,W
08BE:  ADDLW  2D
08C0:  MOVWF  FE9
08C2:  MOVLW  00
08C4:  ADDWFC 03,W
08C6:  MOVWF  FEA
08C8:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
08CC:  MOVLB  2
08CE:  CLRF   xAE
08D0:  MOVLB  0
08D2:  RCALL  0442
....................             } 
....................             else 
08D4:  BRA    08DA
....................                usb_request_stall(); 
08D6:  MOVLB  0
08D8:  RCALL  0448
....................             break; 
08DA:  BRA    08E0
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
08DC:  RCALL  0448
....................             break; 
08DE:  BRA    08E0
....................    } 
.................... } 
08E0:  GOTO   0B20 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
09D0:  MOVFF  41C,2B5
09D4:  RCALL  02E4
09D6:  MOVF   01,F
09D8:  BZ    0A36
....................       switch(usb_ep0_rx_buffer[1]) { 
09DA:  MOVLB  4
09DC:  MOVF   x19,W
09DE:  XORLW  01
09E0:  MOVLB  0
09E2:  BZ    09EE
09E4:  XORLW  02
09E6:  BZ    09FE
09E8:  XORLW  03
09EA:  BZ    0A0E
09EC:  BRA    0A32
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
09EE:  MOVFF  41C,2AB
09F2:  BRA    08E4
....................                usb_put_0len_0(); 
09F4:  MOVLB  2
09F6:  CLRF   xAE
09F8:  MOVLB  0
09FA:  RCALL  0442
....................                break; 
09FC:  BRA    0A36
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
09FE:  MOVFF  41C,2AB
0A02:  BRA    092C
....................                      usb_put_0len_0(); 
0A04:  MOVLB  2
0A06:  CLRF   xAE
0A08:  MOVLB  0
0A0A:  RCALL  0442
....................                      break; 
0A0C:  BRA    0A36
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0A0E:  MOVLB  4
0A10:  CLRF   x20
....................                usb_ep0_tx_buffer[1]=0; 
0A12:  CLRF   x21
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0A14:  MOVFF  41C,2AB
0A18:  MOVLB  0
0A1A:  BRA    0976
0A1C:  MOVF   01,F
0A1E:  BZ    0A26
....................                   usb_ep0_tx_buffer[0]=1; 
0A20:  MOVLW  01
0A22:  MOVLB  4
0A24:  MOVWF  x20
....................                } 
....................                usb_request_send_response(2); 
0A26:  MOVLW  02
0A28:  MOVLB  2
0A2A:  MOVWF  xAE
0A2C:  MOVLB  0
0A2E:  RCALL  0442
....................                break; 
0A30:  BRA    0A36
....................  
....................          default: 
....................             usb_request_stall(); 
0A32:  RCALL  0448
....................             break; 
0A34:  BRA    0A36
....................       } 
....................    } 
.................... } 
0A36:  GOTO   0B20 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
04E8:  CLRF   2B
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
04EA:  CLRF   23
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
04EC:  MOVLB  4
04EE:  MOVF   x1B,W
04F0:  XORLW  01
04F2:  MOVLB  0
04F4:  BZ    0504
04F6:  XORLW  03
04F8:  BZ    050E
04FA:  XORLW  01
04FC:  BZ    0514
04FE:  XORLW  22
0500:  BZ    0546
0502:  BRA    0590
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
0504:  MOVLW  12
0506:  MOVWF  2C
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
0508:  MOVLW  03
050A:  MOVWF  23
....................             break; 
050C:  BRA    0594
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
050E:  MOVLW  43
0510:  MOVWF  2C
....................             break; 
0512:  BRA    0594
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0514:  MOVLW  02
0516:  MOVWF  23
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
0518:  CLRF   03
051A:  MOVLB  4
051C:  MOVF   x1A,W
051E:  ADDLW  24
0520:  MOVWF  FE9
0522:  MOVLW  00
0524:  ADDWFC 03,W
0526:  MOVWF  FEA
0528:  MOVFF  FEF,2B
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
052C:  CLRF   03
052E:  MOVF   2B,W
0530:  MOVFF  FF2,2AB
0534:  BCF    FF2.7
0536:  MOVLB  0
0538:  RCALL  0214
053A:  MOVLB  2
053C:  BTFSC  xAB.7
053E:  BSF    FF2.7
0540:  MOVWF  2C
....................             break; 
0542:  MOVLB  0
0544:  BRA    0594
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
0546:  BCF    FD8.0
0548:  MOVLB  4
054A:  RLCF   x1A,W
054C:  CLRF   03
054E:  MOVFF  FF2,2AB
0552:  BCF    FF2.7
0554:  MOVLB  0
0556:  RCALL  01D2
0558:  TBLRD*+
055A:  MOVFF  FF5,03
055E:  MOVLB  2
0560:  BTFSC  xAB.7
0562:  BSF    FF2.7
0564:  MOVWF  2B
....................             if (usb_getdesc_ptr!=0xFF) { 
0566:  INCFSZ 2B,W
0568:  BRA    056C
056A:  BRA    058A
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
056C:  CLRF   03
056E:  MOVF   2B,W
0570:  MOVFF  FF2,2AB
0574:  BCF    FF2.7
0576:  MOVLB  0
0578:  RCALL  016C
057A:  MOVLB  2
057C:  BTFSC  xAB.7
057E:  BSF    FF2.7
0580:  MOVWF  2C
....................                break; 
0582:  MOVLB  0
0584:  BRA    0594
....................             } 
....................             else { 
0586:  BRA    0590
0588:  MOVLB  2
....................                usb_request_stall(); 
058A:  MOVLB  0
058C:  RCALL  0448
....................                return; 
058E:  BRA    05AC
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
0590:  RCALL  0448
....................             return; 
0592:  BRA    05AC
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0594:  MOVLB  4
0596:  MOVF   x1F,F
0598:  BNZ   05A4
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
059A:  MOVF   2C,W
059C:  SUBWF  x1E,W
059E:  BC    05A4
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
05A0:  MOVFF  41E,2C
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
05A4:  MOVLW  01
05A6:  MOVWF  20
....................    usb_copy_desc_seg_to_ep(); 
05A8:  MOVLB  0
05AA:  RCALL  044E
.................... } 
05AC:  GOTO   0836 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0DFE:  CLRF   21
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0E00:  CLRF   20
....................    usb_set_address(USB_address_pending); 
0E02:  MOVFF  2A,2AC
0E06:  BRA    0DE4
....................    #endif 
.................... } 
0E08:  GOTO   0EE8 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
044E:  MOVLB  2
0450:  CLRF   xAC
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0452:  MOVF   2C,F
0454:  BZ    04D2
0456:  MOVF   xAC,W
0458:  SUBLW  07
045A:  BNC   04D2
....................       switch(USB_stack_status.getdesc_type) { 
045C:  MOVF   23,W
045E:  XORLW  00
0460:  MOVLB  0
0462:  BZ    046E
0464:  XORLW  02
0466:  BZ    0486
0468:  XORLW  01
046A:  BZ    049E
046C:  BRA    04B6
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
046E:  CLRF   03
0470:  MOVF   2B,W
0472:  MOVFF  FF2,2AE
0476:  BCF    FF2.7
0478:  RCALL  016C
047A:  MOVLB  2
047C:  BTFSC  xAE.7
047E:  BSF    FF2.7
0480:  MOVWF  xAD
....................             break; 
0482:  MOVLB  0
0484:  BRA    04B6
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
0486:  CLRF   03
0488:  MOVF   2B,W
048A:  MOVFF  FF2,2AE
048E:  BCF    FF2.7
0490:  RCALL  0214
0492:  MOVLB  2
0494:  BTFSC  xAE.7
0496:  BSF    FF2.7
0498:  MOVWF  xAD
....................             break; 
049A:  MOVLB  0
049C:  BRA    04B6
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
049E:  CLRF   03
04A0:  MOVF   2B,W
04A2:  MOVFF  FF2,2AE
04A6:  BCF    FF2.7
04A8:  RCALL  01F2
04AA:  MOVLB  2
04AC:  BTFSC  xAE.7
04AE:  BSF    FF2.7
04B0:  MOVWF  xAD
....................             break; 
04B2:  MOVLB  0
04B4:  BRA    04B6
....................       } 
....................       usb_getdesc_ptr++; 
04B6:  INCF   2B,F
....................       usb_getdesc_len--; 
04B8:  DECF   2C,F
....................       usb_ep0_tx_buffer[i++]=c; 
04BA:  MOVLB  2
04BC:  MOVF   xAC,W
04BE:  INCF   xAC,F
04C0:  CLRF   03
04C2:  ADDLW  20
04C4:  MOVWF  FE9
04C6:  MOVLW  04
04C8:  ADDWFC 03,W
04CA:  MOVWF  FEA
04CC:  MOVFF  2AD,FEF
....................    } 
04D0:  BRA    0452
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
04D2:  MOVF   2C,F
04D4:  BNZ   04DE
04D6:  MOVF   xAC,W
04D8:  SUBLW  08
04DA:  BZ    04DE
....................          USB_stack_status.dev_req = NONE; 
04DC:  CLRF   20
....................    } 
....................  
....................    usb_request_send_response(i); 
04DE:  MOVFF  2AC,2AE
04E2:  MOVLB  0
04E4:  RCALL  0442
.................... } 
04E6:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  unsigned int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... unsigned int8 g_LastCDCDataPacketSize; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
0D0E:  MOVF   x86,W
0D10:  XORLW  01
0D12:  BZ    0D1E
0D14:  XORLW  02
0D16:  BZ    0D40
0D18:  XORLW  01
0D1A:  BZ    0D4E
0D1C:  BRA    0D76
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
0D1E:  CLRF   FEA
0D20:  MOVLW  38
0D22:  MOVWF  FE9
0D24:  MOVLW  04
0D26:  MOVWF  FE2
0D28:  MOVLW  18
0D2A:  MOVWF  FE1
0D2C:  MOVLW  08
0D2E:  MOVWF  01
0D30:  MOVFF  FE6,FEE
0D34:  DECFSZ 01,F
0D36:  BRA    0D30
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
0D38:  MOVLW  03
0D3A:  MOVWF  x86
....................          usb_request_get_data(); 
0D3C:  RCALL  0A3A
....................         #else 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................         #endif 
....................          break; 
0D3E:  BRA    0D7A
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
0D40:  MOVLB  2
0D42:  CLRF   xAE
0D44:  MOVLB  0
0D46:  CALL   0442
....................          __usb_cdc_state=0; 
0D4A:  CLRF   x86
....................          break; 
0D4C:  BRA    0D7A
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0D4E:  CLRF   FEA
0D50:  MOVLW  2F
0D52:  MOVWF  FE9
0D54:  MOVLW  04
0D56:  MOVWF  FE2
0D58:  MOVLW  18
0D5A:  MOVWF  FE1
0D5C:  MOVLW  07
0D5E:  MOVWF  01
0D60:  MOVFF  FE6,FEE
0D64:  DECFSZ 01,F
0D66:  BRA    0D60
....................          __usb_cdc_state=0; 
0D68:  CLRF   x86
....................          usb_put_0len_0(); 
0D6A:  MOVLB  2
0D6C:  CLRF   xAE
0D6E:  MOVLB  0
0D70:  CALL   0442
....................          break; 
0D74:  BRA    0D7A
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0D76:  CLRF   x86
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
0D78:  BRA    0D7A
....................    } 
.................... } 
0D7A:  GOTO   0DD0 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
0A40:  MOVLB  4
0A42:  DECFSZ x1C,W
0A44:  BRA    0A48
0A46:  BRA    0A4C
0A48:  MOVF   x1C,F
0A4A:  BNZ   0AEA
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
0A4C:  MOVF   x19,W
0A4E:  XORLW  00
0A50:  MOVLB  0
0A52:  BZ    0A6A
0A54:  XORLW  01
0A56:  BZ    0A72
0A58:  XORLW  21
0A5A:  BZ    0A94
0A5C:  XORLW  01
0A5E:  BZ    0A9E
0A60:  XORLW  03
0A62:  BZ    0AC4
0A64:  XORLW  01
0A66:  BZ    0AD2
0A68:  BRA    0AE4
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
0A6A:  MOVLW  01
0A6C:  MOVWF  x86
....................             usb_request_get_data(); 
0A6E:  RCALL  0A3A
....................             break; 
0A70:  BRA    0AE8
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
0A72:  MOVLW  04
0A74:  MOVWF  FEA
0A76:  MOVLW  20
0A78:  MOVWF  FE9
0A7A:  CLRF   FE2
0A7C:  MOVLW  38
0A7E:  MOVWF  FE1
0A80:  MOVLW  08
0A82:  MOVWF  01
0A84:  MOVFF  FE6,FEE
0A88:  DECFSZ 01,F
0A8A:  BRA    0A84
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
0A8C:  MOVFF  41E,2AE
0A90:  RCALL  0442
....................             break; 
0A92:  BRA    0AE8
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
0A94:  MOVLW  02
0A96:  MOVWF  x86
....................             usb_cdc_got_set_line_coding=TRUE; 
0A98:  BSF    x83.0
....................             usb_request_get_data(); 
0A9A:  RCALL  0A3A
....................             break; 
0A9C:  BRA    0AE8
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0A9E:  MOVLW  04
0AA0:  MOVWF  FEA
0AA2:  MOVLW  20
0AA4:  MOVWF  FE9
0AA6:  CLRF   FE2
0AA8:  MOVLW  2F
0AAA:  MOVWF  FE1
0AAC:  MOVLW  07
0AAE:  MOVWF  01
0AB0:  MOVFF  FE6,FEE
0AB4:  DECFSZ 01,F
0AB6:  BRA    0AB0
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0AB8:  MOVLW  07
0ABA:  MOVLB  2
0ABC:  MOVWF  xAE
0ABE:  MOVLB  0
0AC0:  RCALL  0442
....................             break; 
0AC2:  BRA    0AE8
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0AC4:  MOVFF  41A,84
....................             usb_put_0len_0(); 
0AC8:  MOVLB  2
0ACA:  CLRF   xAE
0ACC:  MOVLB  0
0ACE:  RCALL  0442
....................             break; 
0AD0:  BRA    0AE8
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0AD2:  MOVFF  41A,37
0AD6:  MOVFF  41B,36
....................             usb_put_0len_0(); 
0ADA:  MOVLB  2
0ADC:  CLRF   xAE
0ADE:  MOVLB  0
0AE0:  RCALL  0442
....................             break; 
0AE2:  BRA    0AE8
....................  
....................          default: 
....................             usb_request_stall(); 
0AE4:  RCALL  0448
....................             break; 
0AE6:  BRA    0AE8
0AE8:  MOVLB  4
....................       } 
....................    } 
.................... } 
0AEA:  MOVLB  0
0AEC:  GOTO   0B20 (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
0DB0:  BSF    x80.0
....................    usb_cdc_get_buffer_status.index=0; 
0DB2:  CLRF   x82
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0DB4:  MOVLW  02
0DB6:  MOVLB  2
0DB8:  MOVWF  xAC
0DBA:  MOVLB  0
0DBC:  BRA    0D7E
0DBE:  MOVFF  01,81
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
0DC2:  GOTO   0DDE (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    //putc('!'); 
....................    if (usb_cdc_put_buffer_nextin /* || (g_LastCDCDataPacketSize == USB_CDC_DATA_IN_SIZE)*/ )  
*
0EC0:  MOVF   x7F,F
0EC2:  BZ    0EC6
....................    { 
....................       //printf("FL3 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
0EC4:  RCALL  0E9E
....................    } 
.................... } 
0EC6:  GOTO   0EF6 (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................    usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
*
0E9E:  MOVLW  02
0EA0:  MOVLB  2
0EA2:  MOVWF  xAC
0EA4:  CLRF   xAE
0EA6:  MOVLW  40
0EA8:  MOVWF  xAD
0EAA:  CLRF   xB0
0EAC:  MOVFF  7F,2AF
0EB0:  MOVLW  02
0EB2:  MOVWF  xB1
0EB4:  MOVLB  0
0EB6:  RCALL  0E0C
....................    g_LastCDCDataPacketSize = usb_cdc_put_buffer_nextin; 
0EB8:  MOVFF  7F,85
....................    usb_cdc_put_buffer_nextin=0; 
0EBC:  CLRF   x7F
.................... } 
0EBE:  RETLW  00
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
03BA:  CLRF   32
03BC:  CLRF   31
03BE:  MOVLW  25
03C0:  MOVWF  30
03C2:  MOVLW  80
03C4:  MOVWF  2F
....................    usb_cdc_line_coding.bCharFormat = 0; 
03C6:  CLRF   33
....................    usb_cdc_line_coding.bParityType = 0; 
03C8:  CLRF   34
....................    usb_cdc_line_coding.bDataBits = 8; 
03CA:  MOVLW  08
03CC:  MOVWF  35
....................    (int8)usb_cdc_carrier = 0; 
03CE:  CLRF   x84
....................    usb_cdc_got_set_line_coding = FALSE; 
03D0:  BCF    x83.0
....................    usb_cdc_break = 0; 
03D2:  CLRF   37
03D4:  CLRF   36
....................    usb_cdc_put_buffer_nextin = 0; 
03D6:  CLRF   x7F
....................    usb_cdc_get_buffer_status.got = 0; 
03D8:  BCF    x80.0
.................... } 
03DA:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
27BC:  BCF    x80.0
27BE:  CLRF   16
27C0:  BTFSC  FF2.7
27C2:  BSF    16.7
27C4:  BCF    FF2.7
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
27C6:  MOVLW  02
27C8:  MOVLB  2
27CA:  MOVWF  xAB
27CC:  MOVWF  xAC
27CE:  MOVLB  0
27D0:  CALL   0B24
27D4:  BTFSC  16.7
27D6:  BSF    FF2.7
.................... } 
27D8:  GOTO   2802 (RETURN)
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
27DC:  BTFSC  x80.0
27DE:  BRA    27E2
27E0:  BRA    27DC
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
27E2:  MOVF   x82,W
27E4:  INCF   x82,F
27E6:  CLRF   03
27E8:  ADDLW  30
27EA:  MOVWF  FE9
27EC:  MOVLW  04
27EE:  ADDWFC 03,W
27F0:  MOVWF  FEA
27F2:  MOVFF  FEF,1D2
27F6:  MOVLB  1
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
27F8:  MOVLB  0
27FA:  MOVF   x81,W
27FC:  SUBWF  x82,W
27FE:  BNC   2802
....................    { 
....................       usb_cdc_get_discard(); 
2800:  BRA    27BC
....................    } 
....................  
....................    return(c); 
2802:  MOVLB  1
2804:  MOVFF  1D2,01
.................... } 
2808:  MOVLB  0
280A:  RETLW  00
....................  
.................... void usb_cdc_putc_fast(char c)  
.................... { 
....................  #if defined(__PCH__) 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie = INT_GIE; 
*
14FC:  MOVLB  2
14FE:  BCF    x97.0
1500:  BTFSC  FF2.7
1502:  BSF    x97.0
....................    INT_GIE = 0; 
1504:  BCF    FF2.7
....................  #else 
....................    int16 oldSR; 
....................     
....................    oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
1506:  MOVLB  0
1508:  MOVF   x7F,W
150A:  SUBLW  3E
150C:  BC    1512
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
150E:  MOVLW  3E
1510:  MOVWF  x7F
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
1512:  MOVF   x7F,W
1514:  INCF   x7F,F
1516:  CLRF   03
1518:  ADDLW  40
151A:  MOVWF  FE9
151C:  MOVLW  00
151E:  ADDWFC 03,W
1520:  MOVWF  FEA
1522:  MOVFF  296,FEF
....................  
....................    //renable global interrupts 
....................   #if defined(__PCH__) 
....................    INT_GIE = old_gie; 
1526:  BCF    FF2.7
1528:  MOVLB  2
152A:  BTFSC  x97.0
152C:  BSF    FF2.7
152E:  CLRF   16
1530:  BTFSC  FF2.7
1532:  BSF    16.7
1534:  BCF    FF2.7
....................   #else 
....................    SR = oldSR; 
....................   #endif 
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free()) { 
1536:  MOVLW  02
1538:  MOVWF  xB9
153A:  MOVLB  0
153C:  CALL   0BEE
1540:  BTFSC  16.7
1542:  BSF    FF2.7
1544:  MOVF   01,F
1546:  BZ    1556
1548:  CLRF   16
154A:  BTFSC  FF2.7
154C:  BSF    16.7
154E:  BCF    FF2.7
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
1550:  RCALL  0E9E
1552:  BTFSC  16.7
1554:  BSF    FF2.7
....................    } 
....................    //putc('*'); 
.................... } 
1556:  RETLW  00
....................  
.................... void usb_cdc_putc(char c)  
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
*
280C:  MOVF   x7F,W
280E:  SUBLW  3E
2810:  BC    2840
2812:  CLRF   16
2814:  BTFSC  FF2.7
2816:  BSF    16.7
2818:  BCF    FF2.7
....................       if (usb_cdc_put_buffer_free())  
281A:  MOVLW  02
281C:  MOVLB  2
281E:  MOVWF  xB9
2820:  MOVLB  0
2822:  CALL   0BEE
2826:  BTFSC  16.7
2828:  BSF    FF2.7
282A:  MOVF   01,F
282C:  BZ    283E
282E:  CLRF   16
2830:  BTFSC  FF2.7
2832:  BSF    16.7
2834:  BCF    FF2.7
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
2836:  CALL   0E9E
283A:  BTFSC  16.7
283C:  BSF    FF2.7
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
283E:  BRA    280C
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
2840:  MOVFF  1D2,296
2844:  CALL   14FC
.................... } 
2848:  RETLW  00
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD		0x55 
.................... #define MEMORIA_CMD_VER_INFO		0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD				0x40 
.................... #define MEMORIA_CMD_READ_FILE		0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK			0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON		0x01 
.................... #define MEMORIA_OFF		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT		12 
.................... #define MEMORIA_NAME_TERMINATOR		0x00 
.................... #define MEMORIA_DELIMITADOR			0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE		0x00 
.................... #define MEMORIA_LOW_PERFORMANCE		0x40 
....................  
.................... #define FILE_WR 1 
.................... #define FILE_RD 0 
....................  
.................... //extern char MEM_info[5]; 
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... void MEMORIA_getinfo(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char* filename, short modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char* data, unsigned int size); 
.................... void MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char* buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
1140:  MOVLW  08
1142:  MOVWF  01
1144:  MOVLW  04
1146:  MOVWF  00
1148:  DECFSZ 00,F
114A:  BRA    1148
114C:  BCF    F8A.1
114E:  BCF    F93.1
1150:  MOVLW  04
1152:  MOVWF  00
1154:  DECFSZ 00,F
1156:  BRA    1154
1158:  MOVLB  1
115A:  RLCF   xF0,F
115C:  BCF    F8A.0
115E:  BTFSC  FD8.0
1160:  BSF    F93.0
1162:  BTFSS  FD8.0
1164:  BCF    F93.0
1166:  BSF    F93.1
1168:  BTFSS  F81.1
116A:  BRA    1168
116C:  DECFSZ 01,F
116E:  BRA    1172
1170:  BRA    1176
1172:  MOVLB  0
1174:  BRA    1144
1176:  MOVLW  04
1178:  MOVWF  00
117A:  DECFSZ 00,F
117C:  BRA    117A
117E:  BCF    F8A.1
1180:  BCF    F93.1
1182:  NOP   
1184:  BSF    F93.0
1186:  MOVLW  04
1188:  MOVWF  00
118A:  DECFSZ 00,F
118C:  BRA    118A
118E:  MOVLW  04
1190:  MOVWF  00
1192:  DECFSZ 00,F
1194:  BRA    1192
1196:  BSF    F93.1
1198:  BTFSS  F81.1
119A:  BRA    1198
119C:  CLRF   01
119E:  MOVLW  04
11A0:  MOVWF  00
11A2:  DECFSZ 00,F
11A4:  BRA    11A2
11A6:  BTFSC  F81.0
11A8:  BSF    01.0
11AA:  BCF    F8A.1
11AC:  BCF    F93.1
11AE:  BCF    F8A.0
11B0:  BCF    F93.0
11B2:  MOVLB  0
11B4:  RETLW  00
11B6:  MOVLW  08
11B8:  MOVLB  1
11BA:  MOVWF  xF1
11BC:  MOVFF  00,1F2
11C0:  BSF    F93.0
11C2:  MOVLW  04
11C4:  MOVWF  00
11C6:  DECFSZ 00,F
11C8:  BRA    11C6
11CA:  BSF    F93.1
11CC:  BTFSS  F81.1
11CE:  BRA    11CC
11D0:  BTFSC  F81.0
11D2:  BSF    FD8.0
11D4:  BTFSS  F81.0
11D6:  BCF    FD8.0
11D8:  RLCF   01,F
11DA:  MOVLW  04
11DC:  MOVWF  00
11DE:  DECFSZ 00,F
11E0:  BRA    11DE
11E2:  BCF    F93.1
11E4:  BCF    F8A.1
11E6:  DECFSZ xF1,F
11E8:  BRA    11C0
11EA:  BSF    F93.0
11EC:  MOVLW  04
11EE:  MOVWF  00
11F0:  DECFSZ 00,F
11F2:  BRA    11F0
11F4:  BCF    F8A.0
11F6:  MOVF   xF2,W
11F8:  BTFSS  FD8.2
11FA:  BCF    F93.0
11FC:  NOP   
11FE:  BSF    F93.1
1200:  BTFSS  F81.1
1202:  BRA    1200
1204:  MOVLW  04
1206:  MOVWF  00
1208:  DECFSZ 00,F
120A:  BRA    1208
120C:  BCF    F8A.1
120E:  BCF    F93.1
1210:  MOVLW  04
1212:  MOVWF  00
1214:  DECFSZ 00,F
1216:  BRA    1214
1218:  BCF    F8A.0
121A:  BCF    F93.0
121C:  MOVLB  0
121E:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
.................... /* 
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_sec = 0x00; 
.................... */ 
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(unsigned int canal, int16 *buffer); 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA_H 
.................... #define CAPTURA_FRECUENCIA_H 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... /* 
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
.................... */ 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... /*struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
.................... */ 
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
.................... //canales de lectura 
.................... #define CCP_CANAL_1 1 
.................... #define CCP_CANAL_2 2 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_8|T3_CCP1_TO_2; 
....................  
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
.................... 	Q=-1:   ccp inabilitado 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
.................... int semaforo_ccp = 0; 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... void CP_activar_captura(int canal); 
.................... void CP_desativar_captura(); 
.................... int CP_ocupado(); 
.................... int CP_done(); 
.................... int32 CP_obtener_resultado(); 
....................  
.................... #endif 
....................  
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "configuracion.h" 
.................... #ifndef CONFIGURACION_H 
.................... #define CONFIGURACION_H 
....................  
.................... // opciones de configuracion 
.................... #define CONF_SALIR    '9' 
.................... #define CONF_SET_FECHA  '1' 
.................... #define CONF_GET_FECHA  '2' 
.................... #define CONF_SET_CANAL  '3' 
.................... #define CONF_GET_CANAL  '4' 
.................... #define CONF_SET_DATO   '5' 
.................... #define CONF_GET_DATO   '6' 
....................  
.................... #define CONF_ACK        0x06 
.................... #define CONF_NOACK    0x15 
....................  
.................... //direccion del byte de canales activos y bit de canales 
.................... #define CONF_DIR_CANAl        0x08 
.................... #define CONF_CCP_VEL_BIT    0 
.................... #define CONF_CCP_REV_BIT    1 
.................... #define CONF_CCP_BIT            2 
.................... #define CONF_AD_VEL_BIT        3 
.................... #define CONF_AD_REV_BIT        4 
....................  
.................... // numeracion de sensores 
.................... #define ACC_x        0 
.................... #define ACC_y        1 
.................... #define ACC_z        2 
.................... #define AD_VEL     3 
.................... #define AD_REV        4 
.................... #define CCP_VEl     5 
.................... #define CCP_REV     6 
....................  
....................  
.................... // para el switch de log 
.................... #define LOG_ENABLE    1 
.................... #define LOG_DISABLE    0 
.................... #define LOG_LINE ("\n\r%X:%X:%X:%X:%X:%X:%X:%X:%LX:%LX") 
....................  
.................... // definicion de pines de indicadores 
.................... #define INDICADOR_POWER    PIN_E0 
.................... #define INDICADOR_USB        PIN_E1 
.................... #define INDICADOR_RUN        PIN_E2 
....................  
.................... // esto es para debug 
.................... #ifdef SIMULACION 
....................     #define cout     
....................     #define cin        getc               
.................... #else 
....................     #define cout    usb_cdc_putc_fast, 
....................     #define cin        usb_cdc_getc 
....................     #define putc    usb_cdc_putc 
.................... #endif 
....................  
.................... // definciones utilizadas en el nucleo 
.................... int1 salida = 0; 
.................... byte CONF_CANAL_ACTIVO = 0; 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................     int canal_ccp = CCP_CANAL_1; 
.................... #endif    //CAPTURA_FRECUENCIA_H 
....................  
.................... int myerror = 0; 
.................... int16 lectura = 0; 
.................... char noLog[] = "\n\rno se puede guardar"; 
.................... char testfile[] = "prueba"; 
.................... char buffer_log[39]; 
.................... //int32 resultado = 0; 
.................... struct Log { 
....................     byte dia; 
....................     byte mes; 
....................     byte anio; 
....................     byte hor; 
....................     byte min; 
....................     byte seg; 
....................     int8 sensor; 
....................     int8 no_data; 
....................     int32 value; 
....................     int16 crc; 
.................... } data; 
....................  
.................... void iniciar_perifericos(); 
.................... int sensor_activo(int sensor); 
.................... void modo_configuracion(); 
.................... #endif 
....................  
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8) 
....................  
.................... #ifdef use_rtos 
.................... void activar_tareas(); 
.................... void desactivar_tareas(); 
....................  
....................  
.................... //ifdef MEMORIA_H 
.................... void guardar(){ 
*
1C4C:  MOVLB  2
1C4E:  CLRF   x8A
1C50:  CLRF   x8B
....................    unsigned int nBytes = 0, escritos = 0; 
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
1C52:  BSF    F95.2
1C54:  BTFSS  F83.2
1C56:  BRA    1E94
....................       sprintf(buffer_log,LOG_LINE, 
....................             data.dia, data.mes, data.anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
1C58:  MOVLB  0
1C5A:  CLRF   xEE
1C5C:  MOVLW  B8
1C5E:  MOVWF  xED
1C60:  MOVLW  0A
1C62:  MOVLB  2
1C64:  MOVWF  x8E
1C66:  MOVLB  0
1C68:  CALL   145C
1C6C:  MOVLW  0D
1C6E:  MOVLB  2
1C70:  MOVWF  x8E
1C72:  MOVLB  0
1C74:  CALL   145C
1C78:  MOVFF  DF,28C
1C7C:  MOVLW  37
1C7E:  MOVLB  2
1C80:  MOVWF  x8D
1C82:  MOVLB  0
1C84:  CALL   147C
1C88:  MOVLW  3A
1C8A:  MOVLB  2
1C8C:  MOVWF  x8E
1C8E:  MOVLB  0
1C90:  CALL   145C
1C94:  MOVFF  E0,28C
1C98:  MOVLW  37
1C9A:  MOVLB  2
1C9C:  MOVWF  x8D
1C9E:  MOVLB  0
1CA0:  CALL   147C
1CA4:  MOVLW  3A
1CA6:  MOVLB  2
1CA8:  MOVWF  x8E
1CAA:  MOVLB  0
1CAC:  CALL   145C
1CB0:  MOVFF  E1,28C
1CB4:  MOVLW  37
1CB6:  MOVLB  2
1CB8:  MOVWF  x8D
1CBA:  MOVLB  0
1CBC:  CALL   147C
1CC0:  MOVLW  3A
1CC2:  MOVLB  2
1CC4:  MOVWF  x8E
1CC6:  MOVLB  0
1CC8:  CALL   145C
1CCC:  MOVFF  E2,28C
1CD0:  MOVLW  37
1CD2:  MOVLB  2
1CD4:  MOVWF  x8D
1CD6:  MOVLB  0
1CD8:  CALL   147C
1CDC:  MOVLW  3A
1CDE:  MOVLB  2
1CE0:  MOVWF  x8E
1CE2:  MOVLB  0
1CE4:  CALL   145C
1CE8:  MOVFF  E3,28C
1CEC:  MOVLW  37
1CEE:  MOVLB  2
1CF0:  MOVWF  x8D
1CF2:  MOVLB  0
1CF4:  CALL   147C
1CF8:  MOVLW  3A
1CFA:  MOVLB  2
1CFC:  MOVWF  x8E
1CFE:  MOVLB  0
1D00:  CALL   145C
1D04:  MOVFF  E4,28C
1D08:  MOVLW  37
1D0A:  MOVLB  2
1D0C:  MOVWF  x8D
1D0E:  MOVLB  0
1D10:  CALL   147C
1D14:  MOVLW  3A
1D16:  MOVLB  2
1D18:  MOVWF  x8E
1D1A:  MOVLB  0
1D1C:  CALL   145C
1D20:  MOVFF  E5,28C
1D24:  MOVLW  37
1D26:  MOVLB  2
1D28:  MOVWF  x8D
1D2A:  MOVLB  0
1D2C:  CALL   147C
1D30:  MOVLW  3A
1D32:  MOVLB  2
1D34:  MOVWF  x8E
1D36:  MOVLB  0
1D38:  CALL   145C
1D3C:  MOVFF  E6,28C
1D40:  MOVLW  37
1D42:  MOVLB  2
1D44:  MOVWF  x8D
1D46:  MOVLB  0
1D48:  CALL   147C
1D4C:  MOVLW  3A
1D4E:  MOVLB  2
1D50:  MOVWF  x8E
1D52:  MOVLB  0
1D54:  CALL   145C
1D58:  MOVFF  EA,28C
1D5C:  MOVLW  37
1D5E:  MOVLB  2
1D60:  MOVWF  x8D
1D62:  MOVLB  0
1D64:  CALL   147C
1D68:  MOVFF  E9,28C
1D6C:  MOVLW  37
1D6E:  MOVLB  2
1D70:  MOVWF  x8D
1D72:  MOVLB  0
1D74:  CALL   147C
1D78:  MOVFF  E8,28C
1D7C:  MOVLW  37
1D7E:  MOVLB  2
1D80:  MOVWF  x8D
1D82:  MOVLB  0
1D84:  CALL   147C
1D88:  MOVFF  E7,28C
1D8C:  MOVLW  37
1D8E:  MOVLB  2
1D90:  MOVWF  x8D
1D92:  MOVLB  0
1D94:  CALL   147C
1D98:  MOVLW  3A
1D9A:  MOVLB  2
1D9C:  MOVWF  x8E
1D9E:  MOVLB  0
1DA0:  CALL   145C
1DA4:  MOVFF  EC,28C
1DA8:  MOVLW  37
1DAA:  MOVLB  2
1DAC:  MOVWF  x8D
1DAE:  MOVLB  0
1DB0:  CALL   147C
1DB4:  MOVFF  EB,28C
1DB8:  MOVLW  37
1DBA:  MOVLB  2
1DBC:  MOVWF  x8D
1DBE:  MOVLB  0
1DC0:  CALL   147C
....................              
....................       #ifdef MEMORIA_H 
....................       nBytes = strlen(buffer_log); 
1DC4:  MOVLB  2
1DC6:  CLRF   x90
1DC8:  MOVLW  B8
1DCA:  MOVWF  x8F
1DCC:  MOVLB  0
1DCE:  CALL   14C2
1DD2:  MOVFF  01,28A
....................       if((myerror = MEMORIA_open(testfile, FILE_WR)) != 0){ 
1DD6:  MOVLB  2
1DD8:  CLRF   x8D
1DDA:  MOVLW  B1
1DDC:  MOVWF  x8C
1DDE:  MOVLW  01
1DE0:  MOVWF  x8E
1DE2:  MOVLB  0
1DE4:  BRA    1730
1DE6:  MOVFF  01,98
1DEA:  MOVF   x98,F
1DEC:  BZ    1E14
....................          printf(usb_cdc_putc_fast,"\n\rMO%d",myerror); 
1DEE:  MOVLW  FE
1DF0:  MOVWF  FF6
1DF2:  MOVLW  10
1DF4:  MOVWF  FF7
1DF6:  MOVLW  04
1DF8:  MOVLB  2
1DFA:  MOVWF  x90
1DFC:  MOVLB  0
1DFE:  CALL   1558
1E02:  MOVFF  98,290
1E06:  MOVLW  1F
1E08:  MOVLB  2
1E0A:  MOVWF  x91
1E0C:  MOVLB  0
1E0E:  CALL   15AC
....................       }else{ 
1E12:  BRA    1E82
....................          if( (myerror = MEMORIA_write(nBytes)) != 0 ){ 
1E14:  MOVFF  28A,28C
1E18:  BRA    1960
1E1A:  MOVFF  01,98
1E1E:  MOVF   x98,F
1E20:  BZ    1E48
....................             printf(usb_cdc_putc_fast,"\n\rMW%d",myerror); 
1E22:  MOVLW  06
1E24:  MOVWF  FF6
1E26:  MOVLW  11
1E28:  MOVWF  FF7
1E2A:  MOVLW  04
1E2C:  MOVLB  2
1E2E:  MOVWF  x90
1E30:  MOVLB  0
1E32:  CALL   1558
1E36:  MOVFF  98,290
1E3A:  MOVLW  1F
1E3C:  MOVLB  2
1E3E:  MOVWF  x91
1E40:  MOVLB  0
1E42:  CALL   15AC
....................          }else{ 
1E46:  BRA    1E82
....................             escritos = MEMORIA_set_data(buffer_log, nBytes); 
1E48:  MOVLB  2
1E4A:  CLRF   x8D
1E4C:  MOVLW  B8
1E4E:  MOVWF  x8C
1E50:  MOVFF  28A,28E
1E54:  MOVLB  0
1E56:  BRA    1A58
1E58:  MOVFF  01,28B
....................             printf(usb_cdc_putc_fast,"\n\rMS%d", escritos); 
1E5C:  MOVLW  0E
1E5E:  MOVWF  FF6
1E60:  MOVLW  11
1E62:  MOVWF  FF7
1E64:  MOVLW  04
1E66:  MOVLB  2
1E68:  MOVWF  x90
1E6A:  MOVLB  0
1E6C:  CALL   1558
1E70:  MOVFF  28B,290
1E74:  MOVLW  1F
1E76:  MOVLB  2
1E78:  MOVWF  x91
1E7A:  MOVLB  0
1E7C:  CALL   15AC
....................             MEMORIA_close(); 
1E80:  BRA    1B1A
....................          } 
....................       } 
....................       #endif   //MEMORIA_H 
....................        
....................       if(_debug_usb()){ 
1E82:  RCALL  1C0A
1E84:  MOVF   01,F
1E86:  BZ    1E90
....................          printf(cout buffer_log); 
1E88:  CLRF   FEA
1E8A:  MOVLW  B8
1E8C:  MOVWF  FE9
1E8E:  RCALL  1C28
....................       } 
....................    }else{ 
1E90:  BRA    1EA4
1E92:  MOVLB  2
....................       if(_debug_usb()){ 
1E94:  MOVLB  0
1E96:  RCALL  1C0A
1E98:  MOVF   01,F
1E9A:  BZ    1EA4
....................          printf(cout nolog); 
1E9C:  CLRF   FEA
1E9E:  MOVLW  9B
1EA0:  MOVWF  FE9
1EA2:  RCALL  1C28
....................       } 
....................    } 
....................    //if(_debug_usb()){printf(usb_cdc_putc_fast,"%s %u",buffer_log, nBytes);} 
.................... } 
1EA4:  RETLW  00
....................  
.................... /* 
.................... #else 
.................... void guardar(){ 
....................    if(_debug_usb()){ 
....................       if(input(PIN_LOG) == LOG_ENABLE){ 
....................          sprintf(buffer_log,LOG_LINE, 
....................             data.dia, data.mes, data.anio, 
....................             data.hor, data.min, data.seg, 
....................             data.sensor, data.no_data, data.value, data.crc 
....................             ); 
....................          printf(cout buffer_log); 
....................       } else { 
....................          printf(cout nolog); 
....................       } 
....................    } 
.................... } 
.................... #endif 
.................... */ 
....................  
.................... #task (rate=500ms, max=5ms) 
.................... void proceso2(){    
....................    salida = (salida)? 0 : 1; 
*
1116:  BTFSS  x83.1
1118:  BRA    111E
111A:  MOVLW  00
111C:  BRA    1120
111E:  MOVLW  01
1120:  BCF    x83.1
1122:  BTFSC  FE8.0
1124:  BSF    x83.1
....................    if(salida) output_bit(INDICADOR_RUN, 1); 
1126:  BTFSS  x83.1
1128:  BRA    1130
112A:  BSF    F8D.2
112C:  BCF    F96.2
....................    else output_bit(INDICADOR_RUN, 0); 
112E:  BRA    1134
1130:  BCF    F8D.2
1132:  BCF    F96.2
....................    //rtos_yield(); 
.................... } 
1134:  MOVLW  16
1136:  MOVWF  xF4
1138:  MOVLW  11
113A:  MOVWF  xF5
113C:  GOTO   3116
.................... /* 
.................... #task (rate=100ms, max=50ms) 
.................... void testMemoria(){ 
....................    data.sensor = 255; 
....................    data.value = rand(); 
....................    data.crc = rand(); 
....................    ++data.no_data; 
....................    guardar(); 
....................    rtos_yield(); 
.................... }  
.................... */ 
....................  
.................... #ifdef DS1307_H 
.................... #task (rate=500ms, max=50ms) 
.................... void reloj(){ 
....................    ds1307_get_date(data.dia, data.mes, data.anio, DS_vic); 
....................    ds1307_get_time(data.hor, data.min, data.seg); 
....................    //rtos_yield(); 
.................... } 
*
13FC:  MOVLW  4A
13FE:  MOVLB  1
1400:  MOVWF  x03
1402:  MOVLW  12
1404:  MOVWF  x04
1406:  GOTO   3116
.................... #endif   //DS1307_H 
....................  
.................... #ifdef ANALOGO_DIGITAL_H 
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea1() 
....................    { 
....................       AD_leer_canal(ACC_x,&lectura); 
*
1EA6:  MOVLB  2
1EA8:  CLRF   x6C
1EAA:  CLRF   x6E
1EAC:  MOVLW  99
1EAE:  MOVWF  x6D
1EB0:  MOVLB  0
1EB2:  CALL   140A
....................       data.sensor = ACC_x; 
1EB6:  CLRF   xE5
....................       data.value = lectura; 
1EB8:  CLRF   xEA
1EBA:  CLRF   xE9
1EBC:  MOVFF  9A,E8
1EC0:  MOVFF  99,E7
....................       ++data.no_data; 
1EC4:  INCF   xE6,F
....................       guardar(); 
1EC6:  RCALL  1C4C
....................       //rtos_yield(); 
....................    } 
1EC8:  MOVLW  A6
1ECA:  MOVLB  1
1ECC:  MOVWF  x12
1ECE:  MOVLW  1E
1ED0:  MOVWF  x13
1ED2:  GOTO   3116
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea2(){ 
....................       AD_leer_canal(ACC_y,&lectura); 
1ED6:  MOVLW  01
1ED8:  MOVLB  2
1EDA:  MOVWF  x6C
1EDC:  CLRF   x6E
1EDE:  MOVLW  99
1EE0:  MOVWF  x6D
1EE2:  MOVLB  0
1EE4:  CALL   140A
....................       data.sensor = ACC_y; 
1EE8:  MOVLW  01
1EEA:  MOVWF  xE5
....................       data.value = lectura; 
1EEC:  CLRF   xEA
1EEE:  CLRF   xE9
1EF0:  MOVFF  9A,E8
1EF4:  MOVFF  99,E7
....................       ++data.no_data; 
1EF8:  INCF   xE6,F
....................       guardar(); 
1EFA:  RCALL  1C4C
....................       //rtos_yield(); 
....................    } 
1EFC:  MOVLW  D6
1EFE:  MOVLB  1
1F00:  MOVWF  x21
1F02:  MOVLW  1E
1F04:  MOVWF  x22
1F06:  GOTO   3116
....................     
....................     
....................    #task (rate=300ms, max=20ms) 
....................    void Tarea3(){ 
....................       AD_leer_canal(ACC_z,&lectura); 
1F0A:  MOVLW  02
1F0C:  MOVLB  2
1F0E:  MOVWF  x6C
1F10:  CLRF   x6E
1F12:  MOVLW  99
1F14:  MOVWF  x6D
1F16:  MOVLB  0
1F18:  CALL   140A
....................       data.sensor = ACC_z; 
1F1C:  MOVLW  02
1F1E:  MOVWF  xE5
....................       data.value = lectura; 
1F20:  CLRF   xEA
1F22:  CLRF   xE9
1F24:  MOVFF  9A,E8
1F28:  MOVFF  99,E7
....................       ++data.no_data; 
1F2C:  INCF   xE6,F
....................       guardar(); 
1F2E:  RCALL  1C4C
....................       //rtos_yield(); 
....................    } 
1F30:  MOVLW  0A
1F32:  MOVLB  1
1F34:  MOVWF  x30
1F36:  MOVLW  1F
1F38:  MOVWF  x31
1F3A:  GOTO   3116
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_VEL(){ 
....................       if(!sensor_activo(AD_VEL)){return;} 
*
1F86:  MOVLW  03
1F88:  MOVLB  2
1F8A:  MOVWF  x8A
1F8C:  MOVLB  0
1F8E:  RCALL  1F3E
1F90:  MOVF   01,F
1F92:  BNZ   1F96
1F94:  BRA    1FBC
....................       AD_leer_canal(AD_VEL,&lectura); 
1F96:  MOVLW  03
1F98:  MOVLB  2
1F9A:  MOVWF  x6C
1F9C:  CLRF   x6E
1F9E:  MOVLW  99
1FA0:  MOVWF  x6D
1FA2:  MOVLB  0
1FA4:  CALL   140A
....................       data.sensor = AD_VEL; 
1FA8:  MOVLW  03
1FAA:  MOVWF  xE5
....................       data.value = lectura; 
1FAC:  CLRF   xEA
1FAE:  CLRF   xE9
1FB0:  MOVFF  9A,E8
1FB4:  MOVFF  99,E7
....................       ++data.no_data; 
1FB8:  INCF   xE6,F
....................       guardar(); 
1FBA:  RCALL  1C4C
....................       //rtos_yield(); 
....................    } 
1FBC:  MOVLW  86
1FBE:  MOVLB  1
1FC0:  MOVWF  x3F
1FC2:  MOVLW  1F
1FC4:  MOVWF  x40
1FC6:  GOTO   3116
....................     
....................    #task (rate=450ms, max=20ms) 
....................    void leer_AD_REV(){ 
....................       if(!sensor_activo(AD_REV)){return;} 
1FCA:  MOVLW  04
1FCC:  MOVLB  2
1FCE:  MOVWF  x8A
1FD0:  MOVLB  0
1FD2:  RCALL  1F3E
1FD4:  MOVF   01,F
1FD6:  BNZ   1FDA
1FD8:  BRA    2000
....................       AD_leer_canal(AD_REV,&lectura); 
1FDA:  MOVLW  04
1FDC:  MOVLB  2
1FDE:  MOVWF  x6C
1FE0:  CLRF   x6E
1FE2:  MOVLW  99
1FE4:  MOVWF  x6D
1FE6:  MOVLB  0
1FE8:  CALL   140A
....................       data.sensor = AD_REV; 
1FEC:  MOVLW  04
1FEE:  MOVWF  xE5
....................       data.value = lectura; 
1FF0:  CLRF   xEA
1FF2:  CLRF   xE9
1FF4:  MOVFF  9A,E8
1FF8:  MOVFF  99,E7
....................       ++data.no_data; 
1FFC:  INCF   xE6,F
....................       guardar(); 
1FFE:  RCALL  1C4C
....................       //rtos_yield(); 
....................    } 
2000:  MOVLW  CA
2002:  MOVLB  1
2004:  MOVWF  x4E
2006:  MOVLW  1F
2008:  MOVWF  x4F
200A:  GOTO   3116
.................... #endif   //ANALOGO_DIGITAL_H 
....................  
.................... #ifdef CAPTURA_FRECUENCIA_H 
....................    #task (rate=850ms, max=50ms) 
....................    void rpm(){ 
....................       // agregar una condicion para comprobar que esta tarea este abilitada para 
....................       // ejecutarse 
....................       if(!(sensor_activo(CCP_VEL)||sensor_activo(CCP_REV))){return;} 
*
20E2:  MOVLW  05
20E4:  MOVLB  2
20E6:  MOVWF  x8A
20E8:  MOVLB  0
20EA:  RCALL  1F3E
20EC:  MOVF   01,F
20EE:  BNZ   2100
20F0:  MOVLW  06
20F2:  MOVLB  2
20F4:  MOVWF  x8A
20F6:  MOVLB  0
20F8:  RCALL  1F3E
20FA:  MOVF   01,F
20FC:  BNZ   2100
20FE:  BRA    2174
....................        
....................       if(!CP_ocupado()){ 
2100:  BRA    200E
2102:  MOVF   01,F
2104:  BNZ   2146
....................          desactivar_tareas(); 
2106:  BRA    201E
....................          if(canal_ccp == CCP_CANAL_1){ 
2108:  DECFSZ x97,W
210A:  BRA    2124
....................             canal_ccp = (sensor_activo(CCP_VEL))? CCP_CANAL_2 : CCP_CANAL_1; 
210C:  MOVLW  05
210E:  MOVLB  2
2110:  MOVWF  x8A
2112:  MOVLB  0
2114:  RCALL  1F3E
2116:  MOVF   01,F
2118:  BZ    211E
211A:  MOVLW  02
211C:  BRA    2120
211E:  MOVLW  01
2120:  MOVWF  x97
....................          }else   if(canal_ccp == CCP_CANAL_2){ 
2122:  BRA    2140
2124:  MOVF   x97,W
2126:  SUBLW  02
2128:  BNZ   2140
....................             canal_ccp = (sensor_activo(CCP_REV))? CCP_CANAL_1 : CCP_CANAL_2; 
212A:  MOVLW  06
212C:  MOVLB  2
212E:  MOVWF  x8A
2130:  MOVLB  0
2132:  RCALL  1F3E
2134:  MOVF   01,F
2136:  BZ    213C
2138:  MOVLW  01
213A:  BRA    213E
213C:  MOVLW  02
213E:  MOVWF  x97
....................          } 
....................           
....................          //canal_ccp = (canal_ccp == CCP_CANAL_1)? CCP_CANAL_2 : CCP_CANAL_1; 
....................          CP_activar_captura(canal_ccp); 
2140:  MOVFF  97,28A
2144:  BRA    2034
....................       } 
....................       //rtos_await(Q_CCP == 2);                        
....................       if(!CP_done()){ 
2146:  BRA    206E
2148:  MOVF   01,F
214A:  BNZ   214E
....................          //rtos_yield(); 
....................          return; 
214C:  BRA    2174
....................       }   
....................       data.value = CP_obtener_resultado(); 
214E:  BRA    2080
2150:  MOVFF  03,EA
2154:  MOVFF  02,E9
2158:  MOVFF  01,E8
215C:  MOVFF  00,E7
....................       CP_desativar_captura(); 
2160:  BRA    209C
....................       data.sensor = (canal_ccp == CCP_CANAL_1)? CCP_REV: CCP_VEL; 
2162:  DECFSZ x97,W
2164:  BRA    216A
2166:  MOVLW  06
2168:  BRA    216C
216A:  MOVLW  05
216C:  MOVWF  xE5
....................       data.no_data++; 
216E:  INCF   xE6,F
....................       guardar(); 
2170:  RCALL  1C4C
....................       activar_tareas(); 
2172:  BRA    20CC
....................       //rtos_yield(); 
....................    } 
2174:  MOVLW  E2
2176:  MOVLB  1
2178:  MOVWF  x5D
217A:  MOVLW  20
217C:  MOVWF  x5E
217E:  GOTO   3116
.................... #endif   //CAPTURA_FRECUENCIA_H 
....................  
.................... void activar_tareas(){ 
....................    rtos_enable(reloj); 
*
20CC:  BCF    xFE.7
....................    rtos_enable(proceso2); 
20CE:  BCF    xEF.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_enable(Tarea1); 
20D0:  MOVLB  1
20D2:  BCF    x0D.7
....................    rtos_enable(Tarea2); 
20D4:  BCF    x1C.7
....................    rtos_enable(Tarea3); 
20D6:  BCF    x2B.7
....................    rtos_enable(leer_AD_REV); 
20D8:  BCF    x49.7
....................    rtos_enable(leer_AD_VEL); 
20DA:  BCF    x3A.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
20DC:  MOVLB  0
20DE:  GOTO   2174 (RETURN)
....................  
.................... void desactivar_tareas(){ 
....................    rtos_disable(reloj); 
*
201E:  BSF    xFE.7
....................    rtos_disable(proceso2); 
2020:  BSF    xEF.7
....................    #ifdef ANALOGO_DIGITAL_H 
....................    rtos_disable(Tarea1); 
2022:  MOVLB  1
2024:  BSF    x0D.7
....................    rtos_disable(Tarea2); 
2026:  BSF    x1C.7
....................    rtos_disable(Tarea3); 
2028:  BSF    x2B.7
....................    rtos_disable(leer_AD_REV); 
202A:  BSF    x49.7
....................    rtos_disable(leer_AD_VEL); 
202C:  BSF    x3A.7
....................    #endif   //ANALOGO_DIGITAL_H 
.................... } 
202E:  MOVLB  0
2030:  GOTO   2108 (RETURN)
....................  
.................... #endif   //use_rtos 
....................  
.................... //#include "test.c"   // comentar esto en la aplicacion final 
....................  
.................... /*======================= configuracon de dispositivos =======================*/ 
.................... void setup_devices(){ 
....................    iniciar_perifericos(); 
*
2764:  BRA    2700
....................     
....................    setup_psp(PSP_DISABLED); 
2766:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
2768:  BCF    FD1.0
....................    setup_spi(SPI_SS_DISABLED); 
276A:  BCF    FC6.5
276C:  BCF    F94.7
276E:  BSF    F93.0
2770:  BCF    F93.1
2772:  MOVLW  01
2774:  MOVWF  FC6
2776:  MOVLW  00
2778:  MOVWF  FC7
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
277A:  MOVLW  88
277C:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
277E:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
2780:  MOVLW  00
2782:  MOVWF  FCA
2784:  MOVLW  00
2786:  MOVWF  FCB
....................    #ifndef CAPTURA_FRECUENCIA_H 
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    setup_ccp1(CCP_OFF); 
....................    #endif 
....................    setup_comparator(NC_NC_NC_NC); 
2788:  MOVLW  07
278A:  MOVWF  FB4
278C:  MOVF   F92,W
278E:  MOVWF  F92
2790:  MOVLW  0D
2792:  MOVWF  00
2794:  DECFSZ 00,F
2796:  BRA    2794
2798:  MOVF   FB4,W
279A:  BCF    FA1.6
....................    setup_vref(FALSE); 
279C:  CLRF   FB5
....................     
....................    /*===================para los indicadores========================*/ 
....................    set_tris_e(0x00); 
279E:  MOVLW  00
27A0:  MOVWF  F96
....................    set_tris_b(0x00); 
27A2:  MOVWF  F93
....................    set_tris_c(CONFIG_PORT_C);      //configuracion para el modulo de memoria y CCP. mirar Nucleo.h 
27A4:  MOVLW  83
27A6:  MOVWF  F94
....................    set_tris_d(CONFIG_PORT_D); 
27A8:  MOVLW  4E
27AA:  MOVWF  F95
....................    output_bit(INDICADOR_USB, 0); 
27AC:  BCF    F8D.1
27AE:  BCF    F96.1
....................    output_bit(INDICADOR_POWER, 1); 
27B0:  BSF    F8D.0
27B2:  BCF    F96.0
....................    output_bit(INDICADOR_RUN, 1); 
27B4:  BSF    F8D.2
27B6:  BCF    F96.2
....................    //output_low(SPI_SCL); 
....................    //output_high(SPI_SS); 
....................    //output_low(SPI_MOSI); 
....................    //output_high(SPI_MISO); 
....................    //delay_ms(3000); 
....................     
....................     
....................    return; 
.................... } 
27B8:  GOTO   2F4E (RETURN)
....................  
.................... /*=========================================================================== 
.................... ||                               MAIN                                        || 
.................... =============================================================================*/ 
.................... void main(void) { 
*
2D30:  CLRF   FF8
2D32:  BCF    FD0.7
2D34:  BSF    07.7
2D36:  CLRF   FEA
2D38:  CLRF   FE9
2D3A:  CLRF   28
2D3C:  CLRF   2C
2D3E:  CLRF   x7F
2D40:  CLRF   x86
2D42:  CLRF   x87
2D44:  MOVLW  FD
2D46:  MOVWF  x88
2D48:  MOVLW  05
2D4A:  MOVWF  x89
2D4C:  MOVWF  x8A
2D4E:  MOVLW  FF
2D50:  MOVWF  x8B
2D52:  CLRF   x8C
2D54:  CLRF   x90
2D56:  CLRF   x8F
2D58:  CLRF   x8E
2D5A:  CLRF   x8D
2D5C:  CLRF   x94
2D5E:  CLRF   x93
2D60:  CLRF   x92
2D62:  CLRF   x91
2D64:  CLRF   x95
2D66:  BCF    x83.1
2D68:  CLRF   x96
2D6A:  MOVLW  01
2D6C:  MOVWF  x97
2D6E:  CLRF   x98
2D70:  CLRF   x9A
2D72:  CLRF   x99
2D74:  MOVLB  1
2D76:  CLRF   x67
2D78:  BSF    FB8.3
2D7A:  MOVLW  A0
2D7C:  MOVWF  FAF
2D7E:  MOVLW  01
2D80:  MOVWF  FB0
2D82:  MOVLW  A6
2D84:  MOVWF  FAC
2D86:  MOVLW  90
2D88:  MOVWF  FAB
2D8A:  MOVLB  0
2D8C:  BCF    x83.2
2D8E:  BCF    x83.3
2D90:  BCF    x83.4
2D92:  BCF    x83.5
2D94:  MOVLB  1
2D96:  CLRF   xB6
2D98:  CLRF   xB7
2D9A:  CLRF   xB8
2D9C:  CLRF   xBC
2D9E:  CLRF   xBB
2DA0:  CLRF   xBA
2DA2:  CLRF   xB9
2DA4:  MOVLW  01
2DA6:  MOVWF  xCE
2DA8:  MOVLW  80
2DAA:  MOVWF  xCF
2DAC:  MOVLW  40
2DAE:  MOVWF  xD0
2DB0:  MOVLW  15
2DB2:  MOVWF  xD1
2DB4:  MOVF   FC1,W
2DB6:  ANDLW  C0
2DB8:  IORLW  0F
2DBA:  MOVWF  FC1
2DBC:  MOVLW  07
2DBE:  MOVWF  FB4
2DC0:  MOVLW  03
2DC2:  MOVWF  18
2DC4:  CLRF   19
2DC6:  CLRF   1A
2DC8:  CLRF   1B
2DCA:  CLRF   24
2DCC:  MOVLW  04
2DCE:  MOVWF  25
2DD0:  MOVLW  0C
2DD2:  MOVWF  26
2DD4:  MOVLW  0A
2DD6:  MOVLB  0
2DD8:  MOVWF  x9B
2DDA:  MOVLW  0D
2DDC:  MOVWF  x9C
2DDE:  MOVLW  6E
2DE0:  MOVWF  x9D
2DE2:  MOVLW  6F
2DE4:  MOVWF  x9E
2DE6:  MOVLW  20
2DE8:  MOVWF  x9F
2DEA:  MOVLW  73
2DEC:  MOVWF  xA0
2DEE:  MOVLW  65
2DF0:  MOVWF  xA1
2DF2:  MOVLW  20
2DF4:  MOVWF  xA2
2DF6:  MOVLW  70
2DF8:  MOVWF  xA3
2DFA:  MOVLW  75
2DFC:  MOVWF  xA4
2DFE:  MOVLW  65
2E00:  MOVWF  xA5
2E02:  MOVLW  64
2E04:  MOVWF  xA6
2E06:  MOVLW  65
2E08:  MOVWF  xA7
2E0A:  MOVLW  20
2E0C:  MOVWF  xA8
2E0E:  MOVLW  67
2E10:  MOVWF  xA9
2E12:  MOVLW  75
2E14:  MOVWF  xAA
2E16:  MOVLW  61
2E18:  MOVWF  xAB
2E1A:  MOVLW  72
2E1C:  MOVWF  xAC
2E1E:  MOVLW  64
2E20:  MOVWF  xAD
2E22:  MOVLW  61
2E24:  MOVWF  xAE
2E26:  MOVLW  72
2E28:  MOVWF  xAF
2E2A:  CLRF   xB0
2E2C:  MOVLW  70
2E2E:  MOVWF  xB1
2E30:  MOVLW  72
2E32:  MOVWF  xB2
2E34:  MOVLW  75
2E36:  MOVWF  xB3
2E38:  MOVLW  65
2E3A:  MOVWF  xB4
2E3C:  MOVLW  62
2E3E:  MOVWF  xB5
2E40:  MOVLW  61
2E42:  MOVWF  xB6
2E44:  CLRF   xB7
2E46:  CLRF   xED
2E48:  CLRF   xEE
2E4A:  MOVLW  4C
2E4C:  MOVLB  1
2E4E:  MOVWF  x68
2E50:  MOVLW  75
2E52:  MOVWF  x69
2E54:  MOVLW  6E
2E56:  MOVWF  x6A
2E58:  MOVLW  65
2E5A:  MOVWF  x6B
2E5C:  MOVLW  73
2E5E:  MOVWF  x6C
2E60:  CLRF   x6D
2E62:  CLRF   x6E
2E64:  CLRF   x6F
2E66:  CLRF   x70
2E68:  CLRF   x71
2E6A:  CLRF   x72
2E6C:  MOVLW  4D
2E6E:  MOVWF  x73
2E70:  MOVLW  61
2E72:  MOVWF  x74
2E74:  MOVLW  72
2E76:  MOVWF  x75
2E78:  MOVLW  74
2E7A:  MOVWF  x76
2E7C:  MOVLW  65
2E7E:  MOVWF  x77
2E80:  MOVLW  73
2E82:  MOVWF  x78
2E84:  CLRF   x79
2E86:  CLRF   x7A
2E88:  CLRF   x7B
2E8A:  CLRF   x7C
2E8C:  CLRF   x7D
2E8E:  MOVLW  4D
2E90:  MOVWF  x7E
2E92:  MOVLW  69
2E94:  MOVWF  x7F
2E96:  MOVLW  E9
2E98:  MOVWF  x80
2E9A:  MOVLW  72
2E9C:  MOVWF  x81
2E9E:  MOVLW  63
2EA0:  MOVWF  x82
2EA2:  MOVLW  6F
2EA4:  MOVWF  x83
2EA6:  MOVLW  6C
2EA8:  MOVWF  x84
2EAA:  MOVLW  65
2EAC:  MOVWF  x85
2EAE:  MOVLW  73
2EB0:  MOVWF  x86
2EB2:  CLRF   x87
2EB4:  CLRF   x88
2EB6:  MOVLW  4A
2EB8:  MOVWF  x89
2EBA:  MOVLW  75
2EBC:  MOVWF  x8A
2EBE:  MOVLW  65
2EC0:  MOVWF  x8B
2EC2:  MOVLW  76
2EC4:  MOVWF  x8C
2EC6:  MOVLW  65
2EC8:  MOVWF  x8D
2ECA:  MOVLW  73
2ECC:  MOVWF  x8E
2ECE:  CLRF   x8F
2ED0:  CLRF   x90
2ED2:  CLRF   x91
2ED4:  CLRF   x92
2ED6:  CLRF   x93
2ED8:  MOVLW  56
2EDA:  MOVWF  x94
2EDC:  MOVLW  69
2EDE:  MOVWF  x95
2EE0:  MOVLW  65
2EE2:  MOVWF  x96
2EE4:  MOVLW  72
2EE6:  MOVWF  x97
2EE8:  MOVLW  6E
2EEA:  MOVWF  x98
2EEC:  MOVLW  65
2EEE:  MOVWF  x99
2EF0:  MOVLW  73
2EF2:  MOVWF  x9A
2EF4:  CLRF   x9B
2EF6:  CLRF   x9C
2EF8:  CLRF   x9D
2EFA:  CLRF   x9E
2EFC:  MOVLW  53
2EFE:  MOVWF  x9F
2F00:  MOVLW  E1
2F02:  MOVWF  xA0
2F04:  MOVLW  62
2F06:  MOVWF  xA1
2F08:  MOVLW  61
2F0A:  MOVWF  xA2
2F0C:  MOVLW  64
2F0E:  MOVWF  xA3
2F10:  MOVLW  6F
2F12:  MOVWF  xA4
2F14:  CLRF   xA5
2F16:  CLRF   xA6
2F18:  CLRF   xA7
2F1A:  CLRF   xA8
2F1C:  CLRF   xA9
2F1E:  MOVLW  44
2F20:  MOVWF  xAA
2F22:  MOVLW  6F
2F24:  MOVWF  xAB
2F26:  MOVLW  6D
2F28:  MOVWF  xAC
2F2A:  MOVLW  69
2F2C:  MOVWF  xAD
2F2E:  MOVLW  6E
2F30:  MOVWF  xAE
2F32:  MOVLW  67
2F34:  MOVWF  xAF
2F36:  MOVLW  6F
2F38:  MOVWF  xB0
2F3A:  CLRF   xB1
2F3C:  CLRF   xB2
2F3E:  CLRF   xB5
2F40:  CLRF   xBD
2F42:  CLRF   xBE
2F44:  CLRF   xBF
2F46:  CLRF   xC0
2F48:  CLRF   xC1
....................    setup_devices(); 
2F4A:  MOVLB  0
2F4C:  BRA    2764
....................    #ifdef use_rtos 
....................    _debug_usb(); 
2F4E:  CALL   1C0A
....................    if(input(PIN_LOG) == LOG_ENABLE){ 
2F52:  BSF    F95.2
2F54:  BTFSS  F83.2
2F56:  BRA    2F5C
....................       modo_configuracion();   // si esta el log activo entra en modo configuracion 
2F58:  BRA    29B2
....................    }else{ 
2F5A:  BRA    31D2
....................       rtos_run(); //A partir de aqu comenzar la ejecucin de las tareas 
2F5C:  CLRF   xEF
2F5E:  CLRF   xF1
2F60:  MOVLW  0A
2F62:  MOVWF  xF0
2F64:  CLRF   xF3
2F66:  CLRF   xF2
2F68:  CLRF   xF9
2F6A:  CLRF   xF8
2F6C:  CLRF   xF7
2F6E:  CLRF   xF6
2F70:  MOVLW  FF
2F72:  MOVWF  xFB
2F74:  MOVWF  xFA
2F76:  CLRF   xFD
2F78:  CLRF   xFC
2F7A:  MOVLW  16
2F7C:  MOVWF  xF4
2F7E:  MOVLW  11
2F80:  MOVWF  xF5
2F82:  CLRF   xFE
2F84:  MOVLB  1
2F86:  CLRF   x00
2F88:  MOVLW  0A
2F8A:  MOVLB  0
2F8C:  MOVWF  xFF
2F8E:  MOVLB  1
2F90:  CLRF   x02
2F92:  CLRF   x01
2F94:  CLRF   x08
2F96:  CLRF   x07
2F98:  CLRF   x06
2F9A:  CLRF   x05
2F9C:  MOVLW  FF
2F9E:  MOVWF  x0A
2FA0:  MOVWF  x09
2FA2:  CLRF   x0C
2FA4:  CLRF   x0B
2FA6:  MOVLW  4A
2FA8:  MOVWF  x03
2FAA:  MOVLW  12
2FAC:  MOVWF  x04
2FAE:  CLRF   x0D
2FB0:  CLRF   x0F
2FB2:  MOVLW  06
2FB4:  MOVWF  x0E
2FB6:  CLRF   x11
2FB8:  CLRF   x10
2FBA:  CLRF   x17
2FBC:  CLRF   x16
2FBE:  CLRF   x15
2FC0:  CLRF   x14
2FC2:  MOVLW  FF
2FC4:  MOVWF  x19
2FC6:  MOVWF  x18
2FC8:  CLRF   x1B
2FCA:  CLRF   x1A
2FCC:  MOVLW  A6
2FCE:  MOVWF  x12
2FD0:  MOVLW  1E
2FD2:  MOVWF  x13
2FD4:  CLRF   x1C
2FD6:  CLRF   x1E
2FD8:  MOVLW  06
2FDA:  MOVWF  x1D
2FDC:  CLRF   x20
2FDE:  CLRF   x1F
2FE0:  CLRF   x26
2FE2:  CLRF   x25
2FE4:  CLRF   x24
2FE6:  CLRF   x23
2FE8:  MOVLW  FF
2FEA:  MOVWF  x28
2FEC:  MOVWF  x27
2FEE:  CLRF   x2A
2FF0:  CLRF   x29
2FF2:  MOVLW  D6
2FF4:  MOVWF  x21
2FF6:  MOVLW  1E
2FF8:  MOVWF  x22
2FFA:  CLRF   x2B
2FFC:  CLRF   x2D
2FFE:  MOVLW  06
3000:  MOVWF  x2C
3002:  CLRF   x2F
3004:  CLRF   x2E
3006:  CLRF   x35
3008:  CLRF   x34
300A:  CLRF   x33
300C:  CLRF   x32
300E:  MOVLW  FF
3010:  MOVWF  x37
3012:  MOVWF  x36
3014:  CLRF   x39
3016:  CLRF   x38
3018:  MOVLW  0A
301A:  MOVWF  x30
301C:  MOVLW  1F
301E:  MOVWF  x31
3020:  CLRF   x3A
3022:  CLRF   x3C
3024:  MOVLW  09
3026:  MOVWF  x3B
3028:  CLRF   x3E
302A:  CLRF   x3D
302C:  CLRF   x44
302E:  CLRF   x43
3030:  CLRF   x42
3032:  CLRF   x41
3034:  MOVLW  FF
3036:  MOVWF  x46
3038:  MOVWF  x45
303A:  CLRF   x48
303C:  CLRF   x47
303E:  MOVLW  86
3040:  MOVWF  x3F
3042:  MOVLW  1F
3044:  MOVWF  x40
3046:  CLRF   x49
3048:  CLRF   x4B
304A:  MOVLW  09
304C:  MOVWF  x4A
304E:  CLRF   x4D
3050:  CLRF   x4C
3052:  CLRF   x53
3054:  CLRF   x52
3056:  CLRF   x51
3058:  CLRF   x50
305A:  MOVLW  FF
305C:  MOVWF  x55
305E:  MOVWF  x54
3060:  CLRF   x57
3062:  CLRF   x56
3064:  MOVLW  CA
3066:  MOVWF  x4E
3068:  MOVLW  1F
306A:  MOVWF  x4F
306C:  CLRF   x58
306E:  CLRF   x5A
3070:  MOVLW  11
3072:  MOVWF  x59
3074:  CLRF   x5C
3076:  CLRF   x5B
3078:  CLRF   x62
307A:  CLRF   x61
307C:  CLRF   x60
307E:  CLRF   x5F
3080:  MOVLW  FF
3082:  MOVWF  x64
3084:  MOVWF  x63
3086:  CLRF   x66
3088:  CLRF   x65
308A:  MOVLW  E2
308C:  MOVWF  x5D
308E:  MOVLW  20
3090:  MOVWF  x5E
3092:  CLRF   17
3094:  MOVLW  81
3096:  MOVWF  FD5
3098:  MOVLW  0B
309A:  MOVWF  FD7
309C:  MOVLW  DC
309E:  MOVWF  FD6
30A0:  BCF    FF2.2
30A2:  MOVLW  81
30A4:  MOVWF  FD5
30A6:  MOVLW  0B
30A8:  MOVWF  FD7
30AA:  MOVLW  DC
30AC:  MOVWF  FD6
30AE:  BCF    FF2.2
30B0:  CLRF   19
30B2:  MOVLW  08
30B4:  MOVWF  18
30B6:  BCF    FD8.0
30B8:  RLCF   17,W
30BA:  MOVWF  00
30BC:  MOVLB  0
30BE:  CALL   0258
30C2:  MOVWF  02
30C4:  MOVLW  01
30C6:  ADDWF  00,W
30C8:  CALL   0258
30CC:  MOVWF  03
30CE:  MOVFF  03,FEA
30D2:  MOVFF  02,FE9
30D6:  MOVFF  FEF,02
30DA:  INCF   FE9,F
30DC:  MOVFF  FEF,00
30E0:  MOVFF  FEC,01
30E4:  INCF   FEC,F
30E6:  MOVFF  FEF,03
30EA:  BNZ   30F0
30EC:  INCF   FEC,F
30EE:  MOVF   FED,F
30F0:  MOVF   FEC,W
30F2:  SUBWF  01,W
30F4:  BNZ   31AE
30F6:  MOVF   00,W
30F8:  SUBWF  03,W
30FA:  BNZ   31AE
30FC:  MOVF   FED,F
30FE:  MOVF   FED,F
3100:  CLRF   FEE
3102:  CLRF   FEE
3104:  BTFSC  02.7
3106:  BRA    31AE
3108:  MOVF   FEC,F
310A:  MOVFF  FEC,FFA
310E:  MOVF   FED,F
3110:  MOVFF  FEF,FE8
3114:  MOVWF  FF9
3116:  MOVLB  0
3118:  BCF    FD8.0
311A:  RLCF   17,W
311C:  MOVWF  00
311E:  CALL   0258
3122:  MOVWF  02
3124:  MOVLW  01
3126:  ADDWF  00,W
3128:  CALL   0258
312C:  MOVWF  03
312E:  MOVFF  03,FEA
3132:  MOVFF  02,FE9
3136:  BTFSS  FF2.2
3138:  BRA    313C
313A:  BSF    FEF.4
313C:  MOVLW  07
313E:  ADDWF  FE9,F
3140:  MOVLW  00
3142:  ADDWFC FEA,F
3144:  MOVF   FD6,W
3146:  MOVFF  FD7,03
314A:  ADDLW  24
314C:  MOVWF  01
314E:  MOVLW  0B
3150:  SUBWFB 03,W
3152:  MOVWF  02
3154:  MOVF   01,W
3156:  ADDWF  FEF,F
3158:  MOVF   02,W
315A:  ADDWFC FEC,W
315C:  MOVWF  FEF
315E:  MOVLW  00
3160:  ADDWFC FEC,W
3162:  MOVWF  FEF
3164:  MOVLW  00
3166:  ADDWFC FEC,W
3168:  MOVWF  FEF
316A:  MOVF   FED,F
316C:  MOVF   FED,F
316E:  MOVF   FED,F
3170:  MOVF   FEC,W
3172:  MOVF   FEC,W
3174:  MOVF   FEC,W
3176:  MOVF   FEC,W
3178:  MOVF   02,W
317A:  SUBWF  FEC,W
317C:  BNC   3192
317E:  BNZ   3188
3180:  MOVF   FED,F
3182:  MOVF   01,W
3184:  SUBWF  FEE,W
3186:  BNC   3192
3188:  MOVF   FED,F
318A:  MOVF   01,W
318C:  MOVWF  FEF
318E:  MOVF   02,W
3190:  MOVWF  FEC
3192:  MOVF   FEE,F
3194:  MOVF   FEC,W
3196:  SUBWF  02,W
3198:  BNC   31AE
319A:  BNZ   31A4
319C:  MOVF   FED,F
319E:  MOVF   01,W
31A0:  SUBWF  FEE,W
31A2:  BC    31AE
31A4:  MOVF   FED,F
31A6:  MOVF   01,W
31A8:  MOVWF  FEF
31AA:  MOVF   02,W
31AC:  MOVWF  FEC
31AE:  INCF   17,F
31B0:  MOVLW  08
31B2:  SUBWF  17,W
31B4:  BTFSC  FD8.2
31B6:  BRA    31BC
31B8:  MOVLB  1
31BA:  BRA    30B6
31BC:  CLRF   17
31BE:  MOVF   FD6,W
31C0:  MOVFF  FD7,03
31C4:  BTFSS  FF2.2
31C6:  BRA    31CC
31C8:  MOVLB  1
31CA:  BRA    30A6
31CC:  BRA    31BE
31CE:  MOVLW  FF
31D0:  MOVWF  17
....................    } 
....................    #else 
....................    while(1){ 
....................       if(_debug_usb()){ 
....................          test_comunicacion(); 
....................          test_reloj(); 
....................          //test_ADC(); 
....................          //test_memoria(); 
....................          //test_ccp(); 
....................          delay_ms(333); 
....................       }else{ 
....................          salida = (salida)? 0 : 1; 
....................          if(salida) output_bit(INDICADOR_RUN, 1); 
....................          else output_bit(INDICADOR_RUN, 0); 
....................          delay_ms(333); 
....................       } 
....................      } 
....................    #endif 
.................... } 
....................  
.................... /*======================= implementacion de tareas =======================*/ 
.................... #include "comunicacion.c" 
.................... //#include "Nucleo.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... #include <usb_cdc.h> 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... unsigned int indice = 0; 
.................... int COM_init(){ 
31D2:  SLEEP 
.................... 	usb_detach();  
*
231C:  RCALL  1B88
.................... 	usb_cdc_init(); 
231E:  CALL   03BA
....................    usb_init_cs(); 
2322:  BRA    2316
....................    /*usb_task(); 
....................    if(usb_attached()){ 
....................       if(usb_enumerated()){ 
....................          return (USB_OK); 
....................       }else{ 
....................          return(USB_NO_ENUMERATED); 
....................       } 
....................    } 
....................    return (USB_NO_ATTACHED);*/ 
....................    return COM_sense(); 
2324:  RCALL  1BE8
2326:  MOVF   01,W
.................... } 
2328:  GOTO   2702 (RETURN)
....................  
.................... int8 COM_sense(){ 
....................    usb_task(); 
*
1BE8:  BRA    1BAE
....................    if(usb_attached()){ 
1BEA:  BSF    F95.3
1BEC:  BTFSS  F83.3
1BEE:  BRA    1C04
....................       if(usb_enumerated()){ 
1BF0:  BRA    1BE0
1BF2:  MOVF   01,F
1BF4:  BZ    1BFE
....................          return (USB_OK); 
1BF6:  MOVLW  01
1BF8:  MOVWF  01
1BFA:  BRA    1C08
....................       }else{ 
1BFC:  BRA    1C04
....................          return(USB_NO_ENUMERATED); 
1BFE:  MOVLW  00
1C00:  MOVWF  01
1C02:  BRA    1C08
....................       } 
....................    } 
....................    return(USB_NO_ATTACHED); 
1C04:  MOVLW  FF
1C06:  MOVWF  01
.................... } 
1C08:  RETLW  00
....................  
.................... //de aqui en adelante hay que quitar estas funciones que no se utilizan 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1){ 
....................    indice = 0; 
....................    if(!COM_READY) return(-1); 
....................    while(indice < leng){ 
....................       if(wait == 1) 
....................          usb_cdc_putc(buffer[indice]); 
....................       else 
....................          usb_cdc_putc_fast(buffer[indice]); 
....................       indice++; 
....................    } 
....................    return (indice); 
.................... } 
....................  
.................... int8 COM_recive(char* buffer, unsigned int8 leng){ 
....................    indice = 0; 
....................    if(!COM_READY) return (-1); 
....................    while(indice < leng){ 
....................       if(usb_cdc_kbhit()){ 
....................          buffer[indice] = usb_cdc_getc(); 
....................          indice++; 
....................       } 
....................    } 
....................    return(indice); 
.................... } 
....................  
.................... void COM_printf(char* message){ 
.................... 	printf(usb_cdc_putc,"%s\n\r",message); 
.................... } 
....................  
.................... #include "analogo_digital.c" 
.................... //#include "Nucleo.h" 
.................... //#include "analogo_digital.h" 
.................... #ifdef ANALOGO_DIGITAL_H 
....................  
.................... #define ADC_TAD_MUL_4      0x10 
.................... #define ADC_INPUT_PORT		0x2F 
....................  
.................... int AD_init_adc(){ 
.................... //corregir despues 
.................... /* 
.................... #if (getenv("CLOCK") == 4000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 8000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 10000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif (getenv("CLOCK") == 20000000) 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); // default 
.................... #endif 
.................... */	 
.................... 	output_a(0x00); 
*
2476:  CLRF   F92
2478:  CLRF   F89
.................... 	set_tris_a(ADC_INPUT_PORT);		//RA0 a RA4 entradas 
247A:  MOVLW  2F
247C:  MOVWF  F92
.................... 	setup_adc_ports(AN0_TO_AN4); 
247E:  MOVF   FC1,W
2480:  ANDLW  C0
2482:  IORLW  0A
2484:  MOVWF  FC1
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_4|VSS_VDD);	 
2486:  BCF    FC0.0
2488:  BSF    FC0.1
248A:  BCF    FC0.2
248C:  BSF    FC0.7
248E:  BSF    FC2.0
.................... 	return (0); 
2490:  MOVLW  00
2492:  MOVWF  01
.................... } 
2494:  GOTO   2716 (RETURN)
....................  
.................... int AD_leer_canal(int canal, int16 *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
*
140A:  MOVLB  2
140C:  RLCF   x6C,W
140E:  MOVWF  00
1410:  RLCF   00,F
1412:  MOVLW  FC
1414:  ANDWF  00,F
1416:  MOVF   FC2,W
1418:  ANDLW  C3
141A:  IORWF  00,W
141C:  MOVWF  FC2
.................... 	delay_us(10); 
141E:  MOVLW  0D
1420:  MOVWF  00
1422:  DECFSZ 00,F
1424:  BRA    1422
.................... 	read_adc(ADC_START_ONLY); 
1426:  BSF    FC2.1
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
1428:  BCF    x6F.0
142A:  BTFSS  FC2.1
142C:  BSF    x6F.0
.................... 	}while(!done); 
142E:  BTFSS  x6F.0
1430:  BRA    1428
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
1432:  MOVFF  26E,03
1436:  MOVFF  26D,FE9
143A:  MOVFF  26E,FEA
143E:  BTFSC  FC2.1
1440:  BRA    143E
1442:  MOVFF  FC3,FEF
1446:  MOVFF  FC4,FEC
.................... 	delay_us(20); 
144A:  MOVLW  1A
144C:  MOVWF  00
144E:  DECFSZ 00,F
1450:  BRA    144E
1452:  NOP   
.................... 	return (0); 
1454:  MOVLW  00
1456:  MOVWF  01
.................... } 
1458:  MOVLB  0
145A:  RETLW  00
....................  
.................... #endif	//ANALOGO_DIGITAL_H 
....................  
.................... #include "ds1307.c" 
.................... //#include "Nucleo.h" 
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... /// ds1307.c                                                                        /// 
.................... /// Driver for Real Time Clock                                                      /// 
.................... /// modified by Redpic 08/2006                                                      /// 
.................... /// http://picmania.garcia-cuervo.net                                               /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_init(val)                                                           /// 
.................... ///   - Enable oscillator without clearing the seconds register                     /// 
.................... ///     used when PIC loses power and DS1307 run from 3V BAT                        /// 
.................... ///   - Config Control Register with next parameters:                               /// 
.................... ///            DS1307_ALL_DISABLED All disabled                                     /// 
.................... ///            DS1307_OUT_ON_DISABLED_HIHG Out to Hight on Disable Out              /// 
.................... ///            DS1307_OUT_ENABLED Out Enabled                                       /// 
.................... ///            DS1307_OUT_1_HZ Freq. Out to 1 Hz                                    /// 
.................... ///            DS1307_OUT_4_KHZ Freq. Out to 4.096 Khz                              /// 
.................... ///            DS1307_OUT_8_KHZ Freq. Out to 8.192 Khz                              /// 
.................... ///            DS1307_OUT_32_KHZ Freq. Out to 32.768 Khz                            /// 
.................... ///                                                                                 /// 
.................... ///            Example init:                                                        /// 
.................... ///                    ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_date(day,mth,year,dow) - Get the date                           /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_time(hr,min,sec) - Get the time                                 /// 
.................... ///                                                                                 /// 
.................... /// char ds1307_read_nvram_byte(char addr) - Read byte in address                   /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value) - Write byte in address     /// 
.................... ///                                                                                 /// 
.................... /// void ds1307_get_day_of_week(char* ptr) - Get string Day Of Week                 /// 
.................... ///                                                                                 /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and /// 
.................... /// enable Global on ends else usar can do it hiself                                /// 
.................... ///                                                                                 /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
....................  
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA PIN_B0 
.................... #define RTC_SCL PIN_B1 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
....................  
.................... #define DS1307_ALL_DISABLED 0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED 0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ 0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ 0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ 0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ 0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram 0x08 
.................... #define End_user_address_nvram 0x3f 
....................  
.................... #define USE_INTERRUPTS 1 
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... byte DS_vic = 0x00; 
.................... /* 
.................... byte DS_dia = 0x00; 
.................... byte DS_mes = 0x00; 
.................... byte DS_anio = 0x00; 
....................  
.................... byte DS_hor = 0x00; 
.................... byte DS_min = 0x00; 
.................... byte DS_sec = 0x00; 
.................... */ 
.................... #endif 
....................  
....................  
....................  
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
24F6:  MOVLB  1
24F8:  CLRF   xD3
....................  
....................   byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
24FA:  BSF    F93.0
24FC:  MOVLW  04
24FE:  MOVWF  00
2500:  DECFSZ 00,F
2502:  BRA    2500
2504:  BSF    F93.1
2506:  MOVLW  04
2508:  MOVWF  00
250A:  DECFSZ 00,F
250C:  BRA    250A
250E:  BCF    F8A.0
2510:  BCF    F93.0
2512:  MOVLW  04
2514:  MOVWF  00
2516:  DECFSZ 00,F
2518:  BRA    2516
251A:  BCF    F8A.1
251C:  BCF    F93.1
....................   i2c_write(0xD0); 
251E:  MOVLW  D0
2520:  MOVWF  xF0
2522:  MOVLB  0
2524:  CALL   1140
....................   i2c_write(0x00); 
2528:  MOVLB  1
252A:  CLRF   xF0
252C:  MOVLB  0
252E:  CALL   1140
....................   i2c_start(); 
2532:  BSF    F93.0
2534:  MOVLW  04
2536:  MOVWF  00
2538:  DECFSZ 00,F
253A:  BRA    2538
253C:  BSF    F93.1
253E:  MOVLW  04
2540:  MOVWF  00
2542:  DECFSZ 00,F
2544:  BRA    2542
2546:  BTFSS  F81.1
2548:  BRA    2546
254A:  BCF    F8A.0
254C:  BCF    F93.0
254E:  MOVLW  04
2550:  MOVWF  00
2552:  DECFSZ 00,F
2554:  BRA    2552
2556:  BCF    F8A.1
2558:  BCF    F93.1
....................   i2c_write(0xD1); 
255A:  MOVLW  D1
255C:  MOVLB  1
255E:  MOVWF  xF0
2560:  MOVLB  0
2562:  CALL   1140
....................   seconds = ds1307_bcd2bin(i2c_read(0)); 
2566:  CLRF   00
2568:  CALL   11B6
256C:  MOVFF  01,1D4
2570:  MOVFF  01,1F1
2574:  CALL   1220
2578:  MOVFF  01,1D3
....................   i2c_stop(); 
257C:  BCF    F93.0
257E:  NOP   
2580:  BSF    F93.1
2582:  BTFSS  F81.1
2584:  BRA    2582
2586:  MOVLW  04
2588:  MOVWF  00
258A:  DECFSZ 00,F
258C:  BRA    258A
258E:  BRA    2590
2590:  NOP   
2592:  BSF    F93.0
2594:  MOVLW  04
2596:  MOVWF  00
2598:  DECFSZ 00,F
259A:  BRA    2598
....................   seconds &= 0x7F; 
259C:  MOVLB  1
259E:  BCF    xD3.7
....................  
....................   delay_us(3); 
25A0:  MOVLW  03
25A2:  MOVWF  00
25A4:  DECFSZ 00,F
25A6:  BRA    25A4
25A8:  BRA    25AA
....................  
....................   i2c_start(); 
25AA:  BSF    F93.0
25AC:  MOVLW  04
25AE:  MOVWF  00
25B0:  DECFSZ 00,F
25B2:  BRA    25B0
25B4:  BSF    F93.1
25B6:  MOVLW  04
25B8:  MOVWF  00
25BA:  DECFSZ 00,F
25BC:  BRA    25BA
25BE:  BCF    F8A.0
25C0:  BCF    F93.0
25C2:  MOVLW  04
25C4:  MOVWF  00
25C6:  DECFSZ 00,F
25C8:  BRA    25C6
25CA:  BCF    F8A.1
25CC:  BCF    F93.1
....................   i2c_write(0xD0); 
25CE:  MOVLW  D0
25D0:  MOVWF  xF0
25D2:  MOVLB  0
25D4:  CALL   1140
....................   i2c_write(0x00); 
25D8:  MOVLB  1
25DA:  CLRF   xF0
25DC:  MOVLB  0
25DE:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(seconds)); 
25E2:  MOVFF  1D3,1D9
25E6:  RCALL  24CE
25E8:  MOVFF  01,1D4
25EC:  MOVFF  01,1F0
25F0:  CALL   1140
....................   i2c_start(); 
25F4:  BSF    F93.0
25F6:  MOVLW  04
25F8:  MOVWF  00
25FA:  DECFSZ 00,F
25FC:  BRA    25FA
25FE:  BSF    F93.1
2600:  MOVLW  04
2602:  MOVWF  00
2604:  DECFSZ 00,F
2606:  BRA    2604
2608:  BTFSS  F81.1
260A:  BRA    2608
260C:  BCF    F8A.0
260E:  BCF    F93.0
2610:  MOVLW  04
2612:  MOVWF  00
2614:  DECFSZ 00,F
2616:  BRA    2614
2618:  BCF    F8A.1
261A:  BCF    F93.1
....................   i2c_write(0xD0); 
261C:  MOVLW  D0
261E:  MOVLB  1
2620:  MOVWF  xF0
2622:  MOVLB  0
2624:  CALL   1140
....................   i2c_write(0x07); 
2628:  MOVLW  07
262A:  MOVLB  1
262C:  MOVWF  xF0
262E:  MOVLB  0
2630:  CALL   1140
....................   i2c_write(val); 
2634:  MOVFF  1D2,1F0
2638:  CALL   1140
....................   i2c_stop(); 
263C:  BCF    F93.0
263E:  NOP   
2640:  BSF    F93.1
2642:  BTFSS  F81.1
2644:  BRA    2642
2646:  MOVLW  04
2648:  MOVWF  00
264A:  DECFSZ 00,F
264C:  BRA    264A
264E:  BRA    2650
2650:  NOP   
2652:  BSF    F93.0
2654:  MOVLW  04
2656:  MOVWF  00
2658:  DECFSZ 00,F
265A:  BRA    2658
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
265C:  GOTO   272A (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
*
284A:  MOVLB  1
284C:  BCF    xD8.7
....................   hr &= 0x3F; 
284E:  MOVLW  3F
2850:  ANDWF  xD6,F
....................  
....................   i2c_start(); 
2852:  BSF    F93.0
2854:  MOVLW  04
2856:  MOVWF  00
2858:  DECFSZ 00,F
285A:  BRA    2858
285C:  BSF    F93.1
285E:  MOVLW  04
2860:  MOVWF  00
2862:  DECFSZ 00,F
2864:  BRA    2862
2866:  BCF    F8A.0
2868:  BCF    F93.0
286A:  MOVLW  04
286C:  MOVWF  00
286E:  DECFSZ 00,F
2870:  BRA    286E
2872:  BCF    F8A.1
2874:  BCF    F93.1
....................   i2c_write(0xD0); 
2876:  MOVLW  D0
2878:  MOVWF  xF0
287A:  MOVLB  0
287C:  CALL   1140
....................   i2c_write(0x00); 
2880:  MOVLB  1
2882:  CLRF   xF0
2884:  MOVLB  0
2886:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(sec)); 
288A:  MOVFF  1D8,1D9
288E:  RCALL  24CE
2890:  MOVFF  01,1D9
2894:  MOVFF  01,1F0
2898:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(min)); 
289C:  MOVFF  1D7,1D9
28A0:  RCALL  24CE
28A2:  MOVFF  01,1D9
28A6:  MOVFF  01,1F0
28AA:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(hr)); 
28AE:  MOVFF  1D6,1D9
28B2:  RCALL  24CE
28B4:  MOVFF  01,1D9
28B8:  MOVFF  01,1F0
28BC:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(dow)); 
28C0:  MOVFF  1D5,1D9
28C4:  RCALL  24CE
28C6:  MOVFF  01,1D9
28CA:  MOVFF  01,1F0
28CE:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(day)); 
28D2:  MOVFF  1D2,1D9
28D6:  RCALL  24CE
28D8:  MOVFF  01,1D9
28DC:  MOVFF  01,1F0
28E0:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(mth)); 
28E4:  MOVFF  1D3,1D9
28E8:  RCALL  24CE
28EA:  MOVFF  01,1D9
28EE:  MOVFF  01,1F0
28F2:  CALL   1140
....................   i2c_write(ds1307_bin2bcd(year)); 
28F6:  MOVFF  1D4,1D9
28FA:  RCALL  24CE
28FC:  MOVFF  01,1D9
2900:  MOVFF  01,1F0
2904:  CALL   1140
....................   i2c_stop(); 
2908:  BCF    F93.0
290A:  NOP   
290C:  BSF    F93.1
290E:  BTFSS  F81.1
2910:  BRA    290E
2912:  MOVLW  04
2914:  MOVWF  00
2916:  DECFSZ 00,F
2918:  BRA    2916
291A:  BRA    291C
291C:  NOP   
291E:  BSF    F93.0
2920:  MOVLW  04
2922:  MOVWF  00
2924:  DECFSZ 00,F
2926:  BRA    2924
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
2928:  GOTO   2A3C (RETURN)
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
124A:  BSF    F93.0
124C:  MOVLW  04
124E:  MOVWF  00
1250:  DECFSZ 00,F
1252:  BRA    1250
1254:  BSF    F93.1
1256:  MOVLW  04
1258:  MOVWF  00
125A:  DECFSZ 00,F
125C:  BRA    125A
125E:  BCF    F8A.0
1260:  BCF    F93.0
1262:  MOVLW  04
1264:  MOVWF  00
1266:  DECFSZ 00,F
1268:  BRA    1266
126A:  BCF    F8A.1
126C:  BCF    F93.1
*
2A52:  BSF    F93.0
2A54:  MOVLW  04
2A56:  MOVWF  00
2A58:  DECFSZ 00,F
2A5A:  BRA    2A58
2A5C:  BSF    F93.1
2A5E:  MOVLW  04
2A60:  MOVWF  00
2A62:  DECFSZ 00,F
2A64:  BRA    2A62
2A66:  BCF    F8A.0
2A68:  BCF    F93.0
2A6A:  MOVLW  04
2A6C:  MOVWF  00
2A6E:  DECFSZ 00,F
2A70:  BRA    2A6E
2A72:  BCF    F8A.1
2A74:  BCF    F93.1
....................   i2c_write(0xD0); 
*
126E:  MOVLW  D0
1270:  MOVLB  1
1272:  MOVWF  xF0
1274:  MOVLB  0
1276:  RCALL  1140
*
2A76:  MOVLW  D0
2A78:  MOVLB  1
2A7A:  MOVWF  xF0
2A7C:  MOVLB  0
2A7E:  CALL   1140
....................   i2c_write(0x03); 
*
1278:  MOVLW  03
127A:  MOVLB  1
127C:  MOVWF  xF0
127E:  MOVLB  0
1280:  RCALL  1140
*
2A82:  MOVLW  03
2A84:  MOVLB  1
2A86:  MOVWF  xF0
2A88:  MOVLB  0
2A8A:  CALL   1140
....................   i2c_start(); 
*
1282:  BSF    F93.0
1284:  MOVLW  04
1286:  MOVWF  00
1288:  DECFSZ 00,F
128A:  BRA    1288
128C:  BSF    F93.1
128E:  MOVLW  04
1290:  MOVWF  00
1292:  DECFSZ 00,F
1294:  BRA    1292
1296:  BTFSS  F81.1
1298:  BRA    1296
129A:  BCF    F8A.0
129C:  BCF    F93.0
129E:  MOVLW  04
12A0:  MOVWF  00
12A2:  DECFSZ 00,F
12A4:  BRA    12A2
12A6:  BCF    F8A.1
12A8:  BCF    F93.1
*
2A8E:  BSF    F93.0
2A90:  MOVLW  04
2A92:  MOVWF  00
2A94:  DECFSZ 00,F
2A96:  BRA    2A94
2A98:  BSF    F93.1
2A9A:  MOVLW  04
2A9C:  MOVWF  00
2A9E:  DECFSZ 00,F
2AA0:  BRA    2A9E
2AA2:  BTFSS  F81.1
2AA4:  BRA    2AA2
2AA6:  BCF    F8A.0
2AA8:  BCF    F93.0
2AAA:  MOVLW  04
2AAC:  MOVWF  00
2AAE:  DECFSZ 00,F
2AB0:  BRA    2AAE
2AB2:  BCF    F8A.1
2AB4:  BCF    F93.1
....................   i2c_write(0xD1); 
*
12AA:  MOVLW  D1
12AC:  MOVLB  1
12AE:  MOVWF  xF0
12B0:  MOVLB  0
12B2:  RCALL  1140
*
2AB6:  MOVLW  D1
2AB8:  MOVLB  1
2ABA:  MOVWF  xF0
2ABC:  MOVLB  0
2ABE:  CALL   1140
....................   dow = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
12B4:  MOVLW  01
12B6:  MOVWF  00
12B8:  RCALL  11B6
12BA:  MOVF   01,W
12BC:  ANDLW  7F
12BE:  MOVLB  1
12C0:  MOVWF  xEC
12C2:  MOVWF  xF1
12C4:  MOVLB  0
12C6:  RCALL  1220
12C8:  MOVFF  01,87
*
2AC2:  MOVLW  01
2AC4:  MOVWF  00
2AC6:  CALL   11B6
2ACA:  MOVF   01,W
2ACC:  ANDLW  7F
2ACE:  MOVLB  1
2AD0:  MOVWF  xEC
2AD2:  MOVWF  xF1
2AD4:  MOVLB  0
2AD6:  CALL   1220
2ADA:  MOVFF  01,E6
....................   day = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
12CC:  MOVLW  01
12CE:  MOVWF  00
12D0:  RCALL  11B6
12D2:  MOVF   01,W
12D4:  ANDLW  3F
12D6:  MOVLB  1
12D8:  MOVWF  xEC
12DA:  MOVWF  xF1
12DC:  MOVLB  0
12DE:  RCALL  1220
12E0:  MOVFF  01,DF
*
2ADE:  MOVLW  01
2AE0:  MOVWF  00
2AE2:  CALL   11B6
2AE6:  MOVF   01,W
2AE8:  ANDLW  3F
2AEA:  MOVLB  1
2AEC:  MOVWF  xEC
2AEE:  MOVWF  xF1
2AF0:  MOVLB  0
2AF2:  CALL   1220
2AF6:  MOVFF  01,DF
....................   mth = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
12E4:  MOVLW  01
12E6:  MOVWF  00
12E8:  RCALL  11B6
12EA:  MOVF   01,W
12EC:  ANDLW  1F
12EE:  MOVLB  1
12F0:  MOVWF  xEC
12F2:  MOVWF  xF1
12F4:  MOVLB  0
12F6:  RCALL  1220
12F8:  MOVFF  01,E0
*
2AFA:  MOVLW  01
2AFC:  MOVWF  00
2AFE:  CALL   11B6
2B02:  MOVF   01,W
2B04:  ANDLW  1F
2B06:  MOVLB  1
2B08:  MOVWF  xEC
2B0A:  MOVWF  xF1
2B0C:  MOVLB  0
2B0E:  CALL   1220
2B12:  MOVFF  01,E0
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
12FC:  CLRF   00
12FE:  RCALL  11B6
1300:  MOVFF  01,1EC
1304:  MOVFF  01,1F1
1308:  RCALL  1220
130A:  MOVFF  01,E1
*
2B16:  CLRF   00
2B18:  CALL   11B6
2B1C:  MOVFF  01,1EC
2B20:  MOVFF  01,1F1
2B24:  CALL   1220
2B28:  MOVFF  01,E1
....................   i2c_stop(); 
*
130E:  BCF    F93.0
1310:  NOP   
1312:  BSF    F93.1
1314:  BTFSS  F81.1
1316:  BRA    1314
1318:  MOVLW  04
131A:  MOVWF  00
131C:  DECFSZ 00,F
131E:  BRA    131C
1320:  BRA    1322
1322:  NOP   
1324:  BSF    F93.0
1326:  MOVLW  04
1328:  MOVWF  00
132A:  DECFSZ 00,F
132C:  BRA    132A
*
2B2C:  BCF    F93.0
2B2E:  NOP   
2B30:  BSF    F93.1
2B32:  BTFSS  F81.1
2B34:  BRA    2B32
2B36:  MOVLW  04
2B38:  MOVWF  00
2B3A:  DECFSZ 00,F
2B3C:  BRA    2B3A
2B3E:  BRA    2B40
2B40:  NOP   
2B42:  BSF    F93.0
2B44:  MOVLW  04
2B46:  MOVWF  00
2B48:  DECFSZ 00,F
2B4A:  BRA    2B48
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
132E:  BSF    F93.0
1330:  MOVLW  04
1332:  MOVWF  00
1334:  DECFSZ 00,F
1336:  BRA    1334
1338:  BSF    F93.1
133A:  MOVLW  04
133C:  MOVWF  00
133E:  DECFSZ 00,F
1340:  BRA    133E
1342:  BCF    F8A.0
1344:  BCF    F93.0
1346:  MOVLW  04
1348:  MOVWF  00
134A:  DECFSZ 00,F
134C:  BRA    134A
134E:  BCF    F8A.1
1350:  BCF    F93.1
*
2B4C:  BSF    F93.0
2B4E:  MOVLW  04
2B50:  MOVWF  00
2B52:  DECFSZ 00,F
2B54:  BRA    2B52
2B56:  BSF    F93.1
2B58:  MOVLW  04
2B5A:  MOVWF  00
2B5C:  DECFSZ 00,F
2B5E:  BRA    2B5C
2B60:  BCF    F8A.0
2B62:  BCF    F93.0
2B64:  MOVLW  04
2B66:  MOVWF  00
2B68:  DECFSZ 00,F
2B6A:  BRA    2B68
2B6C:  BCF    F8A.1
2B6E:  BCF    F93.1
....................   i2c_write(0xD0); 
*
1352:  MOVLW  D0
1354:  MOVLB  1
1356:  MOVWF  xF0
1358:  MOVLB  0
135A:  RCALL  1140
*
2B70:  MOVLW  D0
2B72:  MOVLB  1
2B74:  MOVWF  xF0
2B76:  MOVLB  0
2B78:  CALL   1140
....................   i2c_write(0x00); 
*
135C:  MOVLB  1
135E:  CLRF   xF0
1360:  MOVLB  0
1362:  RCALL  1140
*
2B7C:  MOVLB  1
2B7E:  CLRF   xF0
2B80:  MOVLB  0
2B82:  CALL   1140
....................   i2c_start(); 
*
1364:  BSF    F93.0
1366:  MOVLW  04
1368:  MOVWF  00
136A:  DECFSZ 00,F
136C:  BRA    136A
136E:  BSF    F93.1
1370:  MOVLW  04
1372:  MOVWF  00
1374:  DECFSZ 00,F
1376:  BRA    1374
1378:  BTFSS  F81.1
137A:  BRA    1378
137C:  BCF    F8A.0
137E:  BCF    F93.0
1380:  MOVLW  04
1382:  MOVWF  00
1384:  DECFSZ 00,F
1386:  BRA    1384
1388:  BCF    F8A.1
138A:  BCF    F93.1
*
2B86:  BSF    F93.0
2B88:  MOVLW  04
2B8A:  MOVWF  00
2B8C:  DECFSZ 00,F
2B8E:  BRA    2B8C
2B90:  BSF    F93.1
2B92:  MOVLW  04
2B94:  MOVWF  00
2B96:  DECFSZ 00,F
2B98:  BRA    2B96
2B9A:  BTFSS  F81.1
2B9C:  BRA    2B9A
2B9E:  BCF    F8A.0
2BA0:  BCF    F93.0
2BA2:  MOVLW  04
2BA4:  MOVWF  00
2BA6:  DECFSZ 00,F
2BA8:  BRA    2BA6
2BAA:  BCF    F8A.1
2BAC:  BCF    F93.1
....................   i2c_write(0xD1); 
*
138C:  MOVLW  D1
138E:  MOVLB  1
1390:  MOVWF  xF0
1392:  MOVLB  0
1394:  RCALL  1140
*
2BAE:  MOVLW  D1
2BB0:  MOVLB  1
2BB2:  MOVWF  xF0
2BB4:  MOVLB  0
2BB6:  CALL   1140
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1396:  MOVLW  01
1398:  MOVWF  00
139A:  RCALL  11B6
139C:  MOVF   01,W
139E:  ANDLW  7F
13A0:  MOVLB  1
13A2:  MOVWF  xEC
13A4:  MOVWF  xF1
13A6:  MOVLB  0
13A8:  RCALL  1220
13AA:  MOVFF  01,E4
*
2BBA:  MOVLW  01
2BBC:  MOVWF  00
2BBE:  CALL   11B6
2BC2:  MOVF   01,W
2BC4:  ANDLW  7F
2BC6:  MOVLB  1
2BC8:  MOVWF  xEC
2BCA:  MOVWF  xF1
2BCC:  MOVLB  0
2BCE:  CALL   1220
2BD2:  MOVFF  01,E4
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
13AE:  MOVLW  01
13B0:  MOVWF  00
13B2:  RCALL  11B6
13B4:  MOVF   01,W
13B6:  ANDLW  7F
13B8:  MOVLB  1
13BA:  MOVWF  xEC
13BC:  MOVWF  xF1
13BE:  MOVLB  0
13C0:  RCALL  1220
13C2:  MOVFF  01,E3
*
2BD6:  MOVLW  01
2BD8:  MOVWF  00
2BDA:  CALL   11B6
2BDE:  MOVF   01,W
2BE0:  ANDLW  7F
2BE2:  MOVLB  1
2BE4:  MOVWF  xEC
2BE6:  MOVWF  xF1
2BE8:  MOVLB  0
2BEA:  CALL   1220
2BEE:  MOVFF  01,E3
....................   hr = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
13C6:  CLRF   00
13C8:  RCALL  11B6
13CA:  MOVF   01,W
13CC:  ANDLW  3F
13CE:  MOVLB  1
13D0:  MOVWF  xEC
13D2:  MOVWF  xF1
13D4:  MOVLB  0
13D6:  RCALL  1220
13D8:  MOVFF  01,E2
*
2BF2:  CLRF   00
2BF4:  CALL   11B6
2BF8:  MOVF   01,W
2BFA:  ANDLW  3F
2BFC:  MOVLB  1
2BFE:  MOVWF  xEC
2C00:  MOVWF  xF1
2C02:  MOVLB  0
2C04:  CALL   1220
2C08:  MOVFF  01,E2
....................   i2c_stop(); 
*
13DC:  BCF    F93.0
13DE:  NOP   
13E0:  BSF    F93.1
13E2:  BTFSS  F81.1
13E4:  BRA    13E2
13E6:  MOVLW  04
13E8:  MOVWF  00
13EA:  DECFSZ 00,F
13EC:  BRA    13EA
13EE:  BRA    13F0
13F0:  NOP   
13F2:  BSF    F93.0
13F4:  MOVLW  04
13F6:  MOVWF  00
13F8:  DECFSZ 00,F
13FA:  BRA    13F8
*
2C0C:  BCF    F93.0
2C0E:  NOP   
2C10:  BSF    F93.1
2C12:  BTFSS  F81.1
2C14:  BRA    2C12
2C16:  MOVLW  04
2C18:  MOVWF  00
2C1A:  DECFSZ 00,F
2C1C:  BRA    2C1A
2C1E:  BRA    2C20
2C20:  NOP   
2C22:  BSF    F93.0
2C24:  MOVLW  04
2C26:  MOVWF  00
2C28:  DECFSZ 00,F
2C2A:  BRA    2C28
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................   char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
2660:  BSF    F93.0
2662:  MOVLW  04
2664:  MOVWF  00
2666:  DECFSZ 00,F
2668:  BRA    2666
266A:  BSF    F93.1
266C:  MOVLW  04
266E:  MOVWF  00
2670:  DECFSZ 00,F
2672:  BRA    2670
2674:  BCF    F8A.0
2676:  BCF    F93.0
2678:  MOVLW  04
267A:  MOVWF  00
267C:  DECFSZ 00,F
267E:  BRA    267C
2680:  BCF    F8A.1
2682:  BCF    F93.1
....................   i2c_write(0xD0); 
2684:  MOVLW  D0
2686:  MOVLB  1
2688:  MOVWF  xF0
268A:  MOVLB  0
268C:  CALL   1140
....................   i2c_write(addr); 
2690:  MOVFF  1D2,1F0
2694:  CALL   1140
....................  
....................   i2c_start(); 
2698:  BSF    F93.0
269A:  MOVLW  04
269C:  MOVWF  00
269E:  DECFSZ 00,F
26A0:  BRA    269E
26A2:  BSF    F93.1
26A4:  MOVLW  04
26A6:  MOVWF  00
26A8:  DECFSZ 00,F
26AA:  BRA    26A8
26AC:  BTFSS  F81.1
26AE:  BRA    26AC
26B0:  BCF    F8A.0
26B2:  BCF    F93.0
26B4:  MOVLW  04
26B6:  MOVWF  00
26B8:  DECFSZ 00,F
26BA:  BRA    26B8
26BC:  BCF    F8A.1
26BE:  BCF    F93.1
....................   i2c_write(0xD1); 
26C0:  MOVLW  D1
26C2:  MOVLB  1
26C4:  MOVWF  xF0
26C6:  MOVLB  0
26C8:  CALL   1140
....................   retval = i2c_read(0); 
26CC:  CLRF   00
26CE:  CALL   11B6
26D2:  MOVFF  01,1D3
....................   i2c_stop(); 
26D6:  BCF    F93.0
26D8:  NOP   
26DA:  BSF    F93.1
26DC:  BTFSS  F81.1
26DE:  BRA    26DC
26E0:  MOVLW  04
26E2:  MOVWF  00
26E4:  DECFSZ 00,F
26E6:  BRA    26E4
26E8:  BRA    26EA
26EA:  NOP   
26EC:  BSF    F93.0
26EE:  MOVLW  04
26F0:  MOVWF  00
26F2:  DECFSZ 00,F
26F4:  BRA    26F2
....................  
.................... return(retval); 
26F6:  MOVLB  1
26F8:  MOVFF  1D3,01
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
26FC:  MOVLB  0
26FE:  RETLW  00
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................   disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
*
292C:  BSF    F93.0
292E:  MOVLW  04
2930:  MOVWF  00
2932:  DECFSZ 00,F
2934:  BRA    2932
2936:  BSF    F93.1
2938:  MOVLW  04
293A:  MOVWF  00
293C:  DECFSZ 00,F
293E:  BRA    293C
2940:  BCF    F8A.0
2942:  BCF    F93.0
2944:  MOVLW  04
2946:  MOVWF  00
2948:  DECFSZ 00,F
294A:  BRA    2948
294C:  BCF    F8A.1
294E:  BCF    F93.1
....................   i2c_write(0xD0); 
2950:  MOVLW  D0
2952:  MOVLB  1
2954:  MOVWF  xF0
2956:  MOVLB  0
2958:  CALL   1140
....................   i2c_write(addr); 
295C:  MOVFF  1D2,1F0
2960:  CALL   1140
....................   i2c_write(value); 
2964:  MOVFF  1D3,1F0
2968:  CALL   1140
....................   i2c_stop(); 
296C:  BCF    F93.0
296E:  NOP   
2970:  BSF    F93.1
2972:  BTFSS  F81.1
2974:  BRA    2972
2976:  MOVLW  04
2978:  MOVWF  00
297A:  DECFSZ 00,F
297C:  BRA    297A
297E:  BRA    2980
2980:  NOP   
2982:  BSF    F93.0
2984:  MOVLW  04
2986:  MOVWF  00
2988:  DECFSZ 00,F
298A:  BRA    2988
....................  
.................... #ifndef USE_INTERRUPTS 
....................   enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
298C:  RETLW  00
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................   byte lday; 
....................   byte lmonth; 
....................   byte lyr; 
....................   byte ldow; 
....................   ds1307_get_date(lday,lmonth,lyr,ldow); 
....................   sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
24CE:  MOVFF  1D9,1DA
....................   retval = 0; 
24D2:  MOVLB  1
24D4:  CLRF   xDB
....................   while(1){ 
....................     if(temp >= 10){ 
24D6:  MOVF   xDA,W
24D8:  SUBLW  09
24DA:  BC    24E6
....................       temp -= 10; 
24DC:  MOVLW  0A
24DE:  SUBWF  xDA,F
....................       retval += 0x10; 
24E0:  MOVLW  10
24E2:  ADDWF  xDB,F
....................     }else{ 
24E4:  BRA    24EC
....................       retval += temp; 
24E6:  MOVF   xDA,W
24E8:  ADDWF  xDB,F
....................       break; 
24EA:  BRA    24EE
....................     } 
....................   } 
24EC:  BRA    24D6
....................   return(retval); 
24EE:  MOVFF  1DB,01
.................... } 
24F2:  MOVLB  0
24F4:  RETLW  00
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
1220:  MOVFF  1F1,1F2
....................   temp >>= 1; 
1224:  BCF    FD8.0
1226:  MOVLB  1
1228:  RRCF   xF2,F
....................   temp &= 0x78; 
122A:  MOVLW  78
122C:  ANDWF  xF2,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
122E:  RRCF   xF2,W
1230:  MOVWF  00
1232:  RRCF   00,F
1234:  MOVLW  3F
1236:  ANDWF  00,F
1238:  MOVF   00,W
123A:  ADDWF  xF2,W
123C:  MOVWF  xF3
123E:  MOVF   xF1,W
1240:  ANDLW  0F
1242:  ADDWF  xF3,W
1244:  MOVWF  01
.................... } 
1246:  MOVLB  0
1248:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... //#use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
.................... /* 
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x03); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
....................   year = ds1307_bcd2bin(i2c_read(0)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
....................   temp >>= 1; 
....................   temp &= 0x78; 
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... } 
.................... */ 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "captura_frecuencia.c" 
.................... #ifdef CAPTURA_FRECUENCIA_H 
.................... //#include "captura_frecuencia.h" 
.................... /* 
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #endif 
.................... */ 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
2182:  INCF   x8C,F
.................... } 
....................  
2184:  BCF    FA1.1
2186:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
218A:  MOVF   x8B,W
218C:  SUBLW  FF
218E:  BNZ   21A0
....................    	setup_ccp1(CCP_CAPTURE_FE); 
2190:  BSF    F94.2
2192:  CLRF   FBD
2194:  MOVLW  04
2196:  MOVWF  FBD
2198:  CLRF   FB7
219A:  CLRF   FB6
....................    	Q_CCP = 0; 
219C:  CLRF   x8B
....................    }else if(Q_CCP == 0){ 
219E:  BRA    2228
21A0:  MOVF   x8B,F
21A2:  BNZ   21DC
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
21A4:  CLRF   01
21A6:  MOVFF  8C,2AA
21AA:  MOVLB  2
21AC:  CLRF   xA8
21AE:  CLRF   xA9
21B0:  MOVF   FBE,W
21B2:  ADDWF  xA8,W
21B4:  MOVLB  0
21B6:  MOVWF  x91
21B8:  MOVF   FBF,W
21BA:  MOVLB  2
21BC:  ADDWFC xA9,W
21BE:  MOVLB  0
21C0:  MOVWF  x92
21C2:  MOVLW  00
21C4:  MOVLB  2
21C6:  ADDWFC xAA,W
21C8:  MOVLB  0
21CA:  MOVWF  x93
21CC:  MOVLW  00
21CE:  MOVLB  2
21D0:  ADDWFC 01,W
21D2:  MOVLB  0
21D4:  MOVWF  x94
....................    	Q_CCP = 1; 
21D6:  MOVLW  01
21D8:  MOVWF  x8B
....................    }else if(Q_CCP == 1){ 
21DA:  BRA    2228
21DC:  DECFSZ x8B,W
21DE:  BRA    2228
....................    	disable_interrupts(INT_CCP1); 
21E0:  BCF    F9D.2
....................    	tiempo_inicial = tiempo_final; 
21E2:  MOVFF  94,90
21E6:  MOVFF  93,8F
21EA:  MOVFF  92,8E
21EE:  MOVFF  91,8D
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
21F2:  CLRF   01
21F4:  MOVFF  8C,2AA
21F8:  MOVLB  2
21FA:  CLRF   xA8
21FC:  CLRF   xA9
21FE:  MOVF   FBE,W
2200:  ADDWF  xA8,W
2202:  MOVLB  0
2204:  MOVWF  x91
2206:  MOVF   FBF,W
2208:  MOVLB  2
220A:  ADDWFC xA9,W
220C:  MOVLB  0
220E:  MOVWF  x92
2210:  MOVLW  00
2212:  MOVLB  2
2214:  ADDWFC xAA,W
2216:  MOVLB  0
2218:  MOVWF  x93
221A:  MOVLW  00
221C:  MOVLB  2
221E:  ADDWFC 01,W
2220:  MOVLB  0
2222:  MOVWF  x94
....................    	Q_CCP = 2; 
2224:  MOVLW  02
2226:  MOVWF  x8B
....................    } 
.................... } 
....................  
2228:  BCF    F9E.2
222A:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    if(Q_CCP == -1){ 
222E:  MOVF   x8B,W
2230:  SUBLW  FF
2232:  BNZ   2244
....................    	setup_ccp1(CCP_CAPTURE_FE); 
2234:  BSF    F94.2
2236:  CLRF   FBD
2238:  MOVLW  04
223A:  MOVWF  FBD
223C:  CLRF   FB7
223E:  CLRF   FB6
....................    	Q_CCP = 0; 
2240:  CLRF   x8B
....................    }else if(Q_CCP == 0){ 
2242:  BRA    22CC
2244:  MOVF   x8B,F
2246:  BNZ   2280
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
2248:  CLRF   01
224A:  MOVFF  8C,2AA
224E:  MOVLB  2
2250:  CLRF   xA8
2252:  CLRF   xA9
2254:  MOVF   FBB,W
2256:  ADDWF  xA8,W
2258:  MOVLB  0
225A:  MOVWF  x91
225C:  MOVF   FBC,W
225E:  MOVLB  2
2260:  ADDWFC xA9,W
2262:  MOVLB  0
2264:  MOVWF  x92
2266:  MOVLW  00
2268:  MOVLB  2
226A:  ADDWFC xAA,W
226C:  MOVLB  0
226E:  MOVWF  x93
2270:  MOVLW  00
2272:  MOVLB  2
2274:  ADDWFC 01,W
2276:  MOVLB  0
2278:  MOVWF  x94
....................    	Q_CCP = 1; 
227A:  MOVLW  01
227C:  MOVWF  x8B
....................    }else if(Q_CCP == 1){ 
227E:  BRA    22CC
2280:  DECFSZ x8B,W
2282:  BRA    22CC
....................    	disable_interrupts(INT_CCP2); 
2284:  BCF    FA0.0
....................    	tiempo_inicial = tiempo_final; 
2286:  MOVFF  94,90
228A:  MOVFF  93,8F
228E:  MOVFF  92,8E
2292:  MOVFF  91,8D
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
2296:  CLRF   01
2298:  MOVFF  8C,2AA
229C:  MOVLB  2
229E:  CLRF   xA8
22A0:  CLRF   xA9
22A2:  MOVF   FBB,W
22A4:  ADDWF  xA8,W
22A6:  MOVLB  0
22A8:  MOVWF  x91
22AA:  MOVF   FBC,W
22AC:  MOVLB  2
22AE:  ADDWFC xA9,W
22B0:  MOVLB  0
22B2:  MOVWF  x92
22B4:  MOVLW  00
22B6:  MOVLB  2
22B8:  ADDWFC xAA,W
22BA:  MOVLB  0
22BC:  MOVWF  x93
22BE:  MOVLW  00
22C0:  MOVLB  2
22C2:  ADDWFC 01,W
22C4:  MOVLB  0
22C6:  MOVWF  x94
....................    	Q_CCP = 2; 
22C8:  MOVLW  02
22CA:  MOVWF  x8B
....................    } 
.................... } 
....................  
22CC:  BCF    FA1.0
22CE:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
*
2498:  MOVFF  88,FB1
....................    T3CON.TMR3ON = 0; 
249C:  BCF    FB1.0
....................    set_timer3(0); 
249E:  CLRF   FB3
24A0:  CLRF   FB2
....................    setup_ccp1(MODO_CCP1); 
24A2:  MOVF   x89,W
24A4:  ANDLW  08
24A6:  BTFSC  FD8.2
24A8:  BCF    F82.2
24AA:  CLRF   FBD
24AC:  MOVFF  89,FBD
24B0:  CLRF   FB7
24B2:  CLRF   FB6
....................    setup_ccp2(MODO_CCP2); 
24B4:  MOVF   x8A,W
24B6:  ANDLW  08
24B8:  BTFSC  FD8.2
24BA:  BCF    F82.1
24BC:  CLRF   FBA
24BE:  MOVFF  8A,FBA
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1;                        
24C2:  BSF    F94.2
24C4:  BSF    F94.1
....................    return 0; 
24C6:  MOVLW  00
24C8:  MOVWF  01
.................... } 
24CA:  GOTO   271C (RETURN)
....................  
.................... void CP_activar_captura(int canal){ 
.................... 	//CODIGO DE MANEJO DE CCP 
.................... 	semaforo_ccp = 1; 
*
2034:  MOVLW  01
2036:  MOVWF  x95
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
2038:  MOVLW  C0
203A:  IORWF  FF2,F
....................    enable_interrupts(INT_TIMER3); 
203C:  BSF    FA0.1
....................    tiempo_inicial = tiempo_final = 0; 
203E:  CLRF   x94
2040:  CLRF   x93
2042:  CLRF   x92
2044:  CLRF   x91
2046:  MOVFF  94,90
204A:  MOVFF  93,8F
204E:  MOVFF  92,8E
2052:  MOVFF  91,8D
....................    set_timer3(0);      						//se reset timer  a 0 
2056:  CLRF   FB3
2058:  CLRF   FB2
....................    T3CON.TMR3ON = 1; 
205A:  BSF    FB1.0
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
205C:  MOVLB  2
205E:  DECFSZ x8A,W
2060:  BRA    2066
2062:  BSF    F9D.2
2064:  BRA    2068
2066:  BSF    FA0.0
.................... } 
2068:  MOVLB  0
206A:  GOTO   2146 (RETURN)
....................  
.................... void CP_desativar_captura(){ 
.................... 	disable_interrupts(INT_CCP1); 
*
209C:  BCF    F9D.2
....................    disable_interrupts(INT_CCP2); 
209E:  BCF    FA0.0
....................    disable_interrupts(INT_TIMER3); 
20A0:  BCF    FA0.1
....................    //disable_interrupts(GLOBAL); 
....................    setup_ccp2(MODO_CCP1); 
20A2:  MOVF   x89,W
20A4:  ANDLW  08
20A6:  BTFSC  FD8.2
20A8:  BCF    F82.1
20AA:  CLRF   FBA
20AC:  MOVFF  89,FBA
....................    setup_ccp2(MODO_CCP2); 
20B0:  MOVF   x8A,W
20B2:  ANDLW  08
20B4:  BTFSC  FD8.2
20B6:  BCF    F82.1
20B8:  CLRF   FBA
20BA:  MOVFF  8A,FBA
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
20BE:  MOVLW  FF
20C0:  MOVWF  x8B
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
20C2:  BCF    FB1.0
....................    overflow_t3_counter = 0; 
20C4:  CLRF   x8C
....................    semaforo_ccp = 0; 
20C6:  CLRF   x95
.................... } 
20C8:  GOTO   2162 (RETURN)
....................  
.................... int CP_ocupado(){ return (semaforo_ccp != 0);} 
*
200E:  MOVF   x95,F
2010:  BNZ   2016
2012:  MOVLW  00
2014:  BRA    2018
2016:  MOVLW  01
2018:  MOVWF  01
201A:  GOTO   2102 (RETURN)
.................... int CP_done(){ return (Q_CCP == 2);} 
*
206E:  MOVF   x8B,W
2070:  SUBLW  02
2072:  BZ    2078
2074:  MOVLW  00
2076:  BRA    207A
2078:  MOVLW  01
207A:  MOVWF  01
207C:  GOTO   2148 (RETURN)
....................  
.................... int32 CP_obtener_resultado(){ 
.................... 	return (tiempo_final - tiempo_inicial); 
2080:  MOVF   x8D,W
2082:  SUBWF  x91,W
2084:  MOVWF  00
2086:  MOVF   x8E,W
2088:  SUBWFB x92,W
208A:  MOVWF  01
208C:  MOVF   x8F,W
208E:  SUBWFB x93,W
2090:  MOVWF  02
2092:  MOVF   x90,W
2094:  SUBWFB x94,W
2096:  MOVWF  03
.................... } 
2098:  GOTO   2150 (RETURN)
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    set_timer3(0);      					//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    (canal == CCP_CANAL_1)? enable_interrupts(INT_CCP1) : enable_interrupts(INT_CCP2); 
....................    //while(Q_CCP != 2){;}              //espera a que se carguen los valores de los tiempos 
....................    disable_interrupts(INT_CCP1); 
....................    disable_interrupts(INT_CCP2); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    //resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    *buffer = tiempo_final - tiempo_inicial; 
....................    return (0); 
.................... } 
.................... #endif 
....................  
.................... #include "memoria.c" 
.................... //#include "Nucleo.h" 
.................... #ifdef MEMORIA_H 
....................  
.................... //#include "memoria.h" 
.................... #include "comunicacion.h" 
.................... #ifndef COMUNICACION_H 
.................... #define COMUNICACION_H 
.................... #define USB_CON_SENSE_PIN PIN_D3 
.................... #include "usb_desc_cdc.h" 
.................... #include <usb_cdc.h> 
....................  
.................... #define USB_OK	1 
.................... #define USB_NO_ENUMERATED 0 
.................... #define USB_NO_ATTACHED -1 
....................  
.................... int8 COM_init(); 
.................... int8 COM_sense(); 
.................... int8 COM_send(char* buffer, unsigned int8 leng, unsigned short wait = 1); 
.................... int8 COM_send(char* buffer, unsigned int8 leng); 
.................... int8 COM_recive(char* buffer, unsigned int8 leng); 
.................... void COM_printf(char* message); 
.................... /* 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
.................... */ 
.................... #define COM_READY (COM_sense() == USB_OK) 
.................... #endif 
....................  
....................  
.................... //borrar para quitar el debug de memoria 
.................... #define debug_memoria 1	 
....................  
.................... // #define MEM_RX PIN_D7 
.................... // #define MEM_TX PIN_D6	 
.................... #define MEMORIA_PIN_RESET PIN_D5 
.................... #use rs232(uart1, stream=MEMORIA, BAUD=9600, TIMEOUT=1000) 
*
17EE:  BTFSS  F9E.4
17F0:  BRA    17EE
17F2:  MOVWF  FAD
17F4:  GOTO   182C (RETURN)
*
1872:  MOVLW  0C
1874:  MOVLB  2
1876:  MOVWF  x92
1878:  MOVLW  85
187A:  MOVWF  x91
187C:  MOVLW  02
187E:  MOVWF  x93
1880:  MOVLW  9B
1882:  MOVWF  x94
1884:  MOVLB  0
1886:  BRA    1850
1888:  MOVLB  2
188A:  DECFSZ x93,F
188C:  BRA    1880
188E:  DECFSZ x91,F
1890:  BRA    18A0
1892:  DECFSZ x92,F
1894:  BRA    18A0
1896:  MOVLB  1
1898:  CLRF   xB5
189A:  CLRF   01
189C:  BRA    18B6
189E:  MOVLB  2
18A0:  BTFSS  F9E.5
18A2:  BRA    187C
18A4:  MOVF   FAB,W
18A6:  MOVLB  1
18A8:  MOVWF  xB5
18AA:  MOVF   FAE,W
18AC:  MOVWF  01
18AE:  BTFSS  xB5.1
18B0:  BRA    18B6
18B2:  BCF    FAB.4
18B4:  BSF    FAB.4
18B6:  MOVLB  0
18B8:  RETLW  00
.................... #define time_delay 1000 
....................  
.................... short MEMORIA_OK = FALSE; 
.................... short MEMORIA_HW = FALSE; 
.................... short timeout_error = FALSE; 
.................... short read_flag = 0; //utilizada por un bug en la lectura de archivos desde dispositivo de memoria 
.................... int8 MEM_proceso = INI_HW; 
.................... unsigned int i = 0; 
.................... unsigned int car = 0; 
.................... unsigned int32 tamano = 0; 
.................... char MEM_info[5] = {0x00,0x00,0x00,0x00,0x00}; 
.................... char MEM_file_name[MEMORIA_NAME_LENG_LIMIT]; 
.................... char MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
.................... char MEM_append = MEMORIA_APPEND; 
.................... //char MEM_performance = MEMORIA_HIGH_PERFORMANCE;	//cambiar a low performance 
.................... char MEM_performance = MEMORIA_LOW_PERFORMANCE; 
.................... char MEM_RESPONSE = MEMORIA_NOACK; 
....................  
.................... #ifdef debug_memoria 
.................... void update_proceso(int8 proceso){ 
.................... 	MEM_proceso = proceso; 
*
168A:  MOVFF  28F,1B6
.................... 	printf(usb_cdc_putc_fast,"\n\rMp>%d", MEM_proceso); 
168E:  MOVLW  D2
1690:  MOVWF  FF6
1692:  MOVLW  22
1694:  MOVWF  FF7
1696:  MOVLW  05
1698:  MOVLB  2
169A:  MOVWF  x90
169C:  MOVLB  0
169E:  RCALL  1558
16A0:  MOVFF  1B6,290
16A4:  MOVLW  1F
16A6:  MOVLB  2
16A8:  MOVWF  x91
16AA:  MOVLB  0
16AC:  RCALL  15AC
.................... 	return; 
.................... } 
16AE:  RETLW  00
.................... #endif 
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL INICIO DEL MODULO DE MEMORIA 
.................... 	====================================== 
.................... */ 
.................... /*==================== reset de memoria ======================*/ 
.................... int MEMORIA_reset(void){ 
.................... 	#ifdef debug_memoria 
.................... 	usb_cdc_putc_fast('r'); 
*
2356:  MOVLW  72
2358:  MOVLB  2
235A:  MOVWF  x96
235C:  MOVLB  0
235E:  CALL   14FC
.................... 	#endif 
.................... 	output_float(PIN_D6); 
2362:  BSF    F95.6
....................    output_low(MEMORIA_PIN_RESET); 
2364:  BCF    F95.5
2366:  BCF    F8C.5
....................    delay_ms(1000); 
2368:  MOVLW  04
236A:  MOVLB  1
236C:  MOVWF  xD2
236E:  MOVLW  FA
2370:  MOVWF  xD3
2372:  MOVLB  0
2374:  RCALL  232C
2376:  MOVLB  1
2378:  DECFSZ xD2,F
237A:  BRA    236E
....................    read_flag = 0; 
237C:  MOVLB  0
237E:  BCF    x83.5
....................    output_high(MEMORIA_PIN_RESET); 
2380:  BCF    F95.5
2382:  BSF    F8C.5
....................    delay_ms(3000); 
2384:  MOVLW  0C
2386:  MOVLB  1
2388:  MOVWF  xD2
238A:  MOVLW  FA
238C:  MOVWF  xD3
238E:  MOVLB  0
2390:  RCALL  232C
2392:  MOVLB  1
2394:  DECFSZ xD2,F
2396:  BRA    238A
....................    return(0); 
2398:  MOVLW  00
239A:  MOVWF  01
.................... } 
239C:  MOVLB  0
239E:  GOTO   2708 (RETURN)
....................  
.................... /*==================== autobaudrate ======================*/ 
.................... int MEMORIA_init_hw(void){ 
23A2:  MOVLW  0A
23A4:  MOVLB  1
23A6:  MOVWF  xD2
.................... 	int8 envios = 10; 
.................... 	#ifdef debug_memoria 
.................... 	update_proceso(INI_HW); 
23A8:  MOVLB  2
23AA:  CLRF   x8F
23AC:  MOVLB  0
23AE:  CALL   168A
.................... 	#else 
.................... 	MEM_proceso = INI_HW; 
.................... 	#endif 
.................... 	 
.................... 	do{ 
.................... 		MEMORIA_putc(MEMORIA_CMD_AUTOBAUD); 
23B2:  MOVLW  55
23B4:  MOVLB  2
23B6:  MOVWF  x90
23B8:  MOVLB  0
23BA:  CALL   17F8
.................... 		MEM_RESPONSE = MEMORIA_getc(); 
23BE:  CALL   18BA
23C2:  MOVFF  01,1D1
.................... 		envios --; 
23C6:  MOVLB  1
23C8:  DECF   xD2,F
.................... 		delay_ms(200); 
23CA:  MOVLW  C8
23CC:  MOVWF  xD3
23CE:  MOVLB  0
23D0:  RCALL  232C
.................... 	}while((envios > 0) && (MEM_RESPONSE != MEMORIA_ACK) );                                                        
23D2:  MOVLB  1
23D4:  MOVF   xD2,F
23D6:  BZ    23E4
23D8:  MOVF   xD1,W
23DA:  SUBLW  06
23DC:  BTFSC  FD8.2
23DE:  BRA    23E4
23E0:  MOVLB  0
23E2:  BRA    23B2
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){                                 
23E4:  MOVF   xD1,W
23E6:  SUBLW  06
23E8:  BZ    23F0
.................... 		return (1); 
23EA:  MOVLW  01
23EC:  MOVWF  01
23EE:  BRA    240A
.................... 	} 
....................     
....................    MEMORIA_HW = TRUE; 
23F0:  MOVLB  0
23F2:  BSF    x83.3
....................    MEMORIA_OK = FALSE; 
23F4:  BCF    x83.2
....................    read_flag = 0; 
23F6:  BCF    x83.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(INI_SW); 
23F8:  MOVLW  01
23FA:  MOVLB  2
23FC:  MOVWF  x8F
23FE:  MOVLB  0
2400:  CALL   168A
.................... 	#else 
.................... 	MEM_proceso = INI_SW; 
.................... 	#endif 
.................... 	 
....................    return (0); 
2404:  MOVLW  00
2406:  MOVWF  01
2408:  MOVLB  1
.................... } 
240A:  MOVLB  0
240C:  GOTO   270A (RETURN)
....................  
.................... /*==================== iniciar memoria ======================*/ 
.................... int MEMORIA_init(void){ 
....................  
....................    if(!MEMORIA_HW || (MEM_proceso != INI_SW)) return (1); 
2410:  BTFSS  x83.3
2412:  BRA    2424
2414:  MOVLB  1
2416:  DECFSZ xB6,W
2418:  BRA    241C
241A:  BRA    2420
241C:  MOVLB  0
241E:  BRA    2424
2420:  BRA    242A
2422:  MOVLB  0
2424:  MOVLW  01
2426:  MOVWF  01
2428:  BRA    2472
.................... 	 
.................... 	MEMORIA_putc(MEMORIA_EXT_CMD); 
242A:  MOVLW  40
242C:  MOVLB  2
242E:  MOVWF  x90
2430:  MOVLB  0
2432:  CALL   17F8
....................    MEMORIA_putc(MEMORIA_CMD_INITIALIZE); 
2436:  MOVLW  69
2438:  MOVLB  2
243A:  MOVWF  x90
243C:  MOVLB  0
243E:  CALL   17F8
....................     
....................    MEM_RESPONSE = MEMORIA_getc(); 
2442:  CALL   18BA
2446:  MOVFF  01,1D1
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK) return(2); 
244A:  MOVLB  1
244C:  MOVF   xD1,W
244E:  SUBLW  06
2450:  BZ    245C
2452:  MOVLW  02
2454:  MOVWF  01
2456:  MOVLB  0
2458:  BRA    2472
....................    else MEMORIA_OK = TRUE; 
245A:  BRA    2460
245C:  MOVLB  0
245E:  BSF    x83.2
....................     
....................    read_flag = 0; 
2460:  BCF    x83.5
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
2462:  MOVLW  02
2464:  MOVLB  2
2466:  MOVWF  x8F
2468:  MOVLB  0
246A:  CALL   168A
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return (0); 
246E:  MOVLW  00
2470:  MOVWF  01
.................... } 
2472:  GOTO   2710 (RETURN)
....................  
.................... /*====================get info======================*/ 
.................... void MEMORIA_getinfo(){ 
....................  
.................... 	MEMORIA_putc(MEMORIA_CMD_VER_INFO); 
....................    MEM_info[0] = MEMORIA_getc(); 
....................    MEM_info[1] = MEMORIA_getc(); 
....................    MEM_info[2] = MEMORIA_getc(); 
....................    MEM_info[3] = MEMORIA_getc(); 
....................    MEM_info[4] = MEMORIA_getc(); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\rMemInf: %x %x %x %x %x", MEM_info[0],MEM_info[1],MEM_info[2],MEM_info[3],MEM_info[4]); 
....................    #endif 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... /*	====================================== 
.................... 	FUNCIONES PARA EL MANEJO DE ARCHIVOS 
.................... 	====================================== 
.................... */ 
....................  
.................... /*====================abrir archivo======================*/ 
....................  
.................... int MEMORIA_open(char* filename, short modo){ 
....................  
....................    if(!MEMORIA_OK) return(1); 
*
1730:  BTFSC  x83.2
1732:  BRA    173A
1734:  MOVLW  01
1736:  MOVWF  01
1738:  BRA    17A2
....................  
....................    if(modo){ 
173A:  MOVLB  2
173C:  MOVF   x8E,F
173E:  BZ    174C
....................       #ifdef debug_memoria 
.................... 		update_proceso(WR); 
1740:  MOVLW  05
1742:  MOVWF  x8F
1744:  MOVLB  0
1746:  RCALL  168A
.................... 		#else 
.................... 		MEM_proceso = WR; 
.................... 		#endif 
....................    }else{ 
1748:  BRA    1754
174A:  MOVLB  2
.................... 		#ifdef debug_memoria 
.................... 		update_proceso(RD); 
174C:  MOVLW  03
174E:  MOVWF  x8F
1750:  MOVLB  0
1752:  RCALL  168A
.................... 		#else 
.................... 		MEM_proceso = RD; 
.................... 		#endif 
....................    } 
....................     
....................    car = strlen(filename); 
1754:  MOVFF  28D,290
1758:  MOVFF  28C,28F
175C:  RCALL  14C2
175E:  MOVFF  01,1B8
....................    car = (car <= MEMORIA_NAME_LENG_LIMIT)? car : MEMORIA_NAME_LENG_LIMIT;  
1762:  MOVLB  1
1764:  MOVF   xB8,W
1766:  SUBLW  0C
1768:  BNC   176E
176A:  MOVF   xB8,W
176C:  BRA    1770
176E:  MOVLW  0C
1770:  MOVWF  xB8
....................    strncpy(MEM_file_name, filename, car); 
1772:  MOVLW  01
1774:  MOVLB  2
1776:  MOVWF  x90
1778:  MOVLW  C2
177A:  MOVWF  x8F
177C:  MOVFF  28D,292
1780:  MOVFF  28C,291
1784:  MOVFF  1B8,293
1788:  MOVLB  0
178A:  BRA    16B0
....................     
....................    i = 0; 
178C:  MOVLB  1
178E:  CLRF   xB7
....................    timeout_error = FALSE; 
1790:  MOVLB  0
1792:  BCF    x83.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
1794:  MOVLW  01
1796:  MOVLB  1
1798:  MOVWF  xCE
....................    MEM_RESPONSE = MEMORIA_NOACK; 
179A:  MOVLW  15
179C:  MOVWF  xD1
....................    return (0); 
179E:  MOVLW  00
17A0:  MOVWF  01
17A2:  MOVLB  0
.................... } 
17A4:  GOTO   1DE6 (RETURN)
....................  
.................... /*==================== cancelar proceso ======================*/ 
....................  
.................... int MEMORIA_cancel(void){ 
....................  
....................    if((MEM_proceso != GET) || (MEM_proceso != SET)){ 
....................       return(-1); 
....................    } 
....................     
....................    if(MEM_proceso == GET){ 
....................       fputc(MEMORIA_NOACK, MEMORIA); 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................  
....................    if(MEM_proceso == SET){ 
....................       while(tamano > 0 ){ 
....................          fputc(0x00,MEMORIA); 
....................          --tamano; 
....................       } 
....................    } 
....................  
....................    tamano = 0; 
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    return (0); 
.................... } 
....................  
.................... /*==================== enviar comando de escritura ======================*/ 
.................... /* 
....................  *BUG: puede retornar 1 0 en la primera escritura del archivo 
....................  *TODO: corregir para primera escritura  
.................... */ 
.................... int MEMORIA_write(unsigned int size){ 
....................     
....................    if(!MEMORIA_OK)return(-1); 
*
1960:  BTFSC  x83.2
1962:  BRA    196A
1964:  MOVLW  FF
1966:  MOVWF  01
1968:  BRA    1A54
....................    if(MEM_proceso != WR)return(-2); 
196A:  MOVLB  1
196C:  MOVF   xB6,W
196E:  SUBLW  05
1970:  BZ    197A
1972:  MOVLW  FE
1974:  MOVWF  01
1976:  MOVLB  0
1978:  BRA    1A54
....................        
....................     
....................    //buffer maximo de 100 bytes 
....................    if((size > 0) && (size <= MAX_BUFFER)) 
197A:  MOVLB  2
197C:  MOVF   x8C,F
197E:  BZ    198E
1980:  MOVF   x8C,W
1982:  SUBLW  64
1984:  BNC   198E
....................       MEM_handshaking = MEMORIA_NO_HANDSHAKING; 
1986:  MOVLB  1
1988:  CLRF   xCE
....................    else 
198A:  BRA    1998
198C:  MOVLB  2
....................       return (-3); 
198E:  MOVLW  FD
1990:  MOVWF  01
1992:  MOVLB  0
1994:  BRA    1A54
1996:  MOVLB  1
....................     
....................    tamano = (unsigned int32)size; 
1998:  CLRF   xBC
199A:  CLRF   xBB
199C:  CLRF   xBA
199E:  MOVFF  28C,1B9
....................    //tamano = (int32)size; 
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
19A2:  MOVLW  40
19A4:  MOVLB  2
19A6:  MOVWF  x90
19A8:  MOVLB  0
19AA:  RCALL  17F8
....................    MEMORIA_putc(MEMORIA_CMD_WRITE_FILE); 
19AC:  MOVLW  74
19AE:  MOVLB  2
19B0:  MOVWF  x90
19B2:  MOVLB  0
19B4:  RCALL  17F8
....................    MEMORIA_putc((MEM_handshaking | MEM_append | MEM_performance)); 
19B6:  MOVLB  1
19B8:  MOVF   xCE,W
19BA:  IORWF  xCF,W
19BC:  IORWF  xD0,W
19BE:  MOVLB  2
19C0:  MOVWF  x8D
19C2:  MOVWF  x90
19C4:  MOVLB  0
19C6:  RCALL  17F8
....................     
....................    for(i = 0; i < car; i++) 
19C8:  MOVLB  1
19CA:  CLRF   xB7
19CC:  MOVF   xB8,W
19CE:  SUBWF  xB7,W
19D0:  BC    19F2
....................       MEMORIA_putc(MEM_file_name[i]); 
19D2:  CLRF   03
19D4:  MOVF   xB7,W
19D6:  ADDLW  C2
19D8:  MOVWF  FE9
19DA:  MOVLW  01
19DC:  ADDWFC 03,W
19DE:  MOVWF  FEA
19E0:  MOVFF  FEF,28D
19E4:  MOVFF  28D,290
19E8:  MOVLB  0
19EA:  RCALL  17F8
19EC:  MOVLB  1
19EE:  INCF   xB7,F
19F0:  BRA    19CC
....................  
....................    MEMORIA_putc(0x00); 
19F2:  MOVLB  2
19F4:  CLRF   x90
19F6:  MOVLB  0
19F8:  RCALL  17F8
....................  
....................    MEMORIA_putc(make8(tamano,3)); 
19FA:  MOVFF  1BC,28D
19FE:  MOVFF  1BC,290
1A02:  RCALL  17F8
....................    MEMORIA_putc(make8(tamano,2)); 
1A04:  MOVFF  1BB,28D
1A08:  MOVFF  1BB,290
1A0C:  RCALL  17F8
....................    MEMORIA_putc(make8(tamano,1)); 
1A0E:  MOVFF  1BA,28D
1A12:  MOVFF  1BA,290
1A16:  RCALL  17F8
....................    MEMORIA_putc(make8(tamano,0)); 
1A18:  MOVFF  1B9,28D
1A1C:  MOVFF  1B9,290
1A20:  RCALL  17F8
....................  
....................    MEM_RESPONSE = MEMORIA_getc(); 
1A22:  RCALL  18BA
1A24:  MOVFF  01,1D1
....................    //reparacion de bug a primera escritura 
....................    if(MEM_RESPONSE == 0x00){ 
1A28:  MOVLB  1
1A2A:  MOVF   xD1,F
1A2C:  BNZ   1A38
....................    	MEM_RESPONSE = MEMORIA_getc(); 
1A2E:  MOVLB  0
1A30:  RCALL  18BA
1A32:  MOVFF  01,1D1
1A36:  MOVLB  1
....................    } 
....................     
....................    if(MEM_RESPONSE != MEMORIA_ACK){ 
1A38:  MOVF   xD1,W
1A3A:  SUBLW  06
1A3C:  BZ    1A46
....................       return (-4); 
1A3E:  MOVLW  FC
1A40:  MOVWF  01
1A42:  MOVLB  0
1A44:  BRA    1A54
....................    } 
....................    #ifdef debug_memoria 
.................... 	update_proceso(SET); 
1A46:  MOVLW  06
1A48:  MOVLB  2
1A4A:  MOVWF  x8F
1A4C:  MOVLB  0
1A4E:  RCALL  168A
.................... 	#else 
.................... 	MEM_proceso = SET; 
.................... 	#endif 
....................    return (0); 
1A50:  MOVLW  00
1A52:  MOVWF  01
.................... } 
1A54:  GOTO   1E1A (RETURN)
....................  
.................... /*==================== enviar datos de escritura ======================*/ 
.................... /* 
....................  * corrwgir deacuerdo a MEMORIA_write() 
....................  */ 
.................... int MEMORIA_set_data(char *data, unsigned int size){ 
....................  
....................    if(!MEMORIA_OK)return(-5); 
1A58:  BTFSC  x83.2
1A5A:  BRA    1A62
1A5C:  MOVLW  FB
1A5E:  MOVWF  01
1A60:  BRA    1B14
....................    if(MEM_proceso != SET) return(-6); 
1A62:  MOVLB  1
1A64:  MOVF   xB6,W
1A66:  SUBLW  06
1A68:  BZ    1A74
1A6A:  MOVLW  FA
1A6C:  MOVWF  01
1A6E:  MOVLB  0
1A70:  BRA    1B14
1A72:  MOVLB  1
....................    if(tamano <= 0)return(-7); 
1A74:  MOVF   xB9,F
1A76:  BNZ   1A8E
1A78:  MOVF   xBA,F
1A7A:  BNZ   1A8E
1A7C:  MOVF   xBB,F
1A7E:  BNZ   1A8E
1A80:  MOVF   xBC,F
1A82:  BNZ   1A8E
1A84:  MOVLW  F9
1A86:  MOVWF  01
1A88:  MOVLB  0
1A8A:  BRA    1B14
1A8C:  MOVLB  1
....................  
....................    i = 0; 
1A8E:  CLRF   xB7
....................    while((tamano > 0)&&(i < size)){ 
1A90:  MOVF   xB9,F
1A92:  BNZ   1AA0
1A94:  MOVF   xBA,F
1A96:  BNZ   1AA0
1A98:  MOVF   xBB,F
1A9A:  BNZ   1AA0
1A9C:  MOVF   xBC,F
1A9E:  BZ    1ADC
1AA0:  MOVLB  2
1AA2:  MOVF   x8E,W
1AA4:  MOVLB  1
1AA6:  SUBWF  xB7,W
1AA8:  BC    1ADC
....................       MEMORIA_putc(data[i]); 
1AAA:  CLRF   03
1AAC:  MOVF   xB7,W
1AAE:  MOVLB  2
1AB0:  ADDWF  x8C,W
1AB2:  MOVWF  FE9
1AB4:  MOVF   x8D,W
1AB6:  ADDWFC 03,W
1AB8:  MOVWF  FEA
1ABA:  MOVFF  FEF,28F
1ABE:  MOVFF  28F,290
1AC2:  MOVLB  0
1AC4:  RCALL  17F8
....................       i++; 
1AC6:  MOVLB  1
1AC8:  INCF   xB7,F
....................       tamano--; 
1ACA:  MOVLW  FF
1ACC:  ADDWF  xB9,F
1ACE:  BTFSS  FD8.0
1AD0:  ADDWF  xBA,F
1AD2:  BTFSS  FD8.0
1AD4:  ADDWF  xBB,F
1AD6:  BTFSS  FD8.0
1AD8:  ADDWF  xBC,F
....................    } 
1ADA:  BRA    1A90
....................     
....................    //si no hay mas datos 
....................    if(tamano <= 0){ 
1ADC:  MOVF   xB9,F
1ADE:  BNZ   1B10
1AE0:  MOVF   xBA,F
1AE2:  BNZ   1B10
1AE4:  MOVF   xBB,F
1AE6:  BNZ   1B10
1AE8:  MOVF   xBC,F
1AEA:  BNZ   1B10
....................       MEM_RESPONSE = MEMORIA_getc(); 
1AEC:  MOVLB  0
1AEE:  RCALL  18BA
1AF0:  MOVFF  01,1D1
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
1AF4:  MOVLB  1
1AF6:  MOVF   xD1,W
1AF8:  SUBLW  06
1AFA:  BZ    1B04
....................          return (-8); 
1AFC:  MOVLW  F8
1AFE:  MOVWF  01
1B00:  MOVLB  0
1B02:  BRA    1B14
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
1B04:  MOVLW  07
1B06:  MOVLB  2
1B08:  MOVWF  x8F
1B0A:  MOVLB  0
1B0C:  RCALL  168A
1B0E:  MOVLB  1
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i); 
1B10:  MOVFF  1B7,01
1B14:  MOVLB  0
.................... } 
1B16:  GOTO   1E58 (RETURN)
....................  
.................... /*==================== enviar comando de lectura ======================*/ 
....................  
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes){ 
....................    char Umsb = 0, Ulsb = 0, Lmsb = 0,Llsb = 0, dummy= 0; 
....................  
....................    if(!MEMORIA_OK)return(-1); 
....................    if(MEM_proceso != RD)return(-2); 
....................  
....................    if((num_bytes > 0) && (num_bytes <= MAX_BUFFER)) 
....................       MEM_handshaking = num_bytes; 
....................    else 
....................       return (-3); 
....................     
....................     
....................    MEMORIA_putc(MEMORIA_EXT_CMD); 
....................    MEMORIA_putc(MEMORIA_CMD_READ_FILE); 
....................    MEMORIA_putc(MEM_handshaking); 
....................     
....................    for(i = 0; i < car; i++) 
....................       MEMORIA_putc(MEM_file_name[i]); 
.................... 	 
.................... 	fputc(0x00, MEMORIA); 
.................... 	// hay un bug al leer por primera vez un archivo 
.................... 	// genera 2 ACK antes del tamao del archivo 
.................... 	if(read_flag == 0){ 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		dummy = fgetc(MEMORIA); 
.................... 		read_flag = 1; 
.................... 	} 
.................... 	//bug de comunicacion 
.................... 	 
.................... 	Umsb = fgetc(MEMORIA); 
....................    Ulsb = fgetc(MEMORIA); 
....................    Lmsb = fgetc(MEMORIA); 
....................    Llsb = fgetc(MEMORIA); 
....................     
....................    tamano = make32(Umsb,Ulsb,Lmsb,Llsb); 
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r==%x %x %x %x", Umsb, Ulsb,Lmsb,Llsb); 
.................... 	update_proceso(GET); 
.................... 	#else 
.................... 	MEM_proceso = GET; 
.................... 	#endif 
....................    return (tamano); 
.................... } 
....................  
....................  
.................... /*==================== obtener datos de la lectura ======================*/ 
....................  
.................... int MEMORIA_get_data(char *buffer){    
....................    char c = 0x00; 
....................  
....................    if(!MEMORIA_OK) return(-1); 
....................    if(MEM_proceso != GET) return(-2); 
....................    if(tamano <= 0) return(-3); 
....................  
....................    i = 0; 
....................    MEMORIA_putc(MEMORIA_ACK);//envia un ACK para recivir nuevos datos 
....................    while((i < MEM_handshaking) && (tamano > 0 )){ 
....................       c = MEMORIA_getc(); 
....................       buffer[i] = c; 
....................       i++; 
....................       tamano--; 
....................    } 
....................  
....................    //si alcanzo el total de datos 
....................    if(tamano == 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(MEM_RESPONSE != MEMORIA_ACK){ 
....................          return (-4); 
....................       } 
....................       #ifdef debug_memoria 
.................... 		update_proceso(CLOSE); 
.................... 		#else 
.................... 		MEM_proceso = CLOSE; 
.................... 		#endif 
....................    } 
....................    return (i);    
.................... } 
....................  
.................... /*==================== cerrar el archivo abierto ======================*/ 
....................  
.................... int MEMORIA_close(void){ 
.................... 	/* 
.................... 	* hay un bug en esta funcion que no contempla limpiar 
.................... 	* la configuracion cuando no ha iniciado el hardware o 
.................... 	* despues de un reset 
.................... 	*/ 
.................... 	/* 
....................    if(!MEMORIA_OK)return (1); 
....................    if(MEM_proceso != CLOSE) return(2); 
....................    */ 
....................    strcpy (MEM_file_name,"");	//cambiar para inicializar a 0 
1B1A:  MOVLW  01
1B1C:  MOVWF  FEA
1B1E:  MOVLW  C2
1B20:  MOVWF  FE9
1B22:  MOVFF  FF2,28C
1B26:  BCF    FF2.7
1B28:  MOVLW  00
1B2A:  CALL   0282
1B2E:  TBLRD*-
1B30:  TBLRD*+
1B32:  MOVF   FF5,W
1B34:  MOVWF  FEE
1B36:  IORLW  00
1B38:  BNZ   1B30
1B3A:  MOVLB  2
1B3C:  BTFSC  x8C.7
1B3E:  BSF    FF2.7
....................    i = 0; 
1B40:  MOVLB  1
1B42:  CLRF   xB7
....................    car = 0; 
1B44:  CLRF   xB8
....................    timeout_error = FALSE; 
1B46:  MOVLB  0
1B48:  BCF    x83.4
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
1B4A:  MOVLW  01
1B4C:  MOVLB  1
1B4E:  MOVWF  xCE
....................    MEM_RESPONSE = MEMORIA_NOACK; 
1B50:  MOVLW  15
1B52:  MOVWF  xD1
....................    #ifdef debug_memoria 
.................... 	update_proceso(OPEN); 
1B54:  MOVLW  02
1B56:  MOVLB  2
1B58:  MOVWF  x8F
1B5A:  MOVLB  0
1B5C:  RCALL  168A
.................... 	#else 
.................... 	MEM_proceso = OPEN; 
.................... 	#endif 
....................    return(0); 
1B5E:  MOVLW  00
1B60:  MOVWF  01
.................... } 
1B62:  GOTO   1E82 (RETURN)
....................  
.................... /*	====================================== 
.................... 	FUNCIONES FUNCIONES DE CONTROL Y BAJO NIVEL 
.................... 	====================================== 
.................... */ 
....................  
.................... /*==================== memoria ocupada =======================*/ 
.................... /*comprueba que no se este realizando un porceso anterior en la memoria*/ 
.................... int MEMORIA_is_busy(void){ 
....................    return ((MEM_proceso == OPEN )? 0 : 1); 
.................... }  
....................  
.................... /*==================== colocar un caracter en el bus======================*/ 
.................... void MEMORIA_putc(char c){ 
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, "\n\r>%X", c); 
*
17F8:  MOVLW  0A
17FA:  MOVLB  2
17FC:  MOVWF  x96
17FE:  MOVLB  0
1800:  RCALL  14FC
1802:  MOVLW  0D
1804:  MOVLB  2
1806:  MOVWF  x96
1808:  MOVLB  0
180A:  RCALL  14FC
180C:  MOVLW  3E
180E:  MOVLB  2
1810:  MOVWF  x96
1812:  MOVLB  0
1814:  RCALL  14FC
1816:  MOVFF  290,291
181A:  MOVLW  37
181C:  MOVLB  2
181E:  MOVWF  x92
1820:  MOVLB  0
1822:  RCALL  17A8
.................... 	#endif 
....................    fputc(c, MEMORIA); 
1824:  MOVLB  2
1826:  MOVF   x90,W
1828:  MOVLB  0
182A:  BRA    17EE
....................    #ifdef debug_memoria 
.................... 	printf(usb_cdc_putc_fast, " e%X", rs232_errors); 
182C:  MOVLW  20
182E:  MOVLB  2
1830:  MOVWF  x96
1832:  MOVLB  0
1834:  RCALL  14FC
1836:  MOVLW  65
1838:  MOVLB  2
183A:  MOVWF  x96
183C:  MOVLB  0
183E:  RCALL  14FC
1840:  MOVFF  1B5,291
1844:  MOVLW  37
1846:  MOVLB  2
1848:  MOVWF  x92
184A:  MOVLB  0
184C:  RCALL  17A8
.................... 	#endif 
....................    return; 
.................... } 
184E:  RETLW  00
....................  
.................... /*==================== obtiene un caracter del bus======================*/ 
.................... char MEMORIA_getc(void){ 
*
18BA:  MOVLB  2
18BC:  CLRF   x8F
18BE:  MOVLW  03
18C0:  MOVWF  x90
.................... 	char c = 0x00, cont = 3; 
....................    timeout_error=FALSE; 
18C2:  MOVLB  0
18C4:  BCF    x83.4
....................    while(!kbhit(MEMORIA) && cont > 0 && !c){ 
18C6:  BTFSC  F9E.5
18C8:  BRA    18FA
18CA:  MOVLB  2
18CC:  MOVF   x90,F
18CE:  BTFSS  FD8.2
18D0:  BRA    18D6
18D2:  MOVLB  0
18D4:  BRA    18FA
18D6:  MOVF   x8F,F
18D8:  BTFSC  FD8.2
18DA:  BRA    18E0
18DC:  MOVLB  0
18DE:  BRA    18FA
....................    	c = fgetc(MEMORIA); 
18E0:  MOVLB  0
18E2:  RCALL  1872
18E4:  MOVFF  01,28F
....................    	#ifdef debug_memoria 
....................    	usb_cdc_putc_fast('*'); 
18E8:  MOVLW  2A
18EA:  MOVLB  2
18EC:  MOVWF  x96
18EE:  MOVLB  0
18F0:  RCALL  14FC
....................    	#endif 
....................    	cont--; 
18F2:  MOVLB  2
18F4:  DECF   x90,F
....................    } 
18F6:  MOVLB  0
18F8:  BRA    18C6
....................     
....................    if(!c) c = fgetc(MEMORIA); 
18FA:  MOVLB  2
18FC:  MOVF   x8F,F
18FE:  BNZ   190A
1900:  MOVLB  0
1902:  RCALL  1872
1904:  MOVFF  01,28F
1908:  MOVLB  2
....................     
....................    #ifdef debug_memoria 
....................    printf(usb_cdc_putc_fast,"\n\r<%x e%x", c, rs232_errors); 
190A:  MOVLW  0A
190C:  MOVWF  x96
190E:  MOVLB  0
1910:  RCALL  14FC
1912:  MOVLW  0D
1914:  MOVLB  2
1916:  MOVWF  x96
1918:  MOVLB  0
191A:  RCALL  14FC
191C:  MOVLW  3C
191E:  MOVLB  2
1920:  MOVWF  x96
1922:  MOVLB  0
1924:  RCALL  14FC
1926:  MOVFF  28F,291
192A:  MOVLW  57
192C:  MOVLB  2
192E:  MOVWF  x92
1930:  MOVLB  0
1932:  RCALL  17A8
1934:  MOVLW  20
1936:  MOVLB  2
1938:  MOVWF  x96
193A:  MOVLB  0
193C:  RCALL  14FC
193E:  MOVLW  65
1940:  MOVLB  2
1942:  MOVWF  x96
1944:  MOVLB  0
1946:  RCALL  14FC
1948:  MOVFF  1B5,291
194C:  MOVLW  57
194E:  MOVLB  2
1950:  MOVWF  x92
1952:  MOVLB  0
1954:  RCALL  17A8
....................    #endif 
....................    return(c); 
1956:  MOVLB  2
1958:  MOVFF  28F,01
.................... } 
195C:  MOVLB  0
195E:  RETLW  00
.................... #endif	// MEMORIA_H 
....................  
.................... #include "utilidades.c" 
.................... //#include "Nucleo.h" 
.................... #include "utilidades.h" 
.................... #ifndef UTILIDADES_H 
.................... #define UTILIDADES_H 
....................  
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng); 
....................  
.................... #ifndef SIMULACION 
.................... 	int1 _debug_usb(); 
.................... 	//#define PUERTO usb_cdc_putc_fast 
.................... #else 
.................... 	#define _debug_usb() 1 
.................... 	#use rs232(stream=PUERTO,baud=9600,parity=N,xmit=PIN_XMIT,rcv=PIN_RCV,bits=8)  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
.................... #define MYDIM 64; 
.................... char MyArray[MYDIM]; 
.................... */ 
....................  
.................... int16 crc_1021(int16 old_crc, int8 data) 
.................... {  
....................   int16 crc; 
....................   int16 x; 
....................   x = make8(old_crc,1) ^ data;  //x = ((old_crc>>8) ^ data) & 0xff;  
....................   x ^= x>>4; 
....................   crc = (old_crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
....................   crc &= 0xffff;  
....................   return crc;  
.................... } 
....................  
.................... int16 calc_CRC(char *buffer, unsigned int8 leng){ 
.................... 	unsigned int8 i;  
....................    int16 MyCRC; 
....................     
....................    MyCRC = 0xFFFF;  
....................    for(i=0 ; i<leng ; i++) {  
....................       MyCRC = crc_1021(MyCRC,buffer[i]);  
....................    } 
....................    return (MyCRC); 
.................... } 
....................  
.................... #ifndef SIMULACION 
.................... int1 _debug_usb(void){ 
.................... 	if(COM_sense() == USB_OK){ 
*
1C0A:  RCALL  1BE8
1C0C:  DECFSZ 01,W
1C0E:  BRA    1C1C
....................       output_bit(INDICADOR_USB, 1); 
1C10:  BSF    F8D.1
1C12:  BCF    F96.1
....................       return (1); 
1C14:  MOVLW  01
1C16:  MOVWF  01
1C18:  BRA    1C26
.................... 	}else{ 
1C1A:  BRA    1C26
.................... 		output_bit(INDICADOR_USB, 0); 
1C1C:  BCF    F8D.1
1C1E:  BCF    F96.1
.................... 		return (0); 
1C20:  MOVLW  00
1C22:  MOVWF  01
1C24:  BRA    1C26
.................... 	} 
.................... } 
1C26:  RETLW  00
.................... #endif 
....................  
....................  
.................... #include "configuracion.c" 
.................... #ifdef CONFIGURACION_H 
....................  
.................... void iniciar_perifericos(){ 
....................      
....................     #ifdef COMUNICACION_H 
....................     myerror = COM_init(); 
*
2700:  BRA    231C
2702:  MOVFF  01,98
....................     //printf("\n\rusb E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef MEMORIA_H 
....................     MEMORIA_reset(); 
2706:  BRA    2356
....................    myerror = MEMORIA_init_hw(); 
2708:  BRA    23A2
270A:  MOVFF  01,98
....................    myerror = MEMORIA_init(); 
270E:  BRA    2410
2710:  MOVFF  01,98
....................    //printf("\n\rmem E%d", myerror); 
....................     #endif 
....................      
....................     #ifdef ANALOGO_DIGITAL_H 
....................     myerror = AD_init_adc(); 
2714:  BRA    2476
2716:  MOVFF  01,98
....................     #endif 
....................      
....................     #ifdef CAPTURA_FRECUENCIA_H 
....................     myerror = CP_init_ccp(); 
271A:  BRA    2498
271C:  MOVFF  01,98
....................     #endif 
....................      
....................     #ifdef DS1307_H 
....................     ds1307_init(DS1307_OUT_ON_DISABLED_HIHG | DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
2720:  MOVLW  90
2722:  MOVLB  1
2724:  MOVWF  xD2
2726:  MOVLB  0
2728:  BRA    24F6
....................    //ds1307_set_date_time(0x0d, 0x01, 0x0d, 0x00, 0x0a, 0x2a, 0x00); 
....................    CONF_CANAL_ACTIVO = ds1307_read_nvram_byte(CONF_DIR_CANAl); 
272A:  MOVLW  08
272C:  MOVLB  1
272E:  MOVWF  xD2
2730:  MOVLB  0
2732:  RCALL  2660
2734:  MOVFF  01,96
....................    //CONF_CANAL_ACTIVO = 0b00000000; 
....................     #endif 
....................      
....................    data.dia = data.mes = data.anio = 0; 
2738:  CLRF   xE1
273A:  MOVFF  E1,E0
273E:  MOVFF  E0,DF
....................    data.hor = data.min = data.seg = 0; 
2742:  CLRF   xE4
2744:  MOVFF  E4,E3
2748:  MOVFF  E3,E2
....................    data.value = data.sensor = data.no_data = 0; 
274C:  CLRF   xE6
274E:  MOVFF  E6,E5
2752:  CLRF   xEA
2754:  CLRF   xE9
2756:  CLRF   xE8
2758:  MOVFF  E5,E7
....................    data.crc = 0; 
275C:  CLRF   xEC
275E:  CLRF   xEB
....................     
.................... } 
2760:  GOTO   2766 (RETURN)
....................  
....................  
.................... int sensor_activo(int sensor){ 
....................     switch(sensor){ 
*
1F3E:  MOVLB  2
1F40:  MOVF   x8A,W
1F42:  XORLW  06
1F44:  MOVLB  0
1F46:  BZ    1F56
1F48:  XORLW  03
1F4A:  BZ    1F60
1F4C:  XORLW  06
1F4E:  BZ    1F6A
1F50:  XORLW  07
1F52:  BZ    1F74
1F54:  BRA    1F7E
....................         case CCP_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_REV_BIT)); 
1F56:  MOVLW  00
1F58:  BTFSC  x96.1
1F5A:  MOVLW  01
1F5C:  MOVWF  01
1F5E:  BRA    1F84
....................         case CCP_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_CCP_VEL_BIT)); 
1F60:  MOVLW  00
1F62:  BTFSC  x96.0
1F64:  MOVLW  01
1F66:  MOVWF  01
1F68:  BRA    1F84
....................         case AD_VEL: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_VEL_BIT)); 
1F6A:  MOVLW  00
1F6C:  BTFSC  x96.3
1F6E:  MOVLW  01
1F70:  MOVWF  01
1F72:  BRA    1F84
....................         case AD_REV: 
....................             return (bit_test(CONF_CANAL_ACTIVO, CONF_AD_REV_BIT)); 
1F74:  MOVLW  00
1F76:  BTFSC  x96.4
1F78:  MOVLW  01
1F7A:  MOVWF  01
1F7C:  BRA    1F84
....................         default: 
....................             return (0); 
1F7E:  MOVLW  00
1F80:  MOVWF  01
1F82:  BRA    1F84
....................     } 
.................... } 
1F84:  RETLW  00
....................  
....................  
.................... void modo_configuracion(){ 
....................     //printf( cout "\n\rmodo configuracion\n\r" ); 
....................    while(_debug_usb()){ 
*
29B2:  CALL   1C0A
29B6:  MOVF   01,F
29B8:  BTFSC  FD8.2
29BA:  BRA    2D2C
....................             while(!(data.sensor = cin()));    //cambiar con usb 
29BC:  RCALL  27DC
29BE:  MOVFF  01,E5
29C2:  MOVF   xE5,F
29C4:  BZ    29BC
....................             switch(data.sensor){ 
29C6:  MOVF   xE5,W
29C8:  XORLW  31
29CA:  BZ    29EA
29CC:  XORLW  03
29CE:  BZ    2A48
29D0:  XORLW  07
29D2:  BTFSC  FD8.2
29D4:  BRA    2C62
29D6:  XORLW  03
29D8:  BTFSC  FD8.2
29DA:  BRA    2C8E
29DC:  XORLW  05
29DE:  BTFSC  FD8.2
29E0:  BRA    2CBA
29E2:  XORLW  07
29E4:  BTFSC  FD8.2
29E6:  BRA    2CE4
29E8:  BRA    2D0E
....................                 case CONF_SET_FECHA: 
....................                     putc(CONF_SET_FECHA); 
29EA:  MOVLW  31
29EC:  MOVLB  1
29EE:  MOVWF  xD2
29F0:  MOVLB  0
29F2:  RCALL  280C
....................                     //printf( cout "\n\rFECHA: %c", data.sensor); 
....................                     data.dia = cin(); 
29F4:  RCALL  27DC
29F6:  MOVFF  01,DF
....................                     data.mes = cin(); 
29FA:  RCALL  27DC
29FC:  MOVFF  01,E0
....................                     data.anio = cin(); 
2A00:  RCALL  27DC
2A02:  MOVFF  01,E1
....................                     data.no_data = cin(); 
2A06:  RCALL  27DC
2A08:  MOVFF  01,E6
....................                     data.hor = cin(); 
2A0C:  RCALL  27DC
2A0E:  MOVFF  01,E2
....................                     data.min = cin(); 
2A12:  RCALL  27DC
2A14:  MOVFF  01,E3
....................                     data.seg = cin(); 
2A18:  RCALL  27DC
2A1A:  MOVFF  01,E4
....................                     ds1307_set_date_time(data.dia, data.mes, data.anio, data.no_data,data.hor, data.min, data.seg); 
2A1E:  MOVFF  DF,1D2
2A22:  MOVFF  E0,1D3
2A26:  MOVFF  E1,1D4
2A2A:  MOVFF  E6,1D5
2A2E:  MOVFF  E2,1D6
2A32:  MOVFF  E3,1D7
2A36:  MOVFF  E4,1D8
2A3A:  BRA    284A
....................                     /*printf( cout "\n\r%u/%u/%u(%u:%u:%u) S:%u N:%u V:%Lu", 
....................                                 data.dia, data.mes, data.anio, 
....................                                 data.hor, data.min, data.seg, 
....................                                 data.sensor, data.no_data, data.value);*/ 
....................                     putc(CONF_ACK); 
2A3C:  MOVLW  06
2A3E:  MOVLB  1
2A40:  MOVWF  xD2
2A42:  MOVLB  0
2A44:  RCALL  280C
....................                     break; 
2A46:  BRA    2D18
....................                 case CONF_GET_FECHA: 
....................                     putc(CONF_GET_FECHA); 
2A48:  MOVLW  32
2A4A:  MOVLB  1
2A4C:  MOVWF  xD2
2A4E:  MOVLB  0
2A50:  RCALL  280C
....................                     ds1307_get_date(data.dia, data.mes, data.anio, data.no_data); 
....................                     ds1307_get_time(data.hor, data.min, data.seg); 
....................                     putc(data.dia); 
*
2C2C:  MOVFF  DF,1D2
2C30:  RCALL  280C
....................                     putc(data.mes); 
2C32:  MOVFF  E0,1D2
2C36:  RCALL  280C
....................                     putc(data.anio); 
2C38:  MOVFF  E1,1D2
2C3C:  RCALL  280C
....................                     putc(data.no_data); 
2C3E:  MOVFF  E6,1D2
2C42:  RCALL  280C
....................                     putc(data.hor); 
2C44:  MOVFF  E2,1D2
2C48:  RCALL  280C
....................                     putc(data.min); 
2C4A:  MOVFF  E3,1D2
2C4E:  RCALL  280C
....................                     putc(data.seg); 
2C50:  MOVFF  E4,1D2
2C54:  RCALL  280C
....................                     putc(CONF_ACK); 
2C56:  MOVLW  06
2C58:  MOVLB  1
2C5A:  MOVWF  xD2
2C5C:  MOVLB  0
2C5E:  RCALL  280C
....................                     break; 
2C60:  BRA    2D18
....................                 case CONF_SET_DATO: 
....................                     putc(CONF_SET_DATO); 
2C62:  MOVLW  35
2C64:  MOVLB  1
2C66:  MOVWF  xD2
2C68:  MOVLB  0
2C6A:  RCALL  280C
....................                     data.sensor = cin(); //lee la direccion 
2C6C:  RCALL  27DC
2C6E:  MOVFF  01,E5
....................                     data.no_data = cin(); // lee el valor 
2C72:  RCALL  27DC
2C74:  MOVFF  01,E6
....................                     ds1307_write_nvram_byte(data.sensor, data.no_data); 
2C78:  MOVFF  E5,1D2
2C7C:  MOVFF  E6,1D3
2C80:  RCALL  292C
....................                     putc(CONF_ACK); 
2C82:  MOVLW  06
2C84:  MOVLB  1
2C86:  MOVWF  xD2
2C88:  MOVLB  0
2C8A:  RCALL  280C
....................                     break; 
2C8C:  BRA    2D18
....................                 case CONF_GET_DATO: 
....................                     putc(CONF_GET_DATO); 
2C8E:  MOVLW  36
2C90:  MOVLB  1
2C92:  MOVWF  xD2
2C94:  MOVLB  0
2C96:  RCALL  280C
....................                     data.sensor = cin(); //lee la direccion 
2C98:  RCALL  27DC
2C9A:  MOVFF  01,E5
....................                     data.no_data = ds1307_read_nvram_byte(data.sensor); //lee el valor de la ram 
2C9E:  MOVFF  E5,1D2
2CA2:  RCALL  2660
2CA4:  MOVFF  01,E6
....................                     putc(data.no_data); 
2CA8:  MOVFF  E6,1D2
2CAC:  RCALL  280C
....................                     putc(CONF_ACK); 
2CAE:  MOVLW  06
2CB0:  MOVLB  1
2CB2:  MOVWF  xD2
2CB4:  MOVLB  0
2CB6:  RCALL  280C
....................                     break; 
2CB8:  BRA    2D18
....................                 case CONF_SET_CANAL: 
....................                     putc(CONF_SET_CANAL); 
2CBA:  MOVLW  33
2CBC:  MOVLB  1
2CBE:  MOVWF  xD2
2CC0:  MOVLB  0
2CC2:  RCALL  280C
....................                     data.no_data = cin(); 
2CC4:  RCALL  27DC
2CC6:  MOVFF  01,E6
....................                     ds1307_write_nvram_byte(CONF_DIR_CANAL, data.no_data); 
2CCA:  MOVLW  08
2CCC:  MOVLB  1
2CCE:  MOVWF  xD2
2CD0:  MOVFF  E6,1D3
2CD4:  MOVLB  0
2CD6:  RCALL  292C
....................                     //printf( cout "\n\rCANAL: %u", data.no_data); 
....................                     putc(CONF_ACK); 
2CD8:  MOVLW  06
2CDA:  MOVLB  1
2CDC:  MOVWF  xD2
2CDE:  MOVLB  0
2CE0:  RCALL  280C
....................                     break; 
2CE2:  BRA    2D18
....................                 case CONF_GET_CANAL: 
....................                     putc(CONF_GET_CANAL); 
2CE4:  MOVLW  34
2CE6:  MOVLB  1
2CE8:  MOVWF  xD2
2CEA:  MOVLB  0
2CEC:  RCALL  280C
....................                     data.no_data = ds1307_read_nvram_byte(CONF_DIR_CANAL); 
2CEE:  MOVLW  08
2CF0:  MOVLB  1
2CF2:  MOVWF  xD2
2CF4:  MOVLB  0
2CF6:  RCALL  2660
2CF8:  MOVFF  01,E6
....................                     putc(data.no_data); 
2CFC:  MOVFF  E6,1D2
2D00:  RCALL  280C
....................                     putc(CONF_ACK); 
2D02:  MOVLW  06
2D04:  MOVLB  1
2D06:  MOVWF  xD2
2D08:  MOVLB  0
2D0A:  RCALL  280C
....................                     break; 
2D0C:  BRA    2D18
....................                 default: 
....................                     putc(CONF_NOACK); 
2D0E:  MOVLW  15
2D10:  MOVLB  1
2D12:  MOVWF  xD2
2D14:  MOVLB  0
2D16:  RCALL  280C
....................             } 
....................             if(data.sensor == CONF_SALIR) {printf( cout "\n\rDesconectar...");break;} 
2D18:  MOVF   xE5,W
2D1A:  SUBLW  39
2D1C:  BNZ   2D2A
2D1E:  MOVLW  04
2D20:  MOVWF  FF6
2D22:  MOVLW  23
2D24:  MOVWF  FF7
2D26:  BRA    298E
2D28:  BRA    2D2C
....................     } 
2D2A:  BRA    29B2
....................     return; 
.................... } 
2D2C:  GOTO   2F5A (RETURN)
....................  
.................... #endif    //CONFIGURACION_H 
....................  
....................  

Configuration Fuses:
   Word  1: CE3C   IESO FCMEN HSPLL PLL5 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
