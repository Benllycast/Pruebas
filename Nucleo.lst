CCS PCH C Compiler, Version 4.105, 13255               10-Oct-12 15:37

               Filename: G:\Project\pic\CCS\MMA7455l\Nucleo.lst

               ROM used: 2744 bytes (8%)
                         Largest free fragment is 30020
               RAM used: 179 (9%) at main() level
                         192 (9%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  GOTO   0638
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   00F4
0060:  BTFSS  F9D.2
0062:  GOTO   006C
0066:  BTFSC  F9E.2
0068:  GOTO   00FC
006C:  BTFSS  FA0.0
006E:  GOTO   0078
0072:  BTFSC  FA1.0
0074:  GOTO   0176
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
0610:  CLRF   FEA
0612:  MOVLW  B3
0614:  MOVWF  FE9
0616:  MOVF   FEF,W
0618:  BZ    0636
061A:  MOVLW  07
061C:  MOVWF  01
061E:  CLRF   00
0620:  DECFSZ 00,F
0622:  BRA    0620
0624:  DECFSZ 01,F
0626:  BRA    061E
0628:  MOVLW  C7
062A:  MOVWF  00
062C:  DECFSZ 00,F
062E:  BRA    062C
0630:  NOP   
0632:  DECFSZ FEF,F
0634:  BRA    061A
0636:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "accelerometro.h" 
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int x; 
....................     int y; 
....................     int z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, long *buffer); 
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD	0x55 
.................... #define MEMORIA_CMD_VER_INFO	0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD			0x40 
.................... #define MEMORIA_CMD_READ_FILE	0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK 		0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON 			0x01 
.................... #define MEMORIA_OFF 		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT	12 
.................... #define MEMORIA_NAME_TERMINATOR 0x00 
.................... #define MEMORIA_DELIMITADOR 	0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE 	0x00 
.................... #define MEMORIA_LOW_PERFORMANCE 	0x40 
.................... //#define MEMORIA_OUT_TIME	65535	//modificar para colocar tiempos mas largos 
.................... //#define MEMORIA_COMPROBAR_ARCHIVO 
....................  
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char *filename, char modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char *data, unsigned int size); 
.................... char MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char *buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... //extern CONFIG_MMA7455 CONFIG; 
.................... //extern unsigned int32 tiempo_inicial, tiempo_final; 
.................... void setup_devices(){ 
*
0450:  MOVLW  FF
0452:  MOVWF  xB2
....................    int error = -1; 
....................    /////////////configuracion del MMA7455//////////////// 
....................    //error = init_MMA(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = AD_init_adc(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = CP_init_ccp(); 
....................    ////////////////////////////////////////////////////// 
....................    //error = MEMORIA_init(); 
....................    ////////////////////////////////////////////////////// 
....................    ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ); 
0454:  MOVLW  10
0456:  MOVWF  xB3
0458:  BRA    030C
....................    ////////////////////////////////////////////////////// 
....................    setup_psp(PSP_DISABLED); 
045A:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
045C:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
045E:  MOVLW  80
0460:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
0462:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0464:  MOVLW  00
0466:  MOVWF  FCA
0468:  MOVLW  00
046A:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_ccp1(CCP_OFF); 
....................    setup_comparator(NC_NC_NC_NC); 
046C:  MOVLW  07
046E:  MOVWF  FB4
0470:  MOVF   F92,W
0472:  MOVWF  F92
0474:  MOVLW  13
0476:  MOVWF  00
0478:  DECFSZ 00,F
047A:  BRA    0478
047C:  BRA    047E
047E:  MOVF   FB4,W
0480:  BCF    FA1.6
....................    setup_vref(FALSE); 
0482:  CLRF   FB5
....................    return; 
.................... } 
0484:  GOTO   0832 (RETURN)
....................  
.................... void main() 
.................... { 
*
0638:  CLRF   FF8
063A:  BCF    FD0.7
063C:  BSF    07.7
063E:  CLRF   FEA
0640:  CLRF   FE9
0642:  BSF    FB8.3
0644:  MOVLW  70
0646:  MOVWF  FAF
0648:  MOVLW  02
064A:  MOVWF  FB0
064C:  MOVLW  A6
064E:  MOVWF  FAC
0650:  MOVLW  90
0652:  MOVWF  FAB
0654:  BSF    F93.1
0656:  BSF    F93.0
0658:  MOVLW  3B
065A:  MOVWF  FC8
065C:  MOVLW  28
065E:  MOVWF  FC6
0660:  BSF    FC7.7
0662:  BCF    FC7.6
0664:  BCF    F95.6
0666:  BSF    F8C.6
0668:  BCF    28.0
066A:  BCF    28.1
066C:  BCF    28.2
066E:  CLRF   29
0670:  CLRF   2A
0672:  CLRF   2B
0674:  MOVLW  C3
0676:  MOVWF  2D
0678:  MOVLW  50
067A:  MOVWF  2C
067C:  MOVLW  7C
067E:  MOVWF  2F
0680:  MOVLW  1D
0682:  MOVWF  2E
0684:  CLRF   33
0686:  CLRF   32
0688:  CLRF   31
068A:  CLRF   30
068C:  MOVLW  01
068E:  MOVWF  45
0690:  MOVLW  80
0692:  MOVWF  46
0694:  CLRF   47
0696:  MOVLW  15
0698:  MOVWF  48
069A:  BSF    FB8.3
069C:  MOVLW  70
069E:  MOVWF  FAF
06A0:  MOVLW  02
06A2:  MOVWF  FB0
06A4:  MOVLW  A6
06A6:  MOVWF  FAC
06A8:  MOVLW  90
06AA:  MOVWF  FAB
06AC:  MOVLW  05
06AE:  MOVWF  x9C
06B0:  MOVWF  x9D
06B2:  MOVLW  FF
06B4:  MOVWF  x9E
06B6:  MOVLW  CD
06B8:  MOVWF  x9F
06BA:  CLRF   xA0
06BC:  CLRF   xA4
06BE:  CLRF   xA3
06C0:  CLRF   xA2
06C2:  CLRF   xA1
06C4:  CLRF   xA8
06C6:  CLRF   xA7
06C8:  CLRF   xA6
06CA:  CLRF   xA5
06CC:  BSF    FB8.3
06CE:  MOVLW  70
06D0:  MOVWF  FAF
06D2:  MOVLW  02
06D4:  MOVWF  FB0
06D6:  MOVLW  A6
06D8:  MOVWF  FAC
06DA:  MOVLW  90
06DC:  MOVWF  FAB
06DE:  MOVF   FC1,W
06E0:  ANDLW  C0
06E2:  IORLW  0F
06E4:  MOVWF  FC1
06E6:  MOVLW  07
06E8:  MOVWF  FB4
06EA:  CLRF   19
06EC:  CLRF   1A
06EE:  CLRF   1B
06F0:  CLRF   1C
06F2:  MOVLW  01
06F4:  MOVWF  1D
06F6:  MOVLW  02
06F8:  MOVWF  1E
06FA:  MOVLW  03
06FC:  MOVWF  1F
06FE:  MOVLW  80
0700:  MOVWF  20
0702:  MOVWF  21
0704:  MOVWF  22
0706:  MOVWF  23
0708:  MOVWF  24
070A:  MOVWF  25
070C:  CLRF   26
070E:  CLRF   27
0710:  CLRF   34
0712:  CLRF   35
0714:  CLRF   36
0716:  CLRF   37
0718:  CLRF   38
071A:  CLRF   49
071C:  CLRF   4A
071E:  MOVLW  4C
0720:  MOVWF  4B
0722:  MOVLW  75
0724:  MOVWF  4C
0726:  MOVLW  6E
0728:  MOVWF  4D
072A:  MOVLW  65
072C:  MOVWF  4E
072E:  MOVLW  73
0730:  MOVWF  4F
0732:  CLRF   50
0734:  CLRF   51
0736:  CLRF   52
0738:  CLRF   53
073A:  CLRF   54
073C:  CLRF   55
073E:  MOVLW  4D
0740:  MOVWF  56
0742:  MOVLW  61
0744:  MOVWF  57
0746:  MOVLW  72
0748:  MOVWF  58
074A:  MOVLW  74
074C:  MOVWF  59
074E:  MOVLW  65
0750:  MOVWF  5A
0752:  MOVLW  73
0754:  MOVWF  5B
0756:  CLRF   5C
0758:  CLRF   5D
075A:  CLRF   5E
075C:  CLRF   5F
075E:  CLRF   x60
0760:  MOVLW  4D
0762:  MOVWF  x61
0764:  MOVLW  69
0766:  MOVWF  x62
0768:  MOVLW  E9
076A:  MOVWF  x63
076C:  MOVLW  72
076E:  MOVWF  x64
0770:  MOVLW  63
0772:  MOVWF  x65
0774:  MOVLW  6F
0776:  MOVWF  x66
0778:  MOVLW  6C
077A:  MOVWF  x67
077C:  MOVLW  65
077E:  MOVWF  x68
0780:  MOVLW  73
0782:  MOVWF  x69
0784:  CLRF   x6A
0786:  CLRF   x6B
0788:  MOVLW  4A
078A:  MOVWF  x6C
078C:  MOVLW  75
078E:  MOVWF  x6D
0790:  MOVLW  65
0792:  MOVWF  x6E
0794:  MOVLW  76
0796:  MOVWF  x6F
0798:  MOVLW  65
079A:  MOVWF  x70
079C:  MOVLW  73
079E:  MOVWF  x71
07A0:  CLRF   x72
07A2:  CLRF   x73
07A4:  CLRF   x74
07A6:  CLRF   x75
07A8:  CLRF   x76
07AA:  MOVLW  56
07AC:  MOVWF  x77
07AE:  MOVLW  69
07B0:  MOVWF  x78
07B2:  MOVLW  65
07B4:  MOVWF  x79
07B6:  MOVLW  72
07B8:  MOVWF  x7A
07BA:  MOVLW  6E
07BC:  MOVWF  x7B
07BE:  MOVLW  65
07C0:  MOVWF  x7C
07C2:  MOVLW  73
07C4:  MOVWF  x7D
07C6:  CLRF   x7E
07C8:  CLRF   x7F
07CA:  CLRF   x80
07CC:  CLRF   x81
07CE:  MOVLW  53
07D0:  MOVWF  x82
07D2:  MOVLW  E1
07D4:  MOVWF  x83
07D6:  MOVLW  62
07D8:  MOVWF  x84
07DA:  MOVLW  61
07DC:  MOVWF  x85
07DE:  MOVLW  64
07E0:  MOVWF  x86
07E2:  MOVLW  6F
07E4:  MOVWF  x87
07E6:  CLRF   x88
07E8:  CLRF   x89
07EA:  CLRF   x8A
07EC:  CLRF   x8B
07EE:  CLRF   x8C
07F0:  MOVLW  44
07F2:  MOVWF  x8D
07F4:  MOVLW  6F
07F6:  MOVWF  x8E
07F8:  MOVLW  6D
07FA:  MOVWF  x8F
07FC:  MOVLW  69
07FE:  MOVWF  x90
0800:  MOVLW  6E
0802:  MOVWF  x91
0804:  MOVLW  67
0806:  MOVWF  x92
0808:  MOVLW  6F
080A:  MOVWF  x93
080C:  CLRF   x94
080E:  CLRF   x95
0810:  CLRF   x98
0812:  CLRF   x99
0814:  CLRF   x9A
0816:  CLRF   x9B
0818:  CLRF   xA9
081A:  CLRF   xAA
081C:  MOVLW  01
081E:  MOVWF  xAB
0820:  MOVWF  xAC
0822:  MOVLW  0C
0824:  MOVWF  xAD
0826:  MOVLW  01
0828:  MOVWF  xAE
082A:  MOVWF  xAF
082C:  MOVWF  xB0
082E:  CLRF   xB1
....................    byte dia = 0x01, mes = 0x01, ano = 0x0C,  
....................          hora = 0x01, min = 0x01, sec = 0x01, dow = 0x00;  
....................    setup_devices(); 
0830:  BRA    0450
....................    ds1307_set_date_time(dia, mes, ano, dow, hora, min, sec); 
0832:  MOVFF  AB,B2
0836:  MOVFF  AC,B3
083A:  MOVFF  AD,B4
083E:  MOVFF  B1,B5
0842:  MOVFF  AE,B6
0846:  MOVFF  AF,B7
084A:  MOVFF  B0,B8
084E:  BRA    0488
....................    // TODO: USER CODE!!   
....................    while(1){ 
....................       ds1307_get_date(dia, mes, ano, dow); 
....................       printf("fecha: %u/%u/%u dow: %u \n\r",dia, mes, ano, dow); 
*
0928:  MOVLW  C6
092A:  MOVWF  FF6
092C:  MOVLW  00
092E:  MOVWF  FF7
0930:  MOVLW  07
0932:  MOVWF  xB2
0934:  RCALL  055C
0936:  MOVFF  AB,B2
093A:  MOVLW  1B
093C:  MOVWF  xB3
093E:  RCALL  05A4
0940:  MOVLW  2F
0942:  BTFSS  F9E.4
0944:  BRA    0942
0946:  MOVWF  FAD
0948:  MOVFF  AC,B2
094C:  MOVLW  1B
094E:  MOVWF  xB3
0950:  RCALL  05A4
0952:  MOVLW  2F
0954:  BTFSS  F9E.4
0956:  BRA    0954
0958:  MOVWF  FAD
095A:  MOVFF  AD,B2
095E:  MOVLW  1B
0960:  MOVWF  xB3
0962:  RCALL  05A4
0964:  MOVLW  D5
0966:  MOVWF  FF6
0968:  MOVLW  00
096A:  MOVWF  FF7
096C:  MOVLW  06
096E:  MOVWF  xB2
0970:  RCALL  055C
0972:  MOVFF  B1,B2
0976:  MOVLW  1B
0978:  MOVWF  xB3
097A:  RCALL  05A4
097C:  MOVLW  20
097E:  BTFSS  F9E.4
0980:  BRA    097E
0982:  MOVWF  FAD
0984:  MOVLW  0A
0986:  BTFSS  F9E.4
0988:  BRA    0986
098A:  MOVWF  FAD
098C:  MOVLW  0D
098E:  BTFSS  F9E.4
0990:  BRA    098E
0992:  MOVWF  FAD
....................       delay_ms(99); 
0994:  MOVLW  63
0996:  MOVWF  xB3
0998:  RCALL  0610
....................       ds1307_get_time(hora, min, sec); 
....................       printf("hora: %u:%u:%u\n\r", hora, min, sec); 
*
0A5E:  MOVLW  E2
0A60:  MOVWF  FF6
0A62:  MOVLW  00
0A64:  MOVWF  FF7
0A66:  MOVLW  06
0A68:  MOVWF  xB2
0A6A:  RCALL  055C
0A6C:  MOVFF  AE,B2
0A70:  MOVLW  1B
0A72:  MOVWF  xB3
0A74:  RCALL  05A4
0A76:  MOVLW  3A
0A78:  BTFSS  F9E.4
0A7A:  BRA    0A78
0A7C:  MOVWF  FAD
0A7E:  MOVFF  AF,B2
0A82:  MOVLW  1B
0A84:  MOVWF  xB3
0A86:  RCALL  05A4
0A88:  MOVLW  3A
0A8A:  BTFSS  F9E.4
0A8C:  BRA    0A8A
0A8E:  MOVWF  FAD
0A90:  MOVFF  B0,B2
0A94:  MOVLW  1B
0A96:  MOVWF  xB3
0A98:  RCALL  05A4
0A9A:  MOVLW  0A
0A9C:  BTFSS  F9E.4
0A9E:  BRA    0A9C
0AA0:  MOVWF  FAD
0AA2:  MOVLW  0D
0AA4:  BTFSS  F9E.4
0AA6:  BRA    0AA4
0AA8:  MOVWF  FAD
....................       delay_ms(900); 
0AAA:  MOVLW  04
0AAC:  MOVWF  xB2
0AAE:  MOVLW  E1
0AB0:  MOVWF  xB3
0AB2:  RCALL  0610
0AB4:  DECFSZ xB2,F
0AB6:  BRA    0AAE
....................    } 
0AB8:  BRA    0850
.................... } 
....................  
....................  
.................... #include "Nucleo.h" 
.................... /* 
0ABA:  SLEEP 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "accelerometro.h"  
....................  
.................... #ifndef ACCELEROMETRO_H 
....................  
.................... #define ACCELEROMETRO_H 
....................  
.................... #define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB 
.................... #define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB 
.................... #define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB 
.................... #define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB 
.................... #define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB 
.................... #define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB 
.................... #define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits 
.................... #define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits 
.................... #define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits 
.................... #define MMA7455_STATUS 0x09     // Read only, Status Register 
.................... #define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register 
.................... #define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional) 
.................... #define MMA7455_RESERVED1 0x0C  // Reserved 
.................... #define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address 
.................... #define MMA7455_USRINF 0x0E     // Read only, User Information (Optional) 
.................... #define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional) 
.................... #define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB 
.................... #define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB 
.................... #define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB 
.................... #define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB 
.................... #define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB 
.................... #define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB 
.................... #define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register 
.................... #define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset 
.................... #define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register 
.................... #define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register 
.................... #define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value 
.................... #define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value 
.................... #define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value 
.................... #define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses) 
.................... #define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value 
.................... #define MMA7455_RESERVED2 0x1F  // Reserved 
....................  
.................... // Defines for the bits, to be able to change  
.................... // between bit number and binary definition. 
.................... // By using the bit number, programming the MMA7455  
.................... // is like programming an AVR microcontroller. 
.................... // But instead of using "(1<<X)", or "_BV(X)",  
.................... // the Arduino "bit(X)" is used. 
.................... #define MMA7455_D0 0x01 //0 
.................... #define MMA7455_D1 0x02 //1 
.................... #define MMA7455_D2 0x04 //2 
.................... #define MMA7455_D3 0x08 //3 
.................... #define MMA7455_D4 0x10 //4 
.................... #define MMA7455_D5 0x20 //5 
.................... #define MMA7455_D6 0x40 //6 
.................... #define MMA7455_D7 0x80 //7 
....................  
.................... // Status Register 
.................... #define MMA7455_DRDY MMA7455_D0 
.................... #define MMA7455_DOVR MMA7455_D1 
.................... #define MMA7455_PERR MMA7455_D2 
....................  
.................... // Mode Control Register 
.................... #define MMA7455_MODE0 MMA7455_D0 
.................... #define MMA7455_MODE1 MMA7455_D1 
.................... #define MMA7455_GLVL0 MMA7455_D2 
.................... #define MMA7455_GLVL1 MMA7455_D3 
.................... #define MMA7455_STON MMA7455_D4 
.................... #define MMA7455_SPI3W MMA7455_D5 
.................... #define MMA7455_DRPD MMA7455_D6 
....................  
.................... // Control 1 Register 
.................... #define MMA7455_INTPIN MMA7455_D0 
.................... #define MMA7455_INTREG0 MMA7455_D1 
.................... #define MMA7455_INTREG1 MMA7455_D2 
.................... #define MMA7455_XDA MMA7455_D3 
.................... #define MMA7455_YDA MMA7455_D4 
.................... #define MMA7455_ZDA MMA7455_D5 
.................... #define MMA7455_THOPT MMA7455_D6 
.................... #define MMA7455_DFBW MMA7455_D7 
....................  
.................... // Control 2 Register 
.................... #define MMA7455_LDPL MMA7455_D0 
.................... #define MMA7455_PDPL MMA7455_D1 
.................... #define MMA7455_DRVO MMA7455_D2 
....................  
.................... // Interrupt Latch Reset Register 
.................... #define MMA7455_CLR_INT1 MMA7455_D0 
.................... #define MMA7455_CLR_INT2 MMA7455_D1 
....................  
.................... // Detection Source Register 
.................... #define MMA7455_INT1 MMA7455_D0 
.................... #define MMA7455_INT2 MMA7455_D1 
.................... #define MMA7455_PDZ MMA7455_D2 
.................... #define MMA7455_PDY MMA7455_D3 
.................... #define MMA7455_PDX MMA7455_D4 
.................... #define MMA7455_LDZ MMA7455_D5 
.................... #define MMA7455_LDY MMA7455_D6 
.................... #define MMA7455_LDX MMA7455_D7 
....................  
.................... // I2C Device Address Register 
.................... #define MMA7455_I2CDIS MMA7455_D7 
....................  
.................... // Default I2C address for the MMA7455 
.................... #define MMA7455_I2C_ADDRESS 0x1D 
.................... //#define MMA7455_I2C_ADDRESS_READ 0X3B 
.................... #define MMA7455_I2C_ADDRESS_READ 0XA1 
.................... //#define MMA7455_I2C_ADDRESS_WRITE 0X3A 
.................... #define MMA7455_I2C_ADDRESS_WRITE 0XA0 
....................  
.................... // When using an union for the registers and 
.................... // the axis values, the byte order of the accelerometer 
.................... // should match the byte order of the compiler and AVR chip. 
.................... // Both have the lower byte at the lower address, 
.................... // so they match. 
.................... // This union is only used by the low level functions. 
.................... typedef union  
.................... { 
....................   struct 
....................   { 
....................     unsigned int8 x_lsb; 
....................     unsigned int8 x_msb; 
....................     unsigned int8 y_lsb; 
....................     unsigned int8 y_msb; 
....................     unsigned int8 z_lsb; 
....................     unsigned int8 z_msb; 
....................   } reg; 
....................   struct 
....................   { 
....................     int x; 
....................     int y; 
....................     int z; 
....................   } value; 
.................... } xyz_union; 
....................  
.................... typedef struct  
.................... { 
....................    /* data */ 
....................    unsigned int8 MODE_CONTROL; 
....................    unsigned int8 CONTROL_1; 
....................    unsigned int8 CONTROL_2; 
....................  
....................    int8 XOFFL; 
....................    int8 XOFFH; 
....................    int8 YOFFL; 
....................    int8 YOFFH; 
....................    int8 ZOFFL; 
....................    int8 ZOFFH;/*,//no implemntado 
....................    char _LEVEL_DETECTION_THREHOLDS; 
....................    char _PULSE_DETECTION_THREHOLDS; 
....................    char _PULSE_DURATION; 
....................    char _LANTENCY_TIME; 
....................    char _TIME_WINDOWS; 
....................    */ 
.................... } CONFIG_MMA7455; 
....................  
.................... //configuracion incial del MMA7455 
.................... int init_MMA(void); 
....................  
.................... //recalibra el offset del MMA7455 
.................... int calibrate_MMA(void); 
....................  
.................... //cambio de configuracion del MMA7455 
.................... void set_config(*CONFIG_MMA7455); 
....................  
.................... //Lectura de los valores de x y z 
.................... int xyz_MMA( int *pX, int *pY, int *pZ); 
....................  
.................... //Lectura de datosd desde el MMA7455 
.................... int read_MMA(unsigned char address, int8 *value); 
.................... int read_MMA(unsigned char start_address, int8 *buffer,int size); 
....................  
.................... //Escritura de datos en el MMA7455 
.................... int write_MMA(unsigned char address, int8 *value); 
.................... int write_MMA(unsigned char start_address, int8 *pData, int size); 
....................  
.................... #define testmma 
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready(); 
.................... #endif 
.................... #endif 
....................  
.................... /* 
.................... DEFINICIONES: 
.................... MOV = deteccion de movimiento 
.................... CL = deteccion de caida libre 
....................  
.................... Initialize the sensor 
.................... Sensitivity: 
....................   2g : GLVL0 
....................   4g : GLVL1 
....................   8g : GLVL1 | GLVL0 
.................... Mode: 
....................   Standby         : 0 
....................   Measurement     : MODE0 
....................   Level Detection : MODE1 
....................   Pulse Detection : MODE1 | MODE0 
....................  
.................... tabla 1: configuracion de INTRG 
.................... ------------------------ 
.................... INT2TRG      INT1   INT2 
.................... 00         LD       PD 
.................... 01         PD       LD 
.................... 10         sPD     dPD 
.................... ------------------------ 
....................  
.................... tabla2: configuracion de pines de interrupciones 
.................... ------------------- 
.................... INTPIN 
.................... 0       INT1bit  --> INT1pin, INT2bit  --> INT2pin 
.................... 1       INT1bit  --> INT2pin, INT2bit  --> INT1pin 
.................... ------------------- 
.................... */ 
....................  
....................  
.................... CONFIG_MMA7455 CONFIG = {1,2,3,128,128,128,128,128,128}; 
.................... //configuracion inicial del MMA7455 
.................... int init_MMA(void){ 
....................   int error = 0; 
....................   xyz_union xyz; 
....................   unsigned int8 c1 = 0, c2 = 0; 
....................    
....................   //mode: measurement; sensitivity: 4g 
....................   c1 = MMA7455_GLVL1 | MMA7455_MODE0; 
....................   error = write_MMA(MMA7455_MCTL, &c1);       //escribe la configuracion deseada en el accelerometro 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //lee la configuracion del accelerometro para comprobar el envio 
....................   error = read_MMA(MMA7455_MCTL, &c2); 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //se comprueban la conincidencia entre lo enviado y lo recivido 
....................   if (c1 != c2) 
....................     return (-99);                 //retorna -99 si no cinciden 
....................   else 
....................     CONFIG.MODE_CONTROL =  c2;    //se respalda la configuracion en el micro 
....................  
....................   //se configura el offset de los ejes a 0 
....................   xyz.value.x = xyz.value.y = xyz.value.z = 0; 
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   delay_ms(100);                  //espera 100 mls para hasta se hayan escrito todos lso datos 
....................   return 0; 
.................... } 
....................  
.................... /** 
.................... para la calibracion de los ejes se supone que este 
.................... en una posicion nivelada horizontalmente evitando posible vibraciones 
.................... */ 
.................... int calibrate_MMA(void){ 
....................   int x, y, z, error = 0; 
....................   xyz_union xyz; 
....................   unsigned int8 c1 = 0, c2 = 0; 
....................  
....................   c1 = (CONFIG.MODE_CONTROL & (MMA7455_GLVL1|MMA7455_GLVL0));   //selecciona los bit de GLVL 
....................   if(c1 == (MMA7455_GLVL0 | MMA7455_GLVL1)){  // si es 8g 
....................     c2 = 16; 
....................   }else if(c1 == MMA7455_GLVL1){ //si es 4g 
....................     c2 = 32; 
....................   }else if(c1 == MMA7455_GLVL0){ //si es 2g 
....................     c2 = 64; 
....................   }else{ 
....................     c2 = 64;  //por defecto 2g 
....................   } 
....................  
....................   error = xyz_MMA(&x, &y, &z);    //se leen los valores de los ejes 
....................   if (error != 0) 
....................     return (error); 
....................    
....................   //calcula offset para el ajuste a 0 de los ejes 
....................   xyz.value.x = 2 * -x;         
....................   xyz.value.y = 2 * -y; 
....................   xyz.value.z = 2 * -(z-c2); 
....................  
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6);  //se envia el offset al accelerometro 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   delay_ms(200); 
....................    
....................   error = xyz_MMA(&x, &y, &z); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   //realiza nuevamente la operacion para el reajuste 
....................   xyz.value.x = 2 * -x;         
....................   xyz.value.y = 2 * -y; 
....................   xyz.value.z = 2 * -(z-c2); 
....................  
....................   error = write_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   //leen los datos enviados al accelerometro para almacenarlos en el microcontrolador 
....................   error = read_MMA(MMA7455_XOFFL, (unsigned int8 *) &xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   CONFIG.XOFFL = xyz.reg.x_lsb; 
....................   CONFIG.XOFFH = xyz.reg.x_msb; 
....................   CONFIG.YOFFL = xyz.reg.x_lsb; 
....................   CONFIG.YOFFH = xyz.reg.x_msb; 
....................   CONFIG.ZOFFL = xyz.reg.x_lsb; 
....................   CONFIG.ZOFFH = xyz.reg.x_msb; 
....................  
....................   return 0; 
.................... } 
....................  
.................... void set_config(*CONFIG_MMA7455){ 
....................  return; 
.................... }// cambiar la configuracion incicial (del SPI y/o MMA) 
....................  
....................  
.................... int xyz_MMA( int *pX, int *pY, int *pZ){ 
....................   xyz_union xyz; 
....................   int error = 0; 
....................   unsigned int8 c; 
....................  
....................   do{ 
....................  
....................     error = read_MMA(MMA7455_STATUS,&c); 
....................   }while(!bit_test(c, 0) && error == 0); 
....................    
....................   if (error != 0) 
....................     return (error); 
....................  
....................   error = read_MMA(MMA7455_XOUTL, (unsigned int8 *)&xyz, 6); 
....................   if (error != 0) 
....................     return (error); 
....................  
....................   // The output is 10-bits and could be negative. 
....................   // To use the output as a 16-bit signed integer, 
....................   // the sign bit (bit 9) is extended for the 16 bits. 
....................   if (xyz.reg.x_msb & 0x02)    // Bit 9 is sign bit. 
....................     xyz.reg.x_msb |= 0xFC;     // Stretch bit 9 over other bits. 
....................   if (xyz.reg.y_msb & 0x02) 
....................     xyz.reg.y_msb |= 0xFC; 
....................   if (xyz.reg.z_msb & 0x02) 
....................     xyz.reg.z_msb |= 0xFC; 
....................  
....................   // The result is the g-force in units of 64 per 'g'. 
....................   *pX = xyz.value.x; 
....................   *pY = xyz.value.y; 
....................   *pZ = xyz.value.z; 
....................  
....................   return 0; 
.................... } 
.................... /*///////////////////////////////////////////// 
.................... read_MMA(): funcion para la lectura de datos desde el accelerometro MMA7455 
....................             hasta el dispositivo maestro 
.................... parametros: 
....................   start: direccion de inicial desde se realizara la lectura 
....................   buffer: buffer de almacenamiento de los datos leidos 
....................   size: cantidad de bytes a leer desde el esclavo 
....................  
.................... returna: 
....................   int: 0 no error,  
....................       1 error de inicio de transmision,  
....................       2 error de peticion de datos, 
....................       -11 error en la lectura desde el MMA  
.................... */ 
.................... int read_MMA(unsigned char address, int8 *value){ 
....................   int error = 0; 
....................    //condicion de inicio de lectura en el MMA7455  
....................   #ifdef testmma 
....................   while(!ext_eeprom_ready()); 
....................   #endif 
....................  
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(address);                     //envia el registro inicial de lectura del MMA 
....................   if(error!=0){return 1;}                         //si existe un error sale de la funcion 
....................    
....................   //peticion de datos desde el MMA7455 
....................   i2c_start();                                    //seal de restart del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_READ);    //se envia la direccion del MMA7455 con lectura   
....................   if(error!=0){return 2;} 
....................   #ifndef testmma  
....................   while(!i2c_poll()); 
....................   #endif 
....................   *value = i2c_read(0); 
....................   i2c_stop(); 
....................   return 0; 
.................... } 
....................  
.................... int read_MMA(unsigned char start_address, unsigned int8 *buffer,int size){ 
....................   int error = 0, i = 0; 
....................   int1 ack = 1; 
....................    
....................   #ifdef testmma 
....................   while(!ext_eeprom_ready()); 
....................   #endif 
....................  
....................   //condicion de inicio de lectura en el MMA7455  
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(start_address);               //envia el registro inicial de lectura del MMA 
....................   if(error!=0){return 1;}                         //si existe un error sale de la funcion 
....................    
....................   //peticion de datos desde el MMA7455 
....................   i2c_start();                                    //seal de restart del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_READ);    //se envia la direccion del MMA7455 con lectura   
....................   if(error!=0){return 2;}                         //si error en reques sale de la funcion 
....................  
....................   i = 0; 
....................   ack = 1; 
....................   while(i2c_poll() && i<size){                    //espera minetras llega un dato desde el MMA7455 
....................     if((i+1) >= size){ack = 0;}                   //si es el ultimo byte envia NACK 
....................     buffer[i++]=i2c_read(ack);                    //lee un byte del bus i2c y envia un ACK 
....................   } 
....................  
....................   i2c_stop();                                     //seal de stop en el bus i2c 
....................    
....................   if ( i != size){return (3);}                    //retorna 3 si no se completo la lectura 
....................    
....................   return (0);   //retorna 0 si succed 
.................... } //leer datos desde el mma 
....................  
....................  
.................... int write_MMA(unsigned char address, int8 *value){ 
....................   int error = 0; 
....................   //condicion de inicio de escritura en el MMA7455 
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(address);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 1;} 
....................   error = i2c_write(*value);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 2;} 
....................   i2c_stop(); 
....................   return 0; 
.................... } 
....................  
....................  
.................... int write_MMA(unsigned char start_address, int8 *pData, int size){ 
....................   int error = 0, i = 0; 
....................   int1 ack = 0; 
....................  
....................   //condicion de inicio de escritura en el MMA7455 
....................   i2c_start();                                    //seal de start del bus i2c 
....................   error = i2c_write(MMA7455_I2C_ADDRESS_WRITE);   //se envia la direccion del MMA7455 con escritura 
....................    
....................   //////////////////////// 
....................   #ifdef testmma 
....................   i2c_write(0); 
....................   #endif 
....................   //////////////////////// 
....................   error = i2c_write(start_address);               //envia el registro inicial de escritura del MMA 
....................   if(error!=0){return 1;}                         //si error en reques sale de la funcion 
....................    
....................   do{ 
....................     ack = i2c_write(pData[i++]);                  //escribe un byte y espera un ACK 
....................   }while(ack == 0 && i < size); 
....................    
....................   i2c_stop(); 
....................   if(i != size){return 2;}                        //si no se completo la escritura retorna error 2 
....................   return 0;                                       //retorna 0 si succed 
.................... } //escribir datos desde el mma 
....................  
.................... #ifdef testmma 
.................... int1 ext_eeprom_ready() { 
....................   int1 ack; 
....................   i2c_start();            // If the write command is acknowledged, 
....................   ack = i2c_write(0xa0);  // then the device is ready. 
....................   i2c_stop(); 
....................   return !ack; 
.................... } 
.................... #endif 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "memoria.h" 
.................... #ifndef MEMORIA_H 
.................... #define MEMORIA_H 
....................  
.................... #define MAX_BUFFER 		100 
....................  
.................... #define INI_HW	0 
.................... #define INI_SW	1 
.................... #define OPEN	2 
.................... #define RD		3 
.................... #define GET		4 
.................... #define WR		5 
.................... #define SET		6 
.................... #define CLOSE	7 
....................  
.................... #define MEMORIA_CMD_AUTOBAUD	0x55 
.................... #define MEMORIA_CMD_VER_INFO	0x56 
.................... #define MEMORIA_CMD_FAT_PROTECT	0x59 
.................... #define MEMORIA_CMD_INITIALIZE	0x69 
....................  
.................... #define MEMORIA_EXT_CMD			0x40 
.................... #define MEMORIA_CMD_READ_FILE	0x61 
.................... #define MEMORIA_CMD_WRITE_FILE	0x74 
....................  
.................... #define MEMORIA_FAT_VALUE	0x08 
....................  
.................... #define MEMORIA_ACK 		0x06 
.................... #define MEMORIA_NOACK		0x15 
....................  
.................... #define MEMORIA_ON 			0x01 
.................... #define MEMORIA_OFF 		0x00 
....................  
.................... #define MEMORIA_NAME_LENG_LIMIT	12 
.................... #define MEMORIA_NAME_TERMINATOR 0x00 
.................... #define MEMORIA_DELIMITADOR 	0x0a 
....................  
.................... #define MEMORIA_NO_APPEND 	0X00 
.................... #define MEMORIA_APPEND 		0X80 
....................  
.................... #define MEMORIA_NO_HANDSHAKING 		0x00 
.................... #define MEMORIA_DEFAULT_HANDSHAKING 0X01 
.................... #define MEMORIA_MAX_HANDSHAKING		0x32 
....................  
.................... #define MEMORIA_HIGH_PERFORMANCE 	0x00 
.................... #define MEMORIA_LOW_PERFORMANCE 	0x40 
.................... //#define MEMORIA_OUT_TIME	65535	//modificar para colocar tiempos mas largos 
.................... //#define MEMORIA_COMPROBAR_ARCHIVO 
....................  
.................... int MEMORIA_reset(void); 
.................... int MEMORIA_init_hw(void); 
.................... int MEMORIA_init(void); 
.................... int MEMORIA_open(char *filename, char modo); 
.................... int MEMORIA_cancel(void); 
.................... int MEMORIA_write(unsigned int size); 
.................... int MEMORIA_set_data(char *data, unsigned int size); 
.................... char MEMORIA_putc(char c); 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes); 
.................... int MEMORIA_get_data(char *buffer); 
.................... int MEMORIA_close(void); 
.................... int MEMORIA_is_busy(void); 
.................... char MEMORIA_getc(void); 
.................... #endif 
....................  
.................... #use rs232(stream=MEMORIA,baud=9600,parity=N,xmit=PIN_D6,rcv=PIN_D7,bits=8,FORCE_SW,DISABLE_INTS) 
....................  
.................... short MEMORIA_OK = FALSE; 
.................... short MEMORIA_HW = FALSE; 
.................... short timeout_error = FALSE; 
.................... int MEM_proceso = INI_HW; 
.................... unsigned int i = 0; 
.................... unsigned int car = 0; 
.................... unsigned long time_delay = 50000; 
.................... int16 MEMORIA_PIN_RESET = PIN_D5; 
.................... unsigned int32 tamano = 0; 
.................... char MEM_info[5] = {0x00,0x00,0x00,0x00,0x00}; 
.................... char MEM_file_name[MEMORIA_NAME_LENG_LIMIT]; 
.................... char MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
.................... char MEM_append = MEMORIA_APPEND; 
.................... char MEM_performance = MEMORIA_HIGH_PERFORMANCE; 
.................... char MEM_RESPONSE = MEMORIA_NOACK; 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_reset(void){ 
....................    output_low(MEMORIA_PIN_RESET); 
....................    delay_ms(5); 
....................    return (MEMORIA_init_hw()); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_init_hw(void){ 
....................    output_float(MEMORIA_PIN_RESET); 
....................    MEMORIA_HW = TRUE; 
....................    MEMORIA_OK = FALSE; 
....................    MEM_info[0] = 0x00; 
....................    MEM_info[1] = 0x00; 
....................    MEM_info[2] = 0x00; 
....................    MEM_info[3] = 0x00; 
....................    MEM_info[4] = 0x00; 
....................    MEM_proceso = INI_SW; 
....................    return (0); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_init(void){ 
....................  
....................    if(!MEMORIA_HW || MEM_proceso != INI_SW) 
....................       return (-1); 
....................  
....................    delay_ms(550); 
....................    fputc(MEMORIA_CMD_AUTOBAUD,MEMORIA);   
....................    MEM_RESPONSE = MEMORIA_getc(); 
....................    if(((MEM_RESPONSE == 0) && timeout_error)||(MEM_RESPONSE != MEMORIA_ACK)){ 
....................       return (1); 
....................    } 
....................  
....................    fputc(MEMORIA_CMD_INITIALIZE,MEMORIA); 
....................    MEM_RESPONSE = MEMORIA_getc(); 
....................    if(((MEM_RESPONSE == 0) && timeout_error)||(MEM_RESPONSE != MEMORIA_ACK)){ 
....................       return (2); 
....................    }else{ 
....................       MEMORIA_OK = TRUE; 
....................    } 
....................  
....................    fputc(MEMORIA_CMD_VER_INFO, MEMORIA); 
....................    MEM_info[0] = MEMORIA_getc(); 
....................    MEM_info[1] = MEMORIA_getc(); 
....................    MEM_info[2] = MEMORIA_getc(); 
....................    MEM_info[3] = MEMORIA_getc(); 
....................    MEM_info[4] = MEMORIA_getc(); 
....................  
....................    MEM_proceso = OPEN; 
....................    return (0); 
.................... }      //inicializa el dispositivo 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_open(char *filename, char modo){ 
....................    unsigned int ncar =0; 
....................  
....................    if(!MEMORIA_OK || MEM_proceso != OPEN){ 
....................       return(-1); 
....................    } 
....................  
....................    if(modo == 'r') 
....................       MEM_proceso = RD; 
....................    else if(modo == 'w') 
....................       MEM_proceso = WR; 
....................    else 
....................       return(-1); 
....................     
....................    ncar = strlen(filename); 
....................    car = (ncar <= MEMORIA_NAME_LENG_LIMIT)? ncar : MEMORIA_NAME_LENG_LIMIT; 
....................    strncpy(MEM_file_name, filename, car); 
....................    i = 0; 
....................    timeout_error = FALSE; 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    MEM_RESPONSE = MEMORIA_NOACK;    
....................    return (0); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_cancel(void){ 
....................  
....................    if((MEM_proceso != GET) || (MEM_proceso != SET)){ 
....................       return(-1); 
....................    } 
....................  
....................    if(MEM_proceso == GET){ 
....................       fputc(MEMORIA_NOACK, MEMORIA); 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................    } 
....................  
....................    if(MEM_proceso == SET){ 
....................       while(tamano > 0 ){ 
....................          fputc(0x00,MEMORIA); 
....................          --tamano; 
....................       } 
....................    } 
....................  
....................    tamano = 0; 
....................    MEM_proceso = OPEN; 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    return (0); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_write(unsigned int size){ 
....................     
....................    if(!MEMORIA_OK || MEM_proceso != WR) 
....................       return(1); 
....................     
....................    //buffer maximo de 100 bytes 
....................    if((size > 0) && (size <= MAX_BUFFER)) 
....................       MEM_handshaking = MEMORIA_NO_HANDSHAKING; 
....................    else 
....................       return (2); 
....................     
....................    tamano = (unsigned int32)size; 
....................    fputc(MEMORIA_EXT_CMD,MEMORIA); 
....................    fputc(MEMORIA_CMD_WRITE_FILE,MEMORIA); 
....................    fputc((MEM_handshaking|MEM_append|MEM_performance),MEMORIA); 
....................     
....................    for(i =0; (i < MEMORIA_NAME_LENG_LIMIT) && (i < car);i++) 
....................       fputc(MEM_file_name[i],MEMORIA); 
....................  
....................    fputc(0x00,MEMORIA); 
....................  
....................    fputc(make8(tamano,3),MEMORIA); 
....................    fputc(make8(tamano,2),MEMORIA); 
....................    fputc(make8(tamano,1),MEMORIA); 
....................    fputc(make8(tamano,0),MEMORIA); 
....................  
....................    MEM_RESPONSE = MEMORIA_getc(); 
....................    if((MEM_RESPONSE == 0) && timeout_error) 
....................       return (3); 
....................    if(MEM_RESPONSE != MEMORIA_ACK){ 
....................       return (4); 
....................    } 
....................    MEM_proceso = SET; 
....................    return (0); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_set_data(char *data, unsigned int size){ 
....................  
....................    if(!MEMORIA_OK || (MEM_proceso != SET) || (tamano <= 0)) 
....................       return(-1); 
....................  
....................    i = 0; 
....................    while((tamano > 0)&&(i < size)){ 
....................       fputc(data[i],MEMORIA); 
....................       i++; 
....................       tamano--; 
....................    } 
....................    //si no hay mas datos 
....................    if(tamano <= 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(((MEM_RESPONSE == 0) && timeout_error)||(MEM_RESPONSE != MEMORIA_ACK)){ 
....................          return (-1); 
....................       } 
....................       MEM_proceso = CLOSE; 
....................    } 
....................    return (i); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... char MEMORIA_putc(char c){ 
....................    fputc(c, MEMORIA); 
....................    if(MEM_handshaking == MEMORIA_DEFAULT_HANDSHAKING){ 
....................       return (MEMORIA_getc());    
....................    } 
....................    return (0);    
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... /////////////////////////////////////////////////////////// 
.................... unsigned int32 MEMORIA_read(unsigned int num_bytes){ 
....................    char Umsb = 0, Ulsb = 0, Lmsb = 0,Llsb = 0; 
....................  
....................    if(!MEMORIA_OK || (MEM_proceso != RD)){ 
....................       return(0); 
....................    } 
....................  
....................    if((num_bytes > 0) && (num_bytes <= MAX_BUFFER)) 
....................       MEM_handshaking = (char)num_bytes; 
....................    else 
....................       return (2); 
....................     
....................     
....................    fputc(MEMORIA_EXT_CMD,MEMORIA); 
....................    fputc(MEMORIA_CMD_READ_FILE,MEMORIA); 
....................    fputc(MEM_handshaking,MEMORIA); 
....................     
....................    for(i =0; (i < MEMORIA_NAME_LENG_LIMIT) && (i < car); ++i) 
....................       fputc(MEM_file_name[i],MEMORIA); 
....................  
....................    fputc(0x00,MEMORIA); 
....................  
....................    Umsb = MEMORIA_getc(); 
....................    if(!Umsb && timeout_error) return (0); 
....................    Ulsb = MEMORIA_getc(); 
....................    if(!Ulsb && timeout_error) return (0); 
....................    Lmsb = MEMORIA_getc(); 
....................    if(!Lmsb && timeout_error) return (0); 
....................    Llsb = MEMORIA_getc(); 
....................    if(!Llsb && timeout_error) return (0); 
....................  
....................    tamano = make32(Umsb,Ulsb,Lmsb,Llsb); 
....................    MEM_proceso = GET; 
....................    return (tamano);                                               
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... //funcion general para recivir datos desde la memoria 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_get_data(char *buffer){    
....................    char c; 
....................     
....................    if(!MEMORIA_OK || (MEM_proceso != GET) || (tamano <= 0)) 
....................       return(-1); 
....................  
....................    i = 0; 
....................    fputc(MEMORIA_ACK, MEMORIA);                                                  //envia un ACK para recivir nuevos datos 
....................    while((i < MEM_handshaking) && (tamano > 0 /*hay mas datos*/)){ 
....................       c = MEMORIA_getc(); 
....................        
....................       if(!c && timeout_error) 
....................          return (-1); 
....................        
....................       buffer[i] = c; 
....................       i++; 
....................       tamano--; 
....................    } 
....................  
....................    //si alcanzo el total de datos 
....................    if(tamano == 0){ 
....................       MEM_RESPONSE = MEMORIA_getc(); 
....................       if(((MEM_RESPONSE == 0) && timeout_error)||(MEM_RESPONSE != MEMORIA_ACK)){ 
....................          return (-1); 
....................       } 
....................       MEM_proceso = CLOSE; 
....................    } 
....................    return (i);    
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... //funcion general cerrar el actual archivo de trabajo 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_close(void){ 
....................  
....................    if(!MEMORIA_OK || (MEM_proceso != CLOSE)) 
....................       return (-1); 
....................  
....................    strcpy (MEM_file_name,""); 
....................    i = 0; 
....................    car = 0; 
....................    timeout_error = FALSE; 
....................    MEM_handshaking = MEMORIA_DEFAULT_HANDSHAKING; 
....................    MEM_RESPONSE = MEMORIA_NOACK; 
....................    MEM_proceso = OPEN; 
....................    return(0); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
.................... //funcion general para configurar las opciones de la memoria 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_set_param(unsigned int param, char *value, unsigned int size){return (0);} 
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... //funcion general para saber si la mmeoria esta actualmente en un proceso de trabajo 
.................... /////////////////////////////////////////////////////////// 
.................... int MEMORIA_is_busy(void){ 
....................    return ((MEM_proceso == OPEN )? 0 : 1); 
.................... }  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... //funcion general obtener un caracter trasmitido desde la memoria 
.................... /////////////////////////////////////////////////////////// 
.................... char MEMORIA_getc(void){ 
....................    long timeout; 
....................    timeout_error=FALSE; 
....................    timeout=0; 
....................    while(!kbhit()&&(++timeout < time_delay)) // 1/2 
....................       delay_us(time_delay); 
....................  
....................    if(kbhit()) 
....................       return(fgetc(MEMORIA)); 
....................    else { 
....................       timeout_error=TRUE; 
....................       return(0); 
....................    } 
.................... } 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef DS1307_H 
.................... #define DS1307_H 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_B0 
.................... #define RTC_SCL  PIN_B1 
.................... #endif 
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
....................  
.................... void ds1307_init(int val); 
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec); 
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow); 
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec); 
.................... char ds1307_read_nvram_byte(char addr); 
.................... void ds1307_write_nvram_byte(char addr, char value); 
.................... void ds1307_get_day_of_week(char* ptr); 
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
01F0:  MOVLW  08
01F2:  MOVWF  01
01F4:  MOVLW  07
01F6:  MOVWF  00
01F8:  DECFSZ 00,F
01FA:  BRA    01F8
01FC:  BCF    F8A.1
01FE:  BCF    F93.1
0200:  MOVLW  07
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  RLCF   xBA,F
020A:  BCF    F8A.0
020C:  BTFSC  FD8.0
020E:  BSF    F93.0
0210:  BTFSS  FD8.0
0212:  BCF    F93.0
0214:  BSF    F93.1
0216:  BTFSS  F81.1
0218:  BRA    0216
021A:  DECFSZ 01,F
021C:  BRA    01F4
021E:  MOVLW  07
0220:  MOVWF  00
0222:  DECFSZ 00,F
0224:  BRA    0222
0226:  BCF    F8A.1
0228:  BCF    F93.1
022A:  NOP   
022C:  BSF    F93.0
022E:  MOVLW  07
0230:  MOVWF  00
0232:  DECFSZ 00,F
0234:  BRA    0232
0236:  MOVLW  07
0238:  MOVWF  00
023A:  DECFSZ 00,F
023C:  BRA    023A
023E:  BSF    F93.1
0240:  BTFSS  F81.1
0242:  BRA    0240
0244:  CLRF   01
0246:  MOVLW  07
0248:  MOVWF  00
024A:  DECFSZ 00,F
024C:  BRA    024A
024E:  BTFSC  F81.0
0250:  BSF    01.0
0252:  BCF    F8A.1
0254:  BCF    F93.1
0256:  BCF    F8A.0
0258:  BCF    F93.0
025A:  RETLW  00
025C:  MOVLW  08
025E:  MOVWF  xB7
0260:  MOVFF  00,B8
0264:  BSF    F93.0
0266:  MOVLW  07
0268:  MOVWF  00
026A:  DECFSZ 00,F
026C:  BRA    026A
026E:  BSF    F93.1
0270:  BTFSS  F81.1
0272:  BRA    0270
0274:  BTFSC  F81.0
0276:  BSF    FD8.0
0278:  BTFSS  F81.0
027A:  BCF    FD8.0
027C:  RLCF   01,F
027E:  MOVLW  07
0280:  MOVWF  00
0282:  DECFSZ 00,F
0284:  BRA    0282
0286:  BCF    F93.1
0288:  BCF    F8A.1
028A:  DECFSZ xB7,F
028C:  BRA    0264
028E:  BSF    F93.0
0290:  MOVLW  07
0292:  MOVWF  00
0294:  DECFSZ 00,F
0296:  BRA    0294
0298:  BCF    F8A.0
029A:  MOVF   xB8,W
029C:  BTFSS  FD8.2
029E:  BCF    F93.0
02A0:  NOP   
02A2:  BSF    F93.1
02A4:  BTFSS  F81.1
02A6:  BRA    02A4
02A8:  MOVLW  07
02AA:  MOVWF  00
02AC:  DECFSZ 00,F
02AE:  BRA    02AC
02B0:  BCF    F8A.1
02B2:  BCF    F93.1
02B4:  MOVLW  07
02B6:  MOVWF  00
02B8:  DECFSZ 00,F
02BA:  BRA    02B8
02BC:  BCF    F8A.0
02BE:  BCF    F93.0
02C0:  RETLW  00
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
*
030C:  CLRF   xB4
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
030E:  BCF    FF2.6
0310:  BCF    FF2.7
0312:  BTFSC  FF2.7
0314:  BRA    0310
.................... #endif 
....................  
....................    i2c_start(); 
0316:  BSF    F93.0
0318:  MOVLW  07
031A:  MOVWF  00
031C:  DECFSZ 00,F
031E:  BRA    031C
0320:  BSF    F93.1
0322:  MOVLW  07
0324:  MOVWF  00
0326:  DECFSZ 00,F
0328:  BRA    0326
032A:  BCF    F8A.0
032C:  BCF    F93.0
032E:  MOVLW  07
0330:  MOVWF  00
0332:  DECFSZ 00,F
0334:  BRA    0332
0336:  BCF    F8A.1
0338:  BCF    F93.1
....................    i2c_write(0xD0); 
033A:  MOVLW  D0
033C:  MOVWF  xBA
033E:  RCALL  01F0
....................    i2c_write(0x00); 
0340:  CLRF   xBA
0342:  RCALL  01F0
....................    i2c_start(); 
0344:  BSF    F93.0
0346:  MOVLW  07
0348:  MOVWF  00
034A:  DECFSZ 00,F
034C:  BRA    034A
034E:  BSF    F93.1
0350:  MOVLW  07
0352:  MOVWF  00
0354:  DECFSZ 00,F
0356:  BRA    0354
0358:  BTFSS  F81.1
035A:  BRA    0358
035C:  BCF    F8A.0
035E:  BCF    F93.0
0360:  MOVLW  07
0362:  MOVWF  00
0364:  DECFSZ 00,F
0366:  BRA    0364
0368:  BCF    F8A.1
036A:  BCF    F93.1
....................    i2c_write(0xD1); 
036C:  MOVLW  D1
036E:  MOVWF  xBA
0370:  RCALL  01F0
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
0372:  CLRF   00
0374:  RCALL  025C
0376:  MOVFF  01,B5
037A:  MOVFF  01,B7
037E:  RCALL  02C2
0380:  MOVFF  01,B4
....................    i2c_stop(); 
0384:  BCF    F93.0
0386:  NOP   
0388:  BSF    F93.1
038A:  BTFSS  F81.1
038C:  BRA    038A
038E:  MOVLW  07
0390:  MOVWF  00
0392:  DECFSZ 00,F
0394:  BRA    0392
0396:  BRA    0398
0398:  NOP   
039A:  BSF    F93.0
039C:  MOVLW  07
039E:  MOVWF  00
03A0:  DECFSZ 00,F
03A2:  BRA    03A0
....................    seconds &= 0x7F; 
03A4:  BCF    xB4.7
....................  
....................    delay_us(3); 
03A6:  MOVLW  05
03A8:  MOVWF  00
03AA:  DECFSZ 00,F
03AC:  BRA    03AA
03AE:  BRA    03B0
....................  
....................    i2c_start(); 
03B0:  BSF    F93.0
03B2:  MOVLW  07
03B4:  MOVWF  00
03B6:  DECFSZ 00,F
03B8:  BRA    03B6
03BA:  BSF    F93.1
03BC:  MOVLW  07
03BE:  MOVWF  00
03C0:  DECFSZ 00,F
03C2:  BRA    03C0
03C4:  BCF    F8A.0
03C6:  BCF    F93.0
03C8:  MOVLW  07
03CA:  MOVWF  00
03CC:  DECFSZ 00,F
03CE:  BRA    03CC
03D0:  BCF    F8A.1
03D2:  BCF    F93.1
....................    i2c_write(0xD0); 
03D4:  MOVLW  D0
03D6:  MOVWF  xBA
03D8:  RCALL  01F0
....................    i2c_write(0x00); 
03DA:  CLRF   xBA
03DC:  RCALL  01F0
....................    i2c_write(ds1307_bin2bcd(seconds)); 
03DE:  MOVFF  B4,B9
03E2:  RCALL  02E8
03E4:  MOVFF  01,B5
03E8:  MOVFF  01,BA
03EC:  RCALL  01F0
....................    i2c_start(); 
03EE:  BSF    F93.0
03F0:  MOVLW  07
03F2:  MOVWF  00
03F4:  DECFSZ 00,F
03F6:  BRA    03F4
03F8:  BSF    F93.1
03FA:  MOVLW  07
03FC:  MOVWF  00
03FE:  DECFSZ 00,F
0400:  BRA    03FE
0402:  BTFSS  F81.1
0404:  BRA    0402
0406:  BCF    F8A.0
0408:  BCF    F93.0
040A:  MOVLW  07
040C:  MOVWF  00
040E:  DECFSZ 00,F
0410:  BRA    040E
0412:  BCF    F8A.1
0414:  BCF    F93.1
....................    i2c_write(0xD0); 
0416:  MOVLW  D0
0418:  MOVWF  xBA
041A:  RCALL  01F0
....................    i2c_write(0x07); 
041C:  MOVLW  07
041E:  MOVWF  xBA
0420:  RCALL  01F0
....................    i2c_write(val); 
0422:  MOVFF  B3,BA
0426:  RCALL  01F0
....................    i2c_stop(); 
0428:  BCF    F93.0
042A:  NOP   
042C:  BSF    F93.1
042E:  BTFSS  F81.1
0430:  BRA    042E
0432:  MOVLW  07
0434:  MOVWF  00
0436:  DECFSZ 00,F
0438:  BRA    0436
043A:  BRA    043C
043C:  NOP   
043E:  BSF    F93.0
0440:  MOVLW  07
0442:  MOVWF  00
0444:  DECFSZ 00,F
0446:  BRA    0444
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0448:  MOVLW  C0
044A:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
044C:  GOTO   045A (RETURN)
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0488:  BCF    FF2.6
048A:  BCF    FF2.7
048C:  BTFSC  FF2.7
048E:  BRA    048A
.................... #endif 
....................  
....................   sec &= 0x7F; 
0490:  BCF    xB8.7
....................   hr &= 0x3F; 
0492:  MOVLW  3F
0494:  ANDWF  xB6,F
....................  
....................   i2c_start(); 
0496:  BSF    F93.0
0498:  MOVLW  07
049A:  MOVWF  00
049C:  DECFSZ 00,F
049E:  BRA    049C
04A0:  BSF    F93.1
04A2:  MOVLW  07
04A4:  MOVWF  00
04A6:  DECFSZ 00,F
04A8:  BRA    04A6
04AA:  BCF    F8A.0
04AC:  BCF    F93.0
04AE:  MOVLW  07
04B0:  MOVWF  00
04B2:  DECFSZ 00,F
04B4:  BRA    04B2
04B6:  BCF    F8A.1
04B8:  BCF    F93.1
....................   i2c_write(0xD0); 
04BA:  MOVLW  D0
04BC:  MOVWF  xBA
04BE:  RCALL  01F0
....................   i2c_write(0x00); 
04C0:  CLRF   xBA
04C2:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(sec)); 
04C4:  MOVFF  B8,B9
04C8:  RCALL  02E8
04CA:  MOVFF  01,B9
04CE:  MOVFF  01,BA
04D2:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(min)); 
04D4:  MOVFF  B7,B9
04D8:  RCALL  02E8
04DA:  MOVFF  01,B9
04DE:  MOVFF  01,BA
04E2:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(hr)); 
04E4:  MOVFF  B6,B9
04E8:  RCALL  02E8
04EA:  MOVFF  01,B9
04EE:  MOVFF  01,BA
04F2:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(dow)); 
04F4:  MOVFF  B5,B9
04F8:  RCALL  02E8
04FA:  MOVFF  01,B9
04FE:  MOVFF  01,BA
0502:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(day)); 
0504:  MOVFF  B2,B9
0508:  RCALL  02E8
050A:  MOVFF  01,B9
050E:  MOVFF  01,BA
0512:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(mth)); 
0514:  MOVFF  B3,B9
0518:  RCALL  02E8
051A:  MOVFF  01,B9
051E:  MOVFF  01,BA
0522:  RCALL  01F0
....................   i2c_write(ds1307_bin2bcd(year)); 
0524:  MOVFF  B4,B9
0528:  RCALL  02E8
052A:  MOVFF  01,B9
052E:  MOVFF  01,BA
0532:  RCALL  01F0
....................   i2c_stop(); 
0534:  BCF    F93.0
0536:  NOP   
0538:  BSF    F93.1
053A:  BTFSS  F81.1
053C:  BRA    053A
053E:  MOVLW  07
0540:  MOVWF  00
0542:  DECFSZ 00,F
0544:  BRA    0542
0546:  BRA    0548
0548:  NOP   
054A:  BSF    F93.0
054C:  MOVLW  07
054E:  MOVWF  00
0550:  DECFSZ 00,F
0552:  BRA    0550
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0554:  MOVLW  C0
0556:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
0558:  GOTO   0850 (RETURN)
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0850:  BCF    FF2.6
0852:  BCF    FF2.7
0854:  BTFSC  FF2.7
0856:  BRA    0852
.................... #endif 
....................  
....................   i2c_start(); 
0858:  BSF    F93.0
085A:  MOVLW  07
085C:  MOVWF  00
085E:  DECFSZ 00,F
0860:  BRA    085E
0862:  BSF    F93.1
0864:  MOVLW  07
0866:  MOVWF  00
0868:  DECFSZ 00,F
086A:  BRA    0868
086C:  BCF    F8A.0
086E:  BCF    F93.0
0870:  MOVLW  07
0872:  MOVWF  00
0874:  DECFSZ 00,F
0876:  BRA    0874
0878:  BCF    F8A.1
087A:  BCF    F93.1
....................   i2c_write(0xD0); 
087C:  MOVLW  D0
087E:  MOVWF  xBA
0880:  RCALL  01F0
....................   i2c_write(0x03); 
0882:  MOVLW  03
0884:  MOVWF  xBA
0886:  RCALL  01F0
....................   i2c_start(); 
0888:  BSF    F93.0
088A:  MOVLW  07
088C:  MOVWF  00
088E:  DECFSZ 00,F
0890:  BRA    088E
0892:  BSF    F93.1
0894:  MOVLW  07
0896:  MOVWF  00
0898:  DECFSZ 00,F
089A:  BRA    0898
089C:  BTFSS  F81.1
089E:  BRA    089C
08A0:  BCF    F8A.0
08A2:  BCF    F93.0
08A4:  MOVLW  07
08A6:  MOVWF  00
08A8:  DECFSZ 00,F
08AA:  BRA    08A8
08AC:  BCF    F8A.1
08AE:  BCF    F93.1
....................   i2c_write(0xD1); 
08B0:  MOVLW  D1
08B2:  MOVWF  xBA
08B4:  RCALL  01F0
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
08B6:  MOVLW  01
08B8:  MOVWF  00
08BA:  RCALL  025C
08BC:  MOVF   01,W
08BE:  ANDLW  7F
08C0:  MOVWF  xB2
08C2:  MOVWF  xB7
08C4:  RCALL  02C2
08C6:  MOVFF  01,B1
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
08CA:  MOVLW  01
08CC:  MOVWF  00
08CE:  RCALL  025C
08D0:  MOVF   01,W
08D2:  ANDLW  3F
08D4:  MOVWF  xB2
08D6:  MOVWF  xB7
08D8:  RCALL  02C2
08DA:  MOVFF  01,AB
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
08DE:  MOVLW  01
08E0:  MOVWF  00
08E2:  RCALL  025C
08E4:  MOVF   01,W
08E6:  ANDLW  1F
08E8:  MOVWF  xB2
08EA:  MOVWF  xB7
08EC:  RCALL  02C2
08EE:  MOVFF  01,AC
....................   year = ds1307_bcd2bin(i2c_read(0)); 
08F2:  CLRF   00
08F4:  RCALL  025C
08F6:  MOVFF  01,B2
08FA:  MOVFF  01,B7
08FE:  RCALL  02C2
0900:  MOVFF  01,AD
....................   i2c_stop(); 
0904:  BCF    F93.0
0906:  NOP   
0908:  BSF    F93.1
090A:  BTFSS  F81.1
090C:  BRA    090A
090E:  MOVLW  07
0910:  MOVWF  00
0912:  DECFSZ 00,F
0914:  BRA    0912
0916:  BRA    0918
0918:  NOP   
091A:  BSF    F93.0
091C:  MOVLW  07
091E:  MOVWF  00
0920:  DECFSZ 00,F
0922:  BRA    0920
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0924:  MOVLW  C0
0926:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
099A:  BCF    FF2.6
099C:  BCF    FF2.7
099E:  BTFSC  FF2.7
09A0:  BRA    099C
.................... #endif 
....................  
....................   i2c_start(); 
09A2:  BSF    F93.0
09A4:  MOVLW  07
09A6:  MOVWF  00
09A8:  DECFSZ 00,F
09AA:  BRA    09A8
09AC:  BSF    F93.1
09AE:  MOVLW  07
09B0:  MOVWF  00
09B2:  DECFSZ 00,F
09B4:  BRA    09B2
09B6:  BCF    F8A.0
09B8:  BCF    F93.0
09BA:  MOVLW  07
09BC:  MOVWF  00
09BE:  DECFSZ 00,F
09C0:  BRA    09BE
09C2:  BCF    F8A.1
09C4:  BCF    F93.1
....................   i2c_write(0xD0); 
09C6:  MOVLW  D0
09C8:  MOVWF  xBA
09CA:  RCALL  01F0
....................   i2c_write(0x00); 
09CC:  CLRF   xBA
09CE:  RCALL  01F0
....................   i2c_start(); 
09D0:  BSF    F93.0
09D2:  MOVLW  07
09D4:  MOVWF  00
09D6:  DECFSZ 00,F
09D8:  BRA    09D6
09DA:  BSF    F93.1
09DC:  MOVLW  07
09DE:  MOVWF  00
09E0:  DECFSZ 00,F
09E2:  BRA    09E0
09E4:  BTFSS  F81.1
09E6:  BRA    09E4
09E8:  BCF    F8A.0
09EA:  BCF    F93.0
09EC:  MOVLW  07
09EE:  MOVWF  00
09F0:  DECFSZ 00,F
09F2:  BRA    09F0
09F4:  BCF    F8A.1
09F6:  BCF    F93.1
....................   i2c_write(0xD1); 
09F8:  MOVLW  D1
09FA:  MOVWF  xBA
09FC:  CALL   01F0
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
0A00:  MOVLW  01
0A02:  MOVWF  00
0A04:  RCALL  025C
0A06:  MOVF   01,W
0A08:  ANDLW  7F
0A0A:  MOVWF  xB2
0A0C:  MOVWF  xB7
0A0E:  RCALL  02C2
0A10:  MOVFF  01,B0
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
0A14:  MOVLW  01
0A16:  MOVWF  00
0A18:  RCALL  025C
0A1A:  MOVF   01,W
0A1C:  ANDLW  7F
0A1E:  MOVWF  xB2
0A20:  MOVWF  xB7
0A22:  RCALL  02C2
0A24:  MOVFF  01,AF
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
0A28:  CLRF   00
0A2A:  RCALL  025C
0A2C:  MOVF   01,W
0A2E:  ANDLW  3F
0A30:  MOVWF  xB2
0A32:  MOVWF  xB7
0A34:  RCALL  02C2
0A36:  MOVFF  01,AE
....................   i2c_stop(); 
0A3A:  BCF    F93.0
0A3C:  NOP   
0A3E:  BSF    F93.1
0A40:  BTFSS  F81.1
0A42:  BRA    0A40
0A44:  MOVLW  07
0A46:  MOVWF  00
0A48:  DECFSZ 00,F
0A4A:  BRA    0A48
0A4C:  BRA    0A4E
0A4E:  NOP   
0A50:  BSF    F93.0
0A52:  MOVLW  07
0A54:  MOVWF  00
0A56:  DECFSZ 00,F
0A58:  BRA    0A56
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
0A5A:  MOVLW  C0
0A5C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
*
02E8:  MOVFF  B9,BA
....................   retval = 0; 
02EC:  CLRF   xBB
....................   while(1){ 
....................     if(temp >= 10){ 
02EE:  MOVF   xBA,W
02F0:  SUBLW  09
02F2:  BC    02FE
....................       temp -= 10; 
02F4:  MOVLW  0A
02F6:  SUBWF  xBA,F
....................       retval += 0x10; 
02F8:  MOVLW  10
02FA:  ADDWF  xBB,F
....................     }else{ 
02FC:  BRA    0304
....................       retval += temp; 
02FE:  MOVF   xBA,W
0300:  ADDWF  xBB,F
....................       break; 
0302:  BRA    0306
....................     } 
....................   } 
0304:  BRA    02EE
....................   return(retval); 
0306:  MOVFF  BB,01
.................... } 
030A:  RETLW  00
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
02C2:  MOVFF  B7,B8
....................   temp >>= 1; 
02C6:  BCF    FD8.0
02C8:  RRCF   xB8,F
....................   temp &= 0x78; 
02CA:  MOVLW  78
02CC:  ANDWF  xB8,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
02CE:  RRCF   xB8,W
02D0:  MOVWF  00
02D2:  RRCF   00,F
02D4:  MOVLW  3F
02D6:  ANDWF  00,F
02D8:  MOVF   00,W
02DA:  ADDWF  xB8,W
02DC:  MOVWF  xB9
02DE:  MOVF   xB7,W
02E0:  ANDLW  0F
02E2:  ADDWF  xB9,W
02E4:  MOVWF  01
.................... } 
02E6:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "captura_frecuencia.h" 
.................... #ifndef CAPTURA_FRECUENCIA 
.................... #define CAPTURA_FRECUENCIA 
.................... //canales de lectura 
.................... #define CANAL_1 1 
.................... #define CANAL_2 2 
....................  
.................... int CP_init_ccp(); 
.................... int CP_leer_ccp(int canal, int32 *buffer); 
.................... #endif 
....................  
.................... #ifndef REGISTROS_H 
....................    #include "registros.h" 
.................... #ifndef REGISTROS_H 
.................... #define REGISTROS_H 
....................  
.................... struct TOSU { 
....................    unsigned int TOSU:5; 
.................... } TOSU; 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFE 
....................  
.................... struct STKPTR { 
....................    unsigned int STKPTR:5; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTR; 
.................... #byte STKPTR = 0xFFC 
....................  
.................... struct PCLATU { 
....................    unsigned int PCU:5; 
.................... } PCLATU; 
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRU { 
....................    unsigned int TBLPTRU:5; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRU; 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF7 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF4 
....................  
.................... struct INTCON { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE:1; 
....................    unsigned int GIE:1; 
.................... } INTCON; 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2 { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG:1; 
....................    unsigned int INTEDG_2:1; 
....................    unsigned int INTEDG_3:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2; 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3 { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3; 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... struct FSR0H { 
....................    unsigned int FSR0H:4; 
.................... } FSR0H; 
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... struct FSR1H { 
....................    unsigned int FSR1H:4; 
.................... } FSR1H; 
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... struct BSR { 
....................    unsigned int BSR:4; 
.................... } BSR; 
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... struct FSR2H { 
....................    unsigned int FSR2H:4; 
.................... } FSR2H; 
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUS; 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD7 
....................  
.................... struct T0CON { 
....................    unsigned int T0PS:3; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CON; 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCON { 
....................    unsigned int SCS:2; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF:3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCON; 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct LVDCON { 
....................    unsigned int LVDL:4; 
....................    unsigned int LVDEN:1; 
....................    unsigned int BGST:1; 
.................... } LVDCON; 
.................... #byte LVDCON = 0xFD2 
....................  
.................... struct WDTCON { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCON; 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCON { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCON; 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCF 
....................  
.................... struct T1CON { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS:2; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CON; 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CON { 
....................    unsigned int T2CKPS:2; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CON; 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTAT { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTAT; 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1 { 
....................    unsigned int SSPM:4; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1; 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2 { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2; 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC4 
....................  
.................... struct ADCON0 { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0; 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1 { 
....................    unsigned int PCFG:4; 
....................    unsigned int VCFG:2; 
.................... } ADCON1; 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2 { 
....................    unsigned int ADCS:3; 
....................    unsigned int ACQT:3; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2; 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... ///////////////////////////// 
.................... //CCP 1 REGISTER 
.................... #word CCPR1 = 0xFBF 
....................  
.................... struct CCP1CON { 
....................    unsigned int CCP1M:4; 
....................    unsigned int DC1B:2; 
....................    unsigned int P1M:2; 
.................... } CCP1CON; 
.................... #byte CCP1CON = 0xFBD 
.................... ///////////////////////////// 
....................  
.................... ///////////////////////////// 
.................... //CCP 2 REGISTER 
.................... #word CCPR2 = 0xFBC 
.................... struct CCP2CON { 
....................    unsigned int CCP2M:4; 
....................    unsigned int DC2B:2; 
.................... } CCP2CON; 
.................... #byte CCP2CON = 0xFBA 
.................... //////////////////////////// 
....................  
.................... struct BAUDCON { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCMT:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON; 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CON { 
....................    unsigned int PDC:7; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CON; 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCPAS1 { 
....................    unsigned int PSSBD:2; 
....................    unsigned int PSSAC:2; 
....................    unsigned int ECCPAS:3; 
....................    unsigned int ECCPASE:1; 
.................... } ECCPAS1; 
.................... #byte ECCPAS1 = 0xFB6 
....................  
.................... struct CVRCON { 
....................    unsigned int CVR:4; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCON; 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCON { 
....................    unsigned int CM:3; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCON; 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB3 
....................  
.................... ///////////////////////////// 
.................... //TIMER 3 REGISTER 
.................... struct T3CON { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP:1; 
....................    unsigned int T3CKPS:2; 
....................    unsigned int T3CCP_2:1; 
....................    unsigned int RD16:1; 
.................... } T3CON; 
.................... #byte T3CON = 0xFB1 
.................... ///////////////////////////// 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTA { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA; 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTA { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA; 
.................... #byte RCSTA = 0xFAB 
....................  
.................... struct EEADRH { 
....................    unsigned int EEADRH:2; 
.................... } EEADRH; 
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1 { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1; 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2 { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int LVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2; 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2 { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int LVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2; 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2 { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int LVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2; 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1 { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1; 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1 { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1; 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1 { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1; 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNE { 
....................    unsigned int TUN:5; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int HF256DIV:1; 
.................... } OSCTUNE; 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISE { 
....................    unsigned int :4; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISE; 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISD { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISD; 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISC { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISC; 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISB { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISB; 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISA { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISA; 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATE { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATE; 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATD { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATD; 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATC { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATC; 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATB { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATB; 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATA { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATA; 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTE { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTE; 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTD { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTD; 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTC { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTC; 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTB { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTB; 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTA { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTA; 
.................... #byte PORTA = 0xF80 
....................  
.................... #endif 
....................  
.................... #endif 
.................... //tipos de capturas de los modulos CCP 
.................... int MODO_CCP1 = CCP_CAPTURE_RE; 
.................... int MODO_CCP2 = CCP_CAPTURE_RE; 
....................  
.................... /* 
....................    Q=0 :   capturando el tiempo de flanco de subida 
....................    Q=1 :   capturando el tiempo de flanco de bajada 
....................    Q=2 :   relizando el calculo de ancho de pulso o periodo 
.................... */ 
.................... int Q_CCP = -1;      //estados de la captura de la frecuencia 
....................  
.................... /*se utiliza el TIMER3 como contador de tiempo del modulo CCP 
....................    TIMER3 con reloj interno (Fosc/4) 
....................    con divicion de frecuencia por 1 
....................    TIMER3 para ambos modulos CCP1 y CCP2 
.................... */ 
.................... int MODO_TIMER_CCP = T3_INTERNAL|T3_DIV_BY_1|T3_CCP1_TO_2; 
....................  
.................... unsigned int overflow_t3_counter = 0; 
.................... unsigned int32 tiempo_inicial = 0, tiempo_final = 0; 
....................  
.................... #INT_TIMER3 
.................... void timer3_isr(void){ 
....................    ++overflow_t3_counter; 
*
00F4:  INCF   xA0,F
.................... } 
....................  
00F6:  BCF    FA1.1
00F8:  GOTO   0078
.................... #INT_CCP1 
.................... void ccp1_isr(void){ 
....................    if(Q_CCP == -1){ 
00FC:  MOVF   x9E,W
00FE:  SUBLW  FF
0100:  BNZ   0112
....................    	setup_ccp1(CCP_CAPTURE_FE); 
0102:  BSF    F94.2
0104:  CLRF   FBD
0106:  MOVLW  04
0108:  MOVWF  FBD
010A:  CLRF   FB7
010C:  CLRF   FB6
....................    	Q_CCP = 0; 
010E:  CLRF   x9E
....................    }else if(Q_CCP == 0){ 
0110:  BRA    0170
0112:  MOVF   x9E,F
0114:  BNZ   013A
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
0116:  CLRF   01
0118:  CLRF   xBC
011A:  CLRF   xBD
011C:  MOVF   FBE,W
011E:  ADDWF  xBC,W
0120:  MOVWF  xA5
0122:  MOVF   FBF,W
0124:  ADDWFC xBD,W
0126:  MOVWF  xA6
0128:  MOVLW  00
012A:  ADDWFC xA0,W
012C:  MOVWF  xA7
012E:  MOVLW  00
0130:  ADDWFC 01,W
0132:  MOVWF  xA8
....................    	Q_CCP = 1; 
0134:  MOVLW  01
0136:  MOVWF  x9E
....................    }else if(Q_CCP == 1){ 
0138:  BRA    0170
013A:  DECFSZ x9E,W
013C:  BRA    0170
....................    	tiempo_inicial = tiempo_final; 
013E:  MOVFF  A8,A4
0142:  MOVFF  A7,A3
0146:  MOVFF  A6,A2
014A:  MOVFF  A5,A1
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_1; 
014E:  CLRF   01
0150:  CLRF   xBC
0152:  CLRF   xBD
0154:  MOVF   FBE,W
0156:  ADDWF  xBC,W
0158:  MOVWF  xA5
015A:  MOVF   FBF,W
015C:  ADDWFC xBD,W
015E:  MOVWF  xA6
0160:  MOVLW  00
0162:  ADDWFC xA0,W
0164:  MOVWF  xA7
0166:  MOVLW  00
0168:  ADDWFC 01,W
016A:  MOVWF  xA8
....................    	Q_CCP = 2; 
016C:  MOVLW  02
016E:  MOVWF  x9E
....................    } 
.................... } 
....................  
0170:  BCF    F9E.2
0172:  GOTO   0078
.................... #INT_CCP2 
.................... void ccp2_isr(void){ 
....................    /*if(Q_CCP == 0){ 
....................       Q_CCP = 1; 
....................       //tiempo_inicial = CCP_2; 
....................       tiempo_inicial = (0x10000*overflow_t3_counter)+CCP_2; 
....................    }else if(Q_CCP == 1){ 
....................       disable_interrupts(INT_TIMER3); 
....................       disable_interrupts(INT_CCP2);       
....................       Q_CCP = 2; 
....................       //tiempo_final = CCP_2; 
....................       tiempo_final = (0x10000*overflow_t3_counter)+CCP_2; 
....................    }*/ 
....................    if(Q_CCP == -1){ 
0176:  MOVF   x9E,W
0178:  SUBLW  FF
017A:  BNZ   018C
....................    	setup_ccp1(CCP_CAPTURE_FE); 
017C:  BSF    F94.2
017E:  CLRF   FBD
0180:  MOVLW  04
0182:  MOVWF  FBD
0184:  CLRF   FB7
0186:  CLRF   FB6
....................    	Q_CCP = 0; 
0188:  CLRF   x9E
....................    }else if(Q_CCP == 0){ 
018A:  BRA    01EA
018C:  MOVF   x9E,F
018E:  BNZ   01B4
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
0190:  CLRF   01
0192:  CLRF   xBC
0194:  CLRF   xBD
0196:  MOVF   FBB,W
0198:  ADDWF  xBC,W
019A:  MOVWF  xA5
019C:  MOVF   FBC,W
019E:  ADDWFC xBD,W
01A0:  MOVWF  xA6
01A2:  MOVLW  00
01A4:  ADDWFC xA0,W
01A6:  MOVWF  xA7
01A8:  MOVLW  00
01AA:  ADDWFC 01,W
01AC:  MOVWF  xA8
....................    	Q_CCP = 1; 
01AE:  MOVLW  01
01B0:  MOVWF  x9E
....................    }else if(Q_CCP == 1){ 
01B2:  BRA    01EA
01B4:  DECFSZ x9E,W
01B6:  BRA    01EA
....................    	tiempo_inicial = tiempo_final; 
01B8:  MOVFF  A8,A4
01BC:  MOVFF  A7,A3
01C0:  MOVFF  A6,A2
01C4:  MOVFF  A5,A1
....................    	tiempo_final = (65536*overflow_t3_counter)+CCP_2; 
01C8:  CLRF   01
01CA:  CLRF   xBC
01CC:  CLRF   xBD
01CE:  MOVF   FBB,W
01D0:  ADDWF  xBC,W
01D2:  MOVWF  xA5
01D4:  MOVF   FBC,W
01D6:  ADDWFC xBD,W
01D8:  MOVWF  xA6
01DA:  MOVLW  00
01DC:  ADDWFC xA0,W
01DE:  MOVWF  xA7
01E0:  MOVLW  00
01E2:  ADDWFC 01,W
01E4:  MOVWF  xA8
....................    	Q_CCP = 2; 
01E6:  MOVLW  02
01E8:  MOVWF  x9E
....................    } 
....................     
.................... } 
....................  
01EA:  BCF    FA1.0
01EC:  GOTO   0078
.................... int CP_init_ccp(){ 
....................    //configurar el timer1 
....................    setup_timer_3(MODO_TIMER_CCP); 
....................    T3CON.TMR3ON = 0; 
....................    set_timer3(0); 
....................    setup_ccp1(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    TRISC.TRISC1 = TRISC.TRISC2 = 1  ;                        
....................    return 0; 
.................... } 
....................  
.................... int CP_leer_ccp(int canal, int32 *buffer){ 
....................    //CODIGO DE MANEJO DE CCP 
....................    int32 resultado = 0; 
....................    enable_interrupts(GLOBAL);      	//habilita las interrupciones globales 
....................    enable_interrupts(INT_TIMER3); 
....................    set_timer3(0);      					//se reset timer  a 0 
....................    T3CON.TMR3ON = 1; 
....................    if(canal == CANAL_1){ 
....................       enable_interrupts(INT_CCP1);   //si es el canal 1 se habilita la interrupcion del modulo CCP1 
....................    }else if(canal == CANAL_2){ 
....................       enable_interrupts(INT_CCP2);   //si es el canal 2 se habilita la interrupcion del modulo CCP2 
....................    }else{return (1);} 
....................    while(Q_CCP != 2){;}             //espera a que se carguen los valores de los tiempos 
....................    disable_interrupts(INT_CCP1); 
....................    disable_interrupts(INT_CCP2); 
....................    setup_ccp2(MODO_CCP1); 
....................    setup_ccp2(MODO_CCP2); 
....................    Q_CCP = -1;                     //regreso al estado inicial para la proxima lectura 
....................    resultado = tiempo_final - tiempo_inicial;      //se calcula el periodo del pulso 
....................    T3CON.TMR3ON = 0;               //se desactiva del TIMER3 para no generar interrupciones 
....................    overflow_t3_counter = 0; 
....................    *buffer = resultado; 
....................    return (0); 
.................... } 
....................  
.................... #include "Nucleo.h" 
.................... /* 
.................... configuracione de hardware 
.................... oscilador: 20Mhz. con PLL:activo para dividir por 5 y obtener 4Mhz, aumentarlo a 96Mhz y dividirlo a 48Mhz para la frecuencia del modulo USB; 
.................... frecuencia de la CPU:24 Mhz; el FUSE CPIDIV3 para dividir los 96Mhz hasta 24MHz como frecuencia de entradad de la CPU  
....................  
....................  
.................... */ 
....................  
.................... #ifndef NUCLEO_H 
.................... #define NUCLEO_H 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... /* 
.................... #include <18F4620.h> 
.................... //#include "registros.h" 
.................... #device adc=10 
.................... */ 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                  //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) with PLL enable 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.1V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
....................  
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5							//PLL enable div by 5 input Osc 
.................... #FUSES CPUDIV3						//postscaler PLL div by 4                       
.................... #FUSES USBDIV						//enable USBDIV, div output PLL by 2 
.................... #FUSES VREGEN						//internal regulator USB enable 
.................... #FUSES ICPRT						 
.................... #FUSES CCP2C1						//CPP input/output multiplexed whit RC1 
....................  
.................... //cambiar el valor del clock si se cambia la frecuencia de la CPU 
.................... #use delay(clock=24000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1, FORCE_HW, RESTART_WDT)                    //directiva de compilador para el uso del bus I2C del microcontrolador 
.................... //#include <stdio.h> 
.................... //#include <stdlib.h> 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "analogo_digital.h" 
.................... #ifndef ANALOGO_DIGITAL_H 
.................... #define ANALOGO_DIGITAL_H 
....................  
....................  
.................... #ifndef CANAL_VELOCIDAD 
.................... 	#define CANAL_VELOCIDAD 0 
.................... #endif 
.................... #ifndef CANAL_ACCELERACION 
.................... 	#define CANAL_ACCELERACION 1 
.................... #endif 
.................... #ifndef CANAL_REVOLUCIONES 
.................... 	#define CANAL_REVOLUCIONES 2 
.................... #endif 
....................  
.................... int AD_init_adc(); 
.................... int AD_leer_canal(int canal, long *buffer); 
.................... #endif 
....................  
....................  
.................... #define ADC_TAD_MUL_2      0x08 
....................  
.................... int AD_init_adc(){ 
.................... 	setup_adc_ports(AN0_TO_AN2); 
....................  
.................... //corregir despues 
.................... #if getenv("CLOCK") == 4000000 
.................... 	setup_adc(ADC_CLOCK_DIV_8|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 8000000 
.................... 	setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 10000000 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #elif getenv("CLOCK") == 20000000 
.................... 	setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_2); 
.................... #else 
.................... 	setup_adc(ADC_CLOCK_DIV_32|ADC_TAD_MUL_2); 
.................... #endif 
.................... 	set_tris_a(0x07);		//RB0 a RB1 entradas 
.................... 	return 0; 
.................... } 
....................  
.................... int AD_leer_canal(int canal, long *buffer){ 
.................... 	int1 done; 
.................... 	set_adc_channel(canal); 
.................... 	read_adc(ADC_START_ONLY); 
.................... 	 
.................... 	do { 
.................... 		done = adc_done(); 
.................... 	}while(!done); 
.................... 	*buffer = read_adc(ADC_READ_ONLY); 
.................... 	return 0; 
.................... } 

Configuration Fuses:
   Word  1: CE3F   IESO FCMEN HSPLL PLL12 CPUDIV4 USBDIV
   Word  2: 0E39   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
